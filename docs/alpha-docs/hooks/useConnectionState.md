<!--
!!!! Autogenerated File !!!!
This file was created by @livekit/components-docs-gen and should not be changed manually.
The contents of this file can be replaced at any time which would lead to the loss of all manual changes.
-->

# useConnectionState

The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.

## Usage

```tsx
const connectionState = useConnectionState(room);
```

<!--USAGE_INSERT_MARKER-->


## Props

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| state | `ConnectionState` |  |  |
| participants | `Map<string, RemoteParticipant>` |  | map of sid: [[RemoteParticipant]] |
| activeSpeakers | `Participant[]` |  | list of participants that are actively speaking. when this changes a [[RoomEvent.ActiveSpeakersChanged]] event is fired |
| engine | `RTCEngine` |  | @internal |
| sid | `string` |  | server assigned unique room id |
| name | `string` |  | user assigned name, derived from JWT token |
| localParticipant | `LocalParticipant` |  | the current participant |
| metadata | `string \| undefined` |  | room metadata |
| options | `InternalRoomOptions` |  | options of room |
| prepareConnection | `(url: string) => Promise<void>` |  | prepares the connection to the livekit server by sending a HEAD request in order to 1. speed up DNS resolution 2. speed up TLS setup on the actual connection request throws an error if server is not reachable after the request timeout @experimental |
| connect | `(url: string, token: string, opts?: RoomConnectOptions \| undefined) => Promise<void>` |  |  |
| disconnect | `(stopTracks?: boolean \| undefined) => Promise<void>` |  | disconnects the room, emits [[RoomEvent.Disconnected]] |
| getParticipantByIdentity | `(identity: string) => Participant \| undefined` |  | retrieves a participant by identity @param identity @returns |
| isRecording | `boolean` |  | if the current room has a participant with `recorder: true` in its JWT grant |
| simulateScenario | `(scenario: string) => Promise<void>` |  | @internal for testing |
| startAudio | `() => Promise<void>` |  | Browsers have different policies regarding audio playback. Most requiring some form of user interaction (click/tap/etc). In those cases, audio will be silent until a click/tap triggering one of the following - `startAudio` - `getUserMedia` |
| canPlaybackAudio | `boolean` |  | Returns true if audio playback is enabled |
| getActiveAudioOutputDevice | `() => string` |  | Returns the active audio output device used in this room.  Note: to get the active `audioinput` or `videoinput` use [[LocalTrack.getDeviceId()]] @return the previously successfully set audio output device ID or an empty string if the default device is used. |
| switchActiveDevice | `(kind: MediaDeviceKind, deviceId: string) => Promise<void>` |  | Switches all active devices used in this room to the given device.  Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility) @param kind use `videoinput` for camera track, `audioinput` for microphone track, `audiooutput` to set speaker for all incoming audio tracks @param deviceId |
| simulateParticipants | `(options: SimulationOptions) => Promise<void>` |  | Allows to populate a room with simulated participants. No actual connection to a server will be established, all state is @experimental |
| emit | `<E extends keyof RoomEventCallbacks>(event: E, ...args: Parameters<RoomEventCallbacks[E]>) => boolean` |  |  |

