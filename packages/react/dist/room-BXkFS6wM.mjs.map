{"version":3,"file":"room-BXkFS6wM.mjs","sources":["../src/hooks/internal/useResizeObserver.ts","../src/hooks/internal/useObservableState.ts","../src/hooks/internal/useMediaQuery.ts","../src/hooks/useAudioPlayback.ts","../../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs","../src/mergeProps.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useConnectionQualityIndicator.ts","../src/hooks/useConnectionStatus.ts","../src/hooks/useDataChannel.ts","../src/hooks/useDisconnectButton.ts","../src/hooks/useFacingMode.ts","../src/hooks/useFocusToggle.ts","../src/hooks/useGridLayout.ts","../src/hooks/useIsMuted.ts","../src/hooks/useIsSpeaking.ts","../src/utils.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useLocalParticipantPermissions.ts","../src/hooks/useMediaDeviceSelect.ts","../src/hooks/useMediaDevices.ts","../src/hooks/useVisualStableUpdate.ts","../src/hooks/usePagination.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useParticipantTile.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/usePinnedTracks.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useStartAudio.ts","../src/hooks/useStartVideo.ts","../src/hooks/useSwipe.ts","../src/hooks/useChatToggle.ts","../src/hooks/useToken.ts","../src/hooks/useTrackMutedIndicator.ts","../src/hooks/useTrackToggle.ts","../src/hooks/useTracks.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useChat.ts","../src/hooks/usePersistentUserChoices.ts","../src/hooks/useIsEncrypted.ts","../src/hooks/useTrackVolume.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts","../src/hooks/useSequentialRoomConnectDisconnect.ts","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/hooks/useAgent.ts","../src/hooks/useSession.ts","../src/hooks/useEvents.ts","../src/hooks/useSessionMessages.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\r\n/* eslint-disable no-underscore-dangle */\r\nimport * as React from 'react';\r\n\r\nconst useLatest = <T>(current: T) => {\r\n  const storedValue = React.useRef(current);\r\n  React.useEffect(() => {\r\n    storedValue.current = current;\r\n  });\r\n  return storedValue;\r\n};\r\n\r\n/**\r\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\r\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\r\n *\r\n * @internal\r\n */\r\nexport function useResizeObserver<T extends HTMLElement>(\r\n  target: React.RefObject<T>,\r\n  callback: UseResizeObserverCallback,\r\n) {\r\n  const resizeObserver = getResizeObserver();\r\n  const storedCallback = useLatest(callback);\r\n\r\n  React.useLayoutEffect(() => {\r\n    let didUnsubscribe = false;\r\n\r\n    const targetEl = target.current;\r\n    if (!targetEl) return;\r\n\r\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\r\n      if (didUnsubscribe) return;\r\n      storedCallback.current(entry, observer);\r\n    }\r\n\r\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\r\n\r\n    return () => {\r\n      didUnsubscribe = true;\r\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\r\n    };\r\n  }, [target.current, resizeObserver, storedCallback]);\r\n\r\n  return resizeObserver?.observer;\r\n}\r\n\r\nfunction createResizeObserver() {\r\n  let ticking = false;\r\n  let allEntries: ResizeObserverEntry[] = [];\r\n\r\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\r\n\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\r\n    allEntries = allEntries.concat(entries);\r\n    if (!ticking) {\r\n      window.requestAnimationFrame(() => {\r\n        const triggered = new Set<Element>();\r\n        for (let i = 0; i < allEntries.length; i++) {\r\n          if (triggered.has(allEntries[i].target)) continue;\r\n          triggered.add(allEntries[i].target);\r\n          const cbs = callbacks.get(allEntries[i].target);\r\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\r\n        }\r\n        allEntries = [];\r\n        ticking = false;\r\n      });\r\n    }\r\n    ticking = true;\r\n  });\r\n\r\n  return {\r\n    observer,\r\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      observer.observe(target);\r\n      const cbs = callbacks.get(target) ?? [];\r\n      cbs.push(callback);\r\n      callbacks.set(target, cbs);\r\n    },\r\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      const cbs = callbacks.get(target) ?? [];\r\n      if (cbs.length === 1) {\r\n        observer.unobserve(target);\r\n        callbacks.delete(target);\r\n        return;\r\n      }\r\n      const cbIndex = cbs.indexOf(callback);\r\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\r\n      callbacks.set(target, cbs);\r\n    },\r\n  };\r\n}\r\n\r\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\r\n\r\nconst getResizeObserver = () =>\r\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\r\n\r\nexport type UseResizeObserverCallback = (\r\n  entry: ResizeObserverEntry,\r\n  observer: ResizeObserver,\r\n) => unknown;\r\n\r\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\r\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\r\n  React.useLayoutEffect(() => {\r\n    if (target.current) {\r\n      const { width, height } = target.current.getBoundingClientRect();\r\n      setSize({ width, height });\r\n    }\r\n  }, [target.current]);\r\n\r\n  const resizeCallback = React.useCallback(\r\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\r\n    [],\r\n  );\r\n  // Where the magic happens\r\n  useResizeObserver(target, resizeCallback);\r\n  return size;\r\n};\r\n","import * as React from 'react';\r\n// @ts-ignore\r\nimport type { Observable } from 'rxjs';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useObservableState<T>(\r\n  observable: Observable<T> | undefined,\r\n  startWith: T,\r\n  resetWhenObservableChanges = true,\r\n) {\r\n  const [state, setState] = React.useState<T>(startWith);\r\n  React.useEffect(() => {\r\n    if (resetWhenObservableChanges) {\r\n      setState(startWith);\r\n    }\r\n    // observable state doesn't run in SSR\r\n    if (typeof window === 'undefined' || !observable) return;\r\n    const subscription = observable.subscribe(setState);\r\n    return () => subscription.unsubscribe();\r\n  }, [observable, resetWhenObservableChanges]);\r\n  return state;\r\n}\r\n","import * as React from 'react';\r\n/**\r\n * Implementation used from https://github.com/juliencrn/usehooks-ts\r\n *\r\n * @internal\r\n */\r\nexport function useMediaQuery(query: string): boolean {\r\n  const getMatches = (query: string): boolean => {\r\n    // Prevents SSR issues\r\n    if (typeof window !== 'undefined') {\r\n      return window.matchMedia(query).matches;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\r\n\r\n  function handleChange() {\r\n    setMatches(getMatches(query));\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    const matchMedia = window.matchMedia(query);\r\n\r\n    // Triggered at the first client-side load and if query changes\r\n    handleChange();\r\n\r\n    // Listen matchMedia\r\n    if (matchMedia.addListener) {\r\n      matchMedia.addListener(handleChange);\r\n    } else {\r\n      matchMedia.addEventListener('change', handleChange);\r\n    }\r\n\r\n    return () => {\r\n      if (matchMedia.removeListener) {\r\n        matchMedia.removeListener(handleChange);\r\n      } else {\r\n        matchMedia.removeEventListener('change', handleChange);\r\n      }\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [query]);\r\n\r\n  return matches;\r\n}\r\n","import type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\r\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\r\n * `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useAudioPlayback(room?: Room): {\r\n  canPlayAudio: boolean;\r\n  startAudio: () => Promise<void>;\r\n} {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const startAudio = React.useCallback(async () => {\r\n    await roomEnsured.startAudio();\r\n  }, [roomEnsured]);\r\n\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  return { canPlayAudio, startAudio };\r\n}\r\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n\r\nimport clsx from 'clsx';\r\n\r\n/**\r\n * Calls all functions in the order they were chained with the same arguments.\r\n * @internal\r\n */\r\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\r\n  return (...args: any[]) => {\r\n    for (const callback of callbacks) {\r\n      if (typeof callback === 'function') {\r\n        try {\r\n          callback(...args);\r\n        } catch (e) {\r\n          console.error(e);\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\ninterface Props {\r\n  [key: string]: any;\r\n}\r\n\r\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\r\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? V : never;\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n  ? I\r\n  : never;\r\n\r\n/**\r\n * Merges multiple props objects together. Event handlers are chained,\r\n * classNames are combined, and ids are deduplicated - different ids\r\n * will trigger a side-effect and re-render components hooked up with `useId`.\r\n * For all other props, the last prop object overrides all previous ones.\r\n * @param args - Multiple sets of props to merge together.\r\n * @internal\r\n */\r\nexport function mergeProps<T extends Props[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\r\n  // Start with a base clone of the first argument. This is a lot faster than starting\r\n  // with an empty object and adding properties as we go.\r\n  const result: Props = { ...args[0] };\r\n  for (let i = 1; i < args.length; i++) {\r\n    const props = args[i];\r\n    for (const key in props) {\r\n      const a = result[key];\r\n      const b = props[key];\r\n\r\n      // Chain events\r\n      if (\r\n        typeof a === 'function' &&\r\n        typeof b === 'function' &&\r\n        // This is a lot faster than a regex.\r\n        key[0] === 'o' &&\r\n        key[1] === 'n' &&\r\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\r\n        key.charCodeAt(2) <= /* 'Z' */ 90\r\n      ) {\r\n        result[key] = chain(a, b);\r\n\r\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\r\n      } else if (\r\n        (key === 'className' || key === 'UNSAFE_className') &&\r\n        typeof a === 'string' &&\r\n        typeof b === 'string'\r\n      ) {\r\n        result[key] = clsx(a, b);\r\n      } else {\r\n        result[key] = b !== undefined ? b : a;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result as UnionToIntersection<TupleTypes<T>>;\r\n}\r\n","import { setupClearPinButton } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport type { ClearPinButtonProps } from '../components';\r\n\r\n/**\r\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\r\n * or your custom implementation of it component. It adds the `onClick` handler\r\n * to signal the `LayoutContext` that the tile in focus should be cleared.\r\n * @public\r\n */\r\nexport function useClearPinButton(props: ClearPinButtonProps) {\r\n  const { state, dispatch } = useLayoutContext().pin;\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className } = setupClearPinButton();\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      disabled: !state?.length,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'clear_pin' });\r\n      },\r\n    });\r\n    return mergedProps;\r\n  }, [props, dispatch, state]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface ConnectionQualityIndicatorOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/**\r\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\r\n * @example\r\n * ```tsx\r\n * const { quality } = useConnectionQualityIndicator();\r\n * // or\r\n * const { quality } = useConnectionQualityIndicator({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\r\n  const p = useEnsureParticipant(options.participant);\r\n\r\n  const { className, connectionQualityObserver } = React.useMemo(\r\n    () => setupConnectionQualityIndicator(p),\r\n    [p],\r\n  );\r\n\r\n  const quality = useObservableState(connectionQualityObserver, p.connectionQuality);\r\n\r\n  return { className, quality };\r\n}\r\n","import { connectionStateObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const connectionState = useConnectionState(room);\r\n * ```\r\n * @public\r\n */\r\nexport function useConnectionState(room?: Room) {\r\n  // passed room takes precedence, if not supplied get current room context\r\n  const r = useEnsureRoom(room);\r\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\r\n  const connectionState = useObservableState(observable, r.state);\r\n  return connectionState;\r\n}\r\n","import type { ReceivedDataMessage } from '@livekit/components-core';\r\nimport { setupDataMessageHandler } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { DataPublishOptions } from 'livekit-client';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\r\n  isSending: boolean;\r\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\r\n  message: ReceivedDataMessage<T> | undefined;\r\n};\r\n\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\r\n *\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants via the 'chat' topic.\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n *\r\n * @example\r\n * ```tsx\r\n * // Receive all messages (no topic filtering)\r\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topic: T,\r\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\r\n): UseDataChannelReturnType<T>;\r\n\r\n/**\r\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\r\n *\r\n * @public\r\n */\r\nexport function useDataChannel(\r\n  onMessage?: (msg: ReceivedDataMessage) => void,\r\n): UseDataChannelReturnType;\r\n/**\r\n * @internal\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\r\n  callback?: (msg: ReceivedDataMessage<T>) => void,\r\n) {\r\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\r\n\r\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\r\n  const room = useRoomContext();\r\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\r\n    () => setupDataMessageHandler(room, topic, onMessage),\r\n    [room, topic, onMessage],\r\n  );\r\n\r\n  const message = useObservableState(messageObservable, undefined);\r\n  const isSending = useObservableState(isSendingObservable, false);\r\n\r\n  return {\r\n    message,\r\n    send,\r\n    isSending,\r\n  };\r\n}\r\n","import { setupDisconnectButton } from '@livekit/components-core';\r\nimport { ConnectionState } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { DisconnectButtonProps } from '../components';\r\nimport { useRoomContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useConnectionState } from './useConnectionStatus';\r\n\r\n/**\r\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\r\n * custom implementation of it. It adds onClick handler to the button to disconnect\r\n * from the room.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { buttonProps } = useDisconnectButton(buttonProps);\r\n * return <button {...buttonProps}>Disconnect</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useDisconnectButton(props: DisconnectButtonProps) {\r\n  const room = useRoomContext();\r\n  const connectionState = useConnectionState(room);\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className, disconnect } = setupDisconnectButton(room);\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      onClick: () => disconnect(props.stopTracks ?? true),\r\n      disabled: connectionState === ConnectionState.Disconnected,\r\n    });\r\n    return mergedProps;\r\n  }, [room, props, connectionState]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\r\n\r\n/**\r\n * Try to determine the `facingMode` of a local participant video track.\r\n * @remarks\r\n * Works only on local video tracks.\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\r\n * @alpha\r\n */\r\nexport function useFacingMode(\r\n  trackReference: TrackReferenceOrPlaceholder,\r\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\r\n  if (trackReference.publication instanceof LocalTrackPublication) {\r\n    const localTrack = trackReference.publication.track;\r\n    if (localTrack) {\r\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\r\n      return facingMode;\r\n    }\r\n  }\r\n  return 'undefined';\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\r\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseFocusToggleProps {\r\n  trackRef?: TrackReferenceOrPlaceholder;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\r\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\r\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const layoutContext = useMaybeLayoutContext();\r\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\r\n\r\n  const inFocus: boolean = React.useMemo(() => {\r\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\r\n  }, [trackReference, layoutContext?.pin.state]);\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\r\n          // Call user defined on click callbacks.\r\n          props.onClick?.(event);\r\n\r\n          // Set or clear focus based on current focus state.\r\n          if (inFocus) {\r\n            layoutContext?.pin.dispatch?.({\r\n              msg: 'clear_pin',\r\n            });\r\n          } else {\r\n            layoutContext?.pin.dispatch?.({\r\n              msg: 'set_pin',\r\n              trackReference,\r\n            });\r\n          }\r\n        },\r\n      }),\r\n    [props, className, trackReference, inFocus, layoutContext?.pin],\r\n  );\r\n\r\n  return { mergedProps, inFocus };\r\n}\r\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\r\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useSize } from './internal';\r\n\r\n/**\r\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\r\n * If the available screen space is not enough, it will reduce the number of maximum visible\r\n * tiles and select a layout that still works visually within the given limitations.\r\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\r\n * while trying to display important tiles such as speaking participants or screen shares.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { layout } = useGridLayout(gridElement, trackCount);\r\n * ```\r\n * @public\r\n */\r\nexport function useGridLayout(\r\n  /** HTML element that contains the grid. */\r\n  gridElement: React.RefObject<HTMLDivElement>,\r\n  /** Count of tracks that should get layed out */\r\n  trackCount: number,\r\n  options: {\r\n    gridLayouts?: GridLayoutDefinition[];\r\n  } = {},\r\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\r\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\r\n  const { width, height } = useSize(gridElement);\r\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\r\n\r\n  React.useEffect(() => {\r\n    if (gridElement.current && layout) {\r\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\r\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\r\n    }\r\n  }, [gridElement, layout]);\r\n\r\n  return {\r\n    layout,\r\n    containerWidth: width,\r\n    containerHeight: height,\r\n  };\r\n}\r\n","import {\r\n  type TrackReferenceOrPlaceholder,\r\n  getTrackReferenceId,\r\n  mutedObserver,\r\n} from '@livekit/components-core';\r\nimport type { Participant, Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\n\r\n/** @public */\r\nexport interface UseIsMutedOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/**\r\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\r\n * It returns a `boolean` that indicates if the track is muted or not.\r\n *\r\n * @example With a track reference\r\n * ```tsx\r\n * const isMuted = useIsMuted(track);\r\n * ```\r\n *\r\n * @example With a track source / participant\r\n * ```tsx\r\n * const isMuted = useIsMuted('camera', { participant });\r\n * ```\r\n *\r\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\r\n * @param options - Additional options when using a `Track.Source`\r\n * @returns boolean indicating if the track is muted\r\n *\r\n * @public\r\n */\r\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\r\nexport function useIsMuted(\r\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\r\n  options: UseIsMutedOptions = {},\r\n) {\r\n  const passedParticipant =\r\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\r\n  const p = useEnsureParticipant(passedParticipant);\r\n  const ref =\r\n    typeof sourceOrTrackRef === 'string'\r\n      ? { participant: p, source: sourceOrTrackRef }\r\n      : sourceOrTrackRef;\r\n  const [isMuted, setIsMuted] = React.useState(\r\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\r\n    return () => listener.unsubscribe();\r\n  }, [getTrackReferenceId(ref)]);\r\n\r\n  return isMuted;\r\n}\r\n","import { createIsSpeakingObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\r\n * @example\r\n * ```tsx\r\n * const isSpeaking = useIsSpeaking(participant);\r\n * ```\r\n * @public\r\n */\r\nexport function useIsSpeaking(participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\r\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\r\n\r\n  return isSpeaking;\r\n}\r\n","import * as React from 'react';\r\nimport { mergeProps as mergePropsReactAria } from './mergeProps';\r\nimport { log } from '@livekit/components-core';\r\nimport clsx from 'clsx';\r\n\r\n/** @internal */\r\nexport function isProp<U extends HTMLElement, T extends React.HTMLAttributes<U>>(\r\n  prop: T | undefined,\r\n): prop is T {\r\n  return prop !== undefined;\r\n}\r\n\r\n/** @internal */\r\nexport function mergeProps<\r\n  U extends HTMLElement,\r\n  T extends Array<React.HTMLAttributes<U> | undefined>,\r\n>(...props: T) {\r\n  return mergePropsReactAria(...props.filter(isProp));\r\n}\r\n\r\n/** @internal */\r\nexport function cloneSingleChild(\r\n  children: React.ReactNode | React.ReactNode[],\r\n  props?: Record<string, any>,\r\n  key?: any,\r\n) {\r\n  return React.Children.map(children, (child) => {\r\n    // Checking isValidElement is the safe way and avoids a typescript\r\n    // error too.\r\n    if (React.isValidElement(child) && React.Children.only(children)) {\r\n      if (child.props.className) {\r\n        // make sure we retain classnames of both passed props and child\r\n        props ??= {};\r\n        props.className = clsx(child.props.className, props.className);\r\n        props.style = { ...child.props.style, ...props.style };\r\n      }\r\n      return React.cloneElement(child, { ...props, key });\r\n    }\r\n    return child;\r\n  });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function warnAboutMissingStyles(el?: HTMLElement) {\r\n  if (\r\n    typeof window !== 'undefined' &&\r\n    typeof process !== 'undefined' &&\r\n    // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n    (process?.env?.NODE_ENV === 'dev' ||\r\n      // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n      process?.env?.NODE_ENV === 'development')\r\n  ) {\r\n    const target = el ?? document.querySelector('.lk-room-container');\r\n    if (target && !getComputedStyle(target).getPropertyValue('--lk-has-imported-styles')) {\r\n      log.warn(\r\n        \"It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page.\",\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @internal\r\n * used to stringify room options to detect dependency changes for react hooks.\r\n * Replaces processors and e2ee options with strings.\r\n */\r\nexport function roomOptionsStringifyReplacer(key: string, val: unknown) {\r\n  if (key === 'processor' && val && typeof val === 'object' && 'name' in val) {\r\n    return val.name;\r\n  }\r\n  if (key === 'e2ee' && val) {\r\n    return 'e2ee-enabled';\r\n  }\r\n  return val;\r\n}\r\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\r\nimport type { DisconnectReason } from 'livekit-client';\r\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { HTMLAttributes } from 'react';\r\n\r\nimport type { LiveKitRoomProps } from '../components';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { roomOptionsStringifyReplacer } from '../utils';\r\n\r\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\r\n  connect: true,\r\n  audio: false,\r\n  video: false,\r\n};\r\n\r\n/**\r\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\r\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { room, htmlProps } = useLiveKitRoom();\r\n * return <div {...htmlProps}>...</div>;\r\n * ```\r\n * @public\r\n */\r\nexport function useLiveKitRoom<T extends HTMLElement>(\r\n  props: LiveKitRoomProps,\r\n): {\r\n  room: Room | undefined;\r\n  htmlProps: HTMLAttributes<T>;\r\n} {\r\n  const {\r\n    token,\r\n    serverUrl,\r\n    options,\r\n    room: passedRoom,\r\n    connectOptions,\r\n    connect,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMediaDeviceFailure,\r\n    onEncryptionError,\r\n    simulateParticipants,\r\n    ...rest\r\n  } = { ...defaultRoomProps, ...props };\r\n  if (options && passedRoom) {\r\n    log.warn(\r\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\r\n    );\r\n  }\r\n\r\n  const [room, setRoom] = React.useState<Room | undefined>();\r\n\r\n  const shouldConnect = React.useRef(connect);\r\n\r\n  React.useEffect(() => {\r\n    setRoom(passedRoom ?? new Room(options));\r\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\r\n\r\n  const htmlProps = React.useMemo(() => {\r\n    const { className } = setupLiveKitRoom();\r\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\r\n  }, [rest]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    const onSignalConnected = () => {\r\n      const localP = room.localParticipant;\r\n\r\n      log.debug('trying to publish local tracks');\r\n      Promise.all([\r\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\r\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\r\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\r\n      ]).catch((e) => {\r\n        log.warn(e);\r\n        onError?.(e as Error);\r\n      });\r\n    };\r\n\r\n    const handleMediaDeviceError = (e: Error, kind?: MediaDeviceKind) => {\r\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\r\n      onMediaDeviceFailure?.(mediaDeviceFailure, kind);\r\n    };\r\n    const handleEncryptionError = (e: Error) => {\r\n      onEncryptionError?.(e);\r\n    };\r\n    const handleDisconnected = (reason?: DisconnectReason) => {\r\n      onDisconnected?.(reason);\r\n    };\r\n    const handleConnected = () => {\r\n      onConnected?.();\r\n    };\r\n\r\n    room\r\n      .on(RoomEvent.SignalConnected, onSignalConnected)\r\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\r\n      .on(RoomEvent.Disconnected, handleDisconnected)\r\n      .on(RoomEvent.Connected, handleConnected);\r\n\r\n    return () => {\r\n      room\r\n        .off(RoomEvent.SignalConnected, onSignalConnected)\r\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\r\n        .off(RoomEvent.Disconnected, handleDisconnected)\r\n        .off(RoomEvent.Connected, handleConnected);\r\n    };\r\n  }, [\r\n    room,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onError,\r\n    onEncryptionError,\r\n    onMediaDeviceFailure,\r\n    onConnected,\r\n    onDisconnected,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n\r\n    if (simulateParticipants) {\r\n      room.simulateParticipants({\r\n        participants: {\r\n          count: simulateParticipants,\r\n        },\r\n        publish: {\r\n          audio: true,\r\n          useRealTracks: true,\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (connect) {\r\n      shouldConnect.current = true;\r\n      log.debug('connecting');\r\n      if (!token) {\r\n        log.debug('no token yet');\r\n        return;\r\n      }\r\n      if (!serverUrl) {\r\n        log.warn('no livekit url provided');\r\n        onError?.(Error('no livekit url provided'));\r\n        return;\r\n      }\r\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\r\n        log.warn(e);\r\n        if (shouldConnect.current === true) {\r\n          onError?.(e as Error);\r\n        }\r\n      });\r\n    } else {\r\n      log.debug('disconnecting because connect is false');\r\n      shouldConnect.current = false;\r\n      room.disconnect();\r\n    }\r\n  }, [\r\n    connect,\r\n    token,\r\n    JSON.stringify(connectOptions),\r\n    room,\r\n    onError,\r\n    serverUrl,\r\n    simulateParticipants,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    return () => {\r\n      log.info('disconnecting on onmount');\r\n      room.disconnect();\r\n    };\r\n  }, [room]);\r\n\r\n  return { room, htmlProps };\r\n}\r\n","import type { ParticipantMedia } from '@livekit/components-core';\r\nimport { observeParticipantMedia } from '@livekit/components-core';\r\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseLocalParticipantOptions {\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useLocalParticipant` hook returns the local participant and the associated state\r\n * around the participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { localParticipant } = useLocalParticipant();\r\n * ```\r\n * @public\r\n */\r\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\r\n\r\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(localParticipant.isCameraEnabled);\r\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\r\n    localParticipant.isScreenShareEnabled,\r\n  );\r\n\r\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\r\n    localParticipant.lastMicrophoneError,\r\n  );\r\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\r\n\r\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\r\n    undefined,\r\n  );\r\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\r\n\r\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\r\n    setIsCameraEnabled(media.isCameraEnabled);\r\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\r\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\r\n    setCameraTrack(media.cameraTrack);\r\n    setMicrophoneTrack(media.microphoneTrack);\r\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\r\n    setLastCameraError(media.participant.lastCameraError);\r\n    setLocalParticipant(media.participant);\r\n  };\r\n  React.useEffect(() => {\r\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\r\n    // TODO also listen to permission and metadata etc. events\r\n    return () => listener.unsubscribe();\r\n  }, [room]);\r\n\r\n  return {\r\n    isMicrophoneEnabled,\r\n    isScreenShareEnabled,\r\n    isCameraEnabled,\r\n    microphoneTrack,\r\n    cameraTrack,\r\n    lastMicrophoneError,\r\n    lastCameraError,\r\n    localParticipant,\r\n  };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\r\n * ```\r\n * @public\r\n */\r\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\r\n  const room = useRoomContext();\r\n  const permissionObserver = React.useMemo(\r\n    () => participantPermissionObserver(room.localParticipant),\r\n    [room],\r\n  );\r\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\r\n  return permissions;\r\n}\r\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\r\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface UseMediaDeviceSelectProps {\r\n  kind: MediaDeviceKind;\r\n  room?: Room;\r\n  track?: LocalAudioTrack | LocalVideoTrack;\r\n  /**\r\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\r\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\r\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\r\n   * appropriate permissions.\r\n   *\r\n   * @see {@link MediaDeviceMenu}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\r\n   */\r\n  requestPermissions?: boolean;\r\n  /**\r\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\r\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\r\n   * Most commonly this will emit a MediaDeviceError\r\n   */\r\n  onError?: (e: Error) => void;\r\n}\r\n\r\n/**\r\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\r\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\r\n * and a function to set the the active device.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\r\n * ```\r\n * @public\r\n */\r\nexport function useMediaDeviceSelect({\r\n  kind,\r\n  room,\r\n  track,\r\n  requestPermissions,\r\n  onError,\r\n}: UseMediaDeviceSelectProps) {\r\n  const roomContext = useMaybeRoomContext();\r\n\r\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\r\n\r\n  // List of all devices.\r\n  const deviceObserver = React.useMemo(\r\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\r\n    [kind, requestPermissions, onError],\r\n  );\r\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\r\n  // Active device management.\r\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\r\n    roomFallback?.getActiveDevice(kind) ?? 'default',\r\n  );\r\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\r\n    () => setupDeviceSelector(kind, roomFallback),\r\n    [kind, roomFallback, track],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\r\n      if (!deviceId) {\r\n        return;\r\n      }\r\n      log.info('setCurrentDeviceId', deviceId);\r\n      setCurrentDeviceId(deviceId);\r\n    });\r\n    return () => {\r\n      listener?.unsubscribe();\r\n    };\r\n  }, [activeDeviceObservable]);\r\n\r\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\r\n}\r\n","import * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { createMediaDeviceObserver } from '@livekit/components-core';\r\n\r\n/**\r\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\r\n *\r\n * @example\r\n * ```tsx\r\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\r\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\r\n * ```\r\n * @public\r\n */\r\nexport function useMediaDevices({\r\n  kind,\r\n  onError,\r\n}: {\r\n  kind: MediaDeviceKind;\r\n  onError?: (e: Error) => void;\r\n}) {\r\n  const deviceObserver = React.useMemo(\r\n    () => createMediaDeviceObserver(kind, onError),\r\n    [kind, onError],\r\n  );\r\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\r\n  return devices;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseVisualStableUpdateOptions {\r\n  /** Overwrites the default sort function. */\r\n  customSortFunction?: (\r\n    trackReferences: TrackReferenceOrPlaceholder[],\r\n  ) => TrackReferenceOrPlaceholder[];\r\n}\r\n\r\n/**\r\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\r\n * in an array. The algorithm only starts to update when there are more items than visually fit\r\n * on a page. If this is the case, it will make sure that speaking participants move to the first\r\n * page and are always visible.\r\n * @remarks\r\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\r\n * or start speaking.\r\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\r\n *\r\n * @example\r\n * ```tsx\r\n * const trackRefs = useTracks();\r\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\r\n * ```\r\n * @public\r\n */\r\nexport function useVisualStableUpdate(\r\n  /** `TrackReference`s to display in the grid.  */\r\n  trackReferences: TrackReferenceOrPlaceholder[],\r\n  maxItemsOnPage: number,\r\n  options: UseVisualStableUpdateOptions = {},\r\n): TrackReferenceOrPlaceholder[] {\r\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\r\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\r\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\r\n\r\n  const sortedTrackRefs =\r\n    typeof options.customSortFunction === 'function'\r\n      ? options.customSortFunction(trackReferences)\r\n      : sortTrackReferences(trackReferences);\r\n\r\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\r\n  if (layoutChanged === false) {\r\n    try {\r\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\r\n    } catch (error) {\r\n      log.error('Error while running updatePages(): ', error);\r\n    }\r\n  }\r\n\r\n  // Save info for to compare against in the next update cycle.\r\n  if (layoutChanged) {\r\n    lastTrackRefs.current = sortedTrackRefs;\r\n  } else {\r\n    lastTrackRefs.current = updatedTrackRefs;\r\n  }\r\n  lastMaxItemsOnPage.current = maxItemsOnPage;\r\n\r\n  return updatedTrackRefs;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\r\n\r\n/**\r\n * The `usePagination` hook implements simple pagination logic for use with arrays.\r\n * @example\r\n * ```tsx\r\n * const tracks = useTracks();\r\n * const pagination = usePagination(4, tracks);\r\n *\r\n * <TrackLoop tracks={pagination.tracks} />\r\n * ```\r\n * @alpha\r\n */\r\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\r\n  const [currentPage, setCurrentPage] = React.useState(1);\r\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\r\n  if (currentPage > totalPageCount) {\r\n    setCurrentPage(totalPageCount);\r\n  }\r\n  const lastItemIndex = currentPage * itemPerPage;\r\n  const firstItemIndex = lastItemIndex - itemPerPage;\r\n\r\n  const changePage = (direction: 'next' | 'previous') => {\r\n    setCurrentPage((state) => {\r\n      if (direction === 'next') {\r\n        if (state === totalPageCount) {\r\n          return state;\r\n        }\r\n        return state + 1;\r\n      } else {\r\n        if (state === 1) {\r\n          return state;\r\n        }\r\n        return state - 1;\r\n      }\r\n    });\r\n  };\r\n\r\n  const goToPage = (num: number) => {\r\n    if (num > totalPageCount) {\r\n      setCurrentPage(totalPageCount);\r\n    } else if (num < 1) {\r\n      setCurrentPage(1);\r\n    } else {\r\n      setCurrentPage(num);\r\n    }\r\n  };\r\n\r\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\r\n\r\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\r\n\r\n  return {\r\n    totalPageCount,\r\n    nextPage: () => changePage('next'),\r\n    prevPage: () => changePage('previous'),\r\n    setPage: goToPage,\r\n    firstItemIndex,\r\n    lastItemIndex,\r\n    tracks: tracksOnPage,\r\n    currentPage,\r\n  };\r\n}\r\n\r\nexport default usePagination;\r\n","import { participantInfoObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { identity, name, metadata } = useParticipantInfo({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantInfoOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\r\n  let p = useMaybeParticipantContext();\r\n  if (props.participant) {\r\n    p = props.participant;\r\n  }\r\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\r\n  const { identity, name, metadata } = useObservableState(infoObserver, {\r\n    name: p?.name,\r\n    identity: p?.identity,\r\n    metadata: p?.metadata,\r\n  });\r\n\r\n  return { identity, name, metadata };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\n\r\n/**\r\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const permissions = useParticipantPermissions({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantPermissionsOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantPermissions(\r\n  options: UseParticipantPermissionsOptions = {},\r\n): ParticipantPermission | undefined {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\r\n  const permissions = useObservableState(permissionObserver, p.permissions);\r\n  return permissions;\r\n}\r\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { setupParticipantTile } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureTrackRef } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useFacingMode } from './useFacingMode';\r\nimport { useIsMuted } from './useIsMuted';\r\nimport { useIsSpeaking } from './useIsSpeaking';\r\nimport { Track } from 'livekit-client';\r\n\r\n/** @public */\r\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\r\n  /** The track reference to display. */\r\n  trackRef?: TrackReferenceOrPlaceholder;\r\n  disableSpeakingIndicator?: boolean;\r\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\r\n  htmlProps: React.HTMLAttributes<T>;\r\n}\r\n\r\n/**\r\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\r\n * @remarks\r\n * The returned props include many data attributes that are useful for CSS styling purposes because they\r\n * indicate the state of the participant and the track.\r\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\r\n * @public\r\n */\r\nexport function useParticipantTile<T extends HTMLElement>({\r\n  trackRef,\r\n  onParticipantClick,\r\n  disableSpeakingIndicator,\r\n  htmlProps,\r\n}: UseParticipantTileProps<T>) {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const mergedProps = React.useMemo(() => {\r\n    const { className } = setupParticipantTile();\r\n    return mergeProps(htmlProps, {\r\n      className,\r\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\r\n        htmlProps.onClick?.(event);\r\n        if (typeof onParticipantClick === 'function') {\r\n          const track =\r\n            trackReference.publication ??\r\n            trackReference.participant.getTrackPublication(trackReference.source);\r\n          onParticipantClick({ participant: trackReference.participant, track });\r\n        }\r\n      },\r\n    });\r\n  }, [\r\n    htmlProps,\r\n    onParticipantClick,\r\n    trackReference.publication,\r\n    trackReference.source,\r\n    trackReference.participant,\r\n  ]);\r\n\r\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\r\n  const micRef = React.useMemo(() => {\r\n    return {\r\n      participant: trackReference.participant,\r\n      source: Track.Source.Microphone,\r\n      publication: micTrack,\r\n    };\r\n  }, [micTrack, trackReference.participant]);\r\n  const isVideoMuted = useIsMuted(trackReference);\r\n  const isAudioMuted = useIsMuted(micRef);\r\n  const isSpeaking = useIsSpeaking(trackReference.participant);\r\n  const facingMode = useFacingMode(trackReference);\r\n  return {\r\n    elementProps: {\r\n      'data-lk-audio-muted': isAudioMuted,\r\n      'data-lk-video-muted': isVideoMuted,\r\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\r\n      'data-lk-local-participant': trackReference.participant.isLocal,\r\n      'data-lk-source': trackReference.source,\r\n      'data-lk-facing-mode': facingMode,\r\n      ...mergedProps,\r\n    } as React.HTMLAttributes<T>,\r\n  };\r\n}\r\n","import { connectedParticipantsObserver } from '@livekit/components-core';\r\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useRemoteParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\r\n\r\n  React.useEffect(() => {\r\n    const listener = connectedParticipantsObserver(room, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n    }).subscribe(setParticipants);\r\n    return () => listener.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\r\n  return participants;\r\n}\r\n","import type { Room, RoomEvent } from 'livekit-client';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipants(options: UseParticipantsOptions = {}) {\r\n  const remoteParticipants = useRemoteParticipants(options);\r\n  const { localParticipant } = useLocalParticipant(options);\r\n\r\n  return React.useMemo(\r\n    () => [localParticipant, ...remoteParticipants],\r\n    [localParticipant, remoteParticipants],\r\n  );\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { LayoutContextType } from '../context';\r\nimport { useEnsureLayoutContext } from '../context';\r\n\r\n/**\r\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\r\n * @remarks\r\n * To function properly, this hook must be called within a `LayoutContext`.\r\n * @example\r\n * ```tsx\r\n * const pinnedTracks = usePinnedTracks();\r\n * ```\r\n * @public\r\n */\r\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\r\n  layoutContext = useEnsureLayoutContext(layoutContext);\r\n  return React.useMemo(() => {\r\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\r\n      return layoutContext.pin.state;\r\n    }\r\n    return [];\r\n  }, [layoutContext.pin.state]);\r\n}\r\n","import {\r\n  type ParticipantIdentifier,\r\n  connectedParticipantObserver,\r\n  participantByIdentifierObserver,\r\n} from '@livekit/components-core';\r\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\r\n   */\r\n  updateOnlyOn?: ParticipantEvent[];\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identifier: ParticipantIdentifier,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant('Russ');\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identity: string,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\nexport function useRemoteParticipant(\r\n  identityOrIdentifier: string | ParticipantIdentifier,\r\n  options: UseRemoteParticipantOptions = {},\r\n): RemoteParticipant | undefined {\r\n  const room = useRoomContext();\r\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (typeof identityOrIdentifier === 'string') {\r\n      return connectedParticipantObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    } else {\r\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    }\r\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\r\n\r\n  // Using `wrapperParticipant` to ensure a new object reference,\r\n  // triggering a re-render when the participant events fire.\r\n  const [participantWrapper, setParticipantWrapper] = React.useState({\r\n    p: undefined as RemoteParticipant | undefined,\r\n  });\r\n  React.useEffect(() => {\r\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\r\n    return () => listener.unsubscribe();\r\n  }, [observable]);\r\n\r\n  return participantWrapper.p;\r\n}\r\n","import { roomInfoObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\r\n * @remarks\r\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { name, metadata } = useRoomInfo();\r\n * ```\r\n * @public\r\n */\r\nexport interface UseRoomInfoOptions {\r\n  room?: Room;\r\n}\r\n\r\n/** @public */\r\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\r\n  const { name, metadata } = useObservableState(infoObserver, {\r\n    name: room.name,\r\n    metadata: room.metadata,\r\n  });\r\n\r\n  return { name, metadata };\r\n}\r\n","import { activeSpeakerObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { Room } from 'livekit-client';\r\n\r\n/** @public */\r\nexport type UseSpeakingParticipantsOptions = {\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\r\n *\r\n * @example\r\n * ```tsx\r\n * const activeSpeakers = useSpeakingParticipants();\r\n * ```\r\n * @public\r\n */\r\nexport function useSpeakingParticipants(options?: UseSpeakingParticipantsOptions) {\r\n  const ensuredRoom = useEnsureRoom(options?.room);\r\n\r\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(ensuredRoom), [ensuredRoom]);\r\n  const activeSpeakers = useObservableState(speakerObserver, ensuredRoom.activeSpeakers);\r\n  return activeSpeakers;\r\n}\r\n","import { sortParticipants } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\r\n\r\n/**\r\n * The `useSortedParticipants` hook returns the participants sorted by importance.\r\n * @public\r\n */\r\nexport function useSortedParticipants(participants: Array<Participant>) {\r\n  const [sortedParticipants, setSortedParticipants] = React.useState(\r\n    sortParticipants(participants),\r\n  );\r\n  const activeSpeakers = useSpeakingParticipants();\r\n\r\n  React.useEffect(() => {\r\n    setSortedParticipants(sortParticipants(participants));\r\n  }, [activeSpeakers, participants]);\r\n  return sortedParticipants;\r\n}\r\n","import { setupStartAudio } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @alpha */\r\nexport interface UseStartAudioProps {\r\n  room?: Room;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\r\n * that indicates whether audio playback is allowed in the current context,\r\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\r\n    () => setupStartAudio(),\r\n    [],\r\n  );\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: () => {\r\n          handleStartAudioPlayback(roomEnsured);\r\n        },\r\n        style: { display: canPlayAudio ? 'none' : 'block' },\r\n      }),\r\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\r\n  );\r\n\r\n  return { mergedProps, canPlayAudio };\r\n}\r\n","import { setupStartVideo } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @alpha */\r\nexport interface UseStartVideoProps {\r\n  room?: Room;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\r\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\r\n * that indicates whether video playback is allowed in the current context,\r\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\r\n *\r\n * @alpha\r\n */\r\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\r\n    () => setupStartVideo(),\r\n    [],\r\n  );\r\n  const observable = React.useMemo(\r\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\r\n  );\r\n  const { canPlayVideo } = useObservableState(observable, {\r\n    canPlayVideo: roomEnsured.canPlaybackVideo,\r\n  });\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: () => {\r\n          handleStartVideoPlayback(roomEnsured);\r\n        },\r\n        style: { display: canPlayVideo ? 'none' : 'block' },\r\n      }),\r\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\r\n  );\r\n\r\n  return { mergedProps, canPlayVideo };\r\n}\r\n","import * as React from 'react';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport type UseSwipeOptions = {\r\n  minSwipeDistance?: number;\r\n  onLeftSwipe?: () => void;\r\n  onRightSwipe?: () => void;\r\n};\r\n\r\n/**\r\n * Simple implementation to detect horizontal swipe actions.\r\n * Accepts callbacks for on right and left swipes.\r\n * @example\r\n * ```tsx\r\n *  <div\r\n      onTouchStart={onTouchStart}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n    >\r\n * ```\r\n * @alpha\r\n */\r\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\r\n  const touchStart = React.useRef<number | null>(null);\r\n  const touchEnd = React.useRef<number | null>(null);\r\n\r\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\r\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\r\n\r\n  const onTouchStart = (event: TouchEvent) => {\r\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\r\n    touchStart.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchMove = (event: TouchEvent) => {\r\n    touchEnd.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchEnd = React.useCallback(() => {\r\n    if (!touchStart.current || !touchEnd.current) {\r\n      return;\r\n    }\r\n    const distance = touchStart.current - touchEnd.current;\r\n    const isLeftSwipe = distance > minSwipeDistance;\r\n    const isRightSwipe = distance < -minSwipeDistance;\r\n\r\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\r\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\r\n  }, [minSwipeDistance, options]);\r\n\r\n  React.useEffect(() => {\r\n    const elementCopy = element.current;\r\n    if (elementCopy) {\r\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\r\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\r\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\r\n    }\r\n    return () => {\r\n      if (elementCopy) {\r\n        elementCopy.removeEventListener('touchstart', onTouchStart);\r\n        elementCopy.removeEventListener('touchmove', onTouchMove);\r\n        elementCopy.removeEventListener('touchend', onTouchEnd);\r\n      }\r\n    };\r\n  }, [element, onTouchEnd]);\r\n}\r\n","import { setupChatToggle } from '@livekit/components-core';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseChatToggleProps {\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\r\n * @remarks\r\n * Depends on the `LayoutContext` to work properly.\r\n * @see {@link ChatToggle}, {@link Chat}\r\n * @public\r\n */\r\nexport function useChatToggle({ props }: UseChatToggleProps) {\r\n  const { dispatch, state } = useLayoutContext().widget;\r\n  const { className } = React.useMemo(() => setupChatToggle(), []);\r\n\r\n  const mergedProps = React.useMemo(() => {\r\n    return mergeProps(props, {\r\n      className,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\r\n      },\r\n      'aria-pressed': state?.showChat ? 'true' : 'false',\r\n      'data-lk-unread-msgs': state\r\n        ? state.unreadMessages < 10\r\n          ? state.unreadMessages.toFixed(0)\r\n          : '9+'\r\n        : '0',\r\n    });\r\n  }, [props, className, dispatch, state]);\r\n\r\n  return { mergedProps };\r\n}\r\n","import { log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UserInfo {\r\n  identity?: string;\r\n  name?: string;\r\n  metadata?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface UseTokenOptions {\r\n  userInfo?: UserInfo;\r\n}\r\n\r\n/**\r\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\r\n *\r\n * @example\r\n * ```tsx\r\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\r\n * ```\r\n * @public */\r\nexport function useToken(\r\n  tokenEndpoint: string | undefined,\r\n  roomName: string,\r\n  options: UseTokenOptions = {},\r\n) {\r\n  const [token, setToken] = React.useState<string | undefined>(undefined);\r\n\r\n  React.useEffect(() => {\r\n    if (tokenEndpoint === undefined) {\r\n      throw Error('token endpoint needs to be defined');\r\n    }\r\n    if (options.userInfo?.identity === undefined) {\r\n      return;\r\n    }\r\n    const tokenFetcher = async () => {\r\n      log.debug('fetching token');\r\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\r\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\r\n      if (!res.ok) {\r\n        log.error(\r\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\r\n        );\r\n        return;\r\n      }\r\n      const { accessToken } = await res.json();\r\n      setToken(accessToken);\r\n    };\r\n    tokenFetcher();\r\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\r\n  return token;\r\n}\r\n","import {\r\n  type TrackReferenceOrPlaceholder,\r\n  setupTrackMutedIndicator,\r\n  getTrackReferenceId,\r\n} from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureTrackRef } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ninterface TrackMutedIndicatorReturnType {\r\n  isMuted: boolean;\r\n  className: string;\r\n}\r\n\r\n/**\r\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\r\n * and returns the muted state of the given track.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { isMuted } = useTrackMutedIndicator(trackRef);\r\n * ```\r\n * @public\r\n */\r\nexport function useTrackMutedIndicator(\r\n  trackRef?: TrackReferenceOrPlaceholder,\r\n): TrackMutedIndicatorReturnType {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const { className, mediaMutedObserver } = React.useMemo(\r\n    () => setupTrackMutedIndicator(trackReference),\r\n    [getTrackReferenceId(trackReference)],\r\n  );\r\n\r\n  const isMuted = useObservableState(\r\n    mediaMutedObserver,\r\n    !!(\r\n      trackReference.publication?.isMuted ||\r\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\r\n    ),\r\n  );\r\n\r\n  return { isMuted, className };\r\n}\r\n","import type { ToggleSource } from '@livekit/components-core';\r\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { type Room } from 'livekit-client';\r\nimport type { TrackToggleProps } from '../components';\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface UseTrackToggleProps<T extends ToggleSource>\r\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\r\n * and functionality of the given track.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\r\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useTrackToggle<T extends ToggleSource>({\r\n  source,\r\n  onChange,\r\n  initialState,\r\n  captureOptions,\r\n  publishOptions,\r\n  onDeviceError,\r\n  room,\r\n  ...rest\r\n}: UseTrackToggleProps<T>) {\r\n  const roomFromContext = useMaybeRoomContext();\r\n  const roomFallback = React.useMemo(() => room ?? roomFromContext, [room, roomFromContext]);\r\n  const track = roomFallback?.localParticipant?.getTrackPublication(source);\r\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\r\n  const userInteractionRef = React.useRef(false);\r\n\r\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\r\n    () =>\r\n      roomFallback\r\n        ? setupMediaToggle<T>(source, roomFallback, captureOptions, publishOptions, onDeviceError)\r\n        : setupManualToggle(),\r\n    [roomFallback, source, JSON.stringify(captureOptions), publishOptions],\r\n  );\r\n\r\n  const pending = useObservableState(pendingObserver, false);\r\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\r\n\r\n  React.useEffect(() => {\r\n    onChange?.(enabled, userInteractionRef.current);\r\n    userInteractionRef.current = false;\r\n  }, [enabled, onChange]);\r\n\r\n  React.useEffect(() => {\r\n    if (initialState !== undefined) {\r\n      log.debug('forcing initial toggle state', source, initialState);\r\n      toggle(initialState);\r\n    }\r\n    // only execute once at the beginning\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\r\n\r\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\r\n    (evt) => {\r\n      userInteractionRef.current = true;\r\n      toggle().catch(() => (userInteractionRef.current = false));\r\n      rest.onClick?.(evt);\r\n    },\r\n    [rest, toggle],\r\n  );\r\n\r\n  return {\r\n    toggle,\r\n    enabled,\r\n    pending,\r\n    track,\r\n    buttonProps: {\r\n      ...newProps,\r\n      'aria-pressed': enabled,\r\n      'data-lk-source': source,\r\n      'data-lk-enabled': enabled,\r\n      disabled: pending,\r\n      onClick: clickHandler,\r\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n  };\r\n}\r\n","import type {\r\n  SourcesArray,\r\n  TrackReference,\r\n  TrackReferenceOrPlaceholder,\r\n  TrackSourceWithOptions,\r\n  TrackReferencePlaceholder,\r\n} from '@livekit/components-core';\r\nimport {\r\n  isSourcesWithOptions,\r\n  isSourceWitOptions,\r\n  log,\r\n  trackReferencesObservable,\r\n} from '@livekit/components-core';\r\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\r\nimport { Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport type UseTracksOptions = {\r\n  updateOnlyOn?: RoomEvent[];\r\n  onlySubscribed?: boolean;\r\n  room?: Room;\r\n};\r\n\r\n/** @public */\r\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\r\n  ? TrackReference[]\r\n  : T extends TrackSourceWithOptions[]\r\n    ? TrackReferenceOrPlaceholder[]\r\n    : never;\r\n\r\n/**\r\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\r\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\r\n * @example\r\n * ```ts\r\n * // Return all camera track publications.\r\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\r\n * ```\r\n * @example\r\n * ```ts\r\n * // Return all subscribed camera tracks as well as placeholders for\r\n * // participants without a camera subscription.\r\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\r\n * ```\r\n * @public\r\n */\r\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\r\n  sources: T = [\r\n    Track.Source.Camera,\r\n    Track.Source.Microphone,\r\n    Track.Source.ScreenShare,\r\n    Track.Source.ScreenShareAudio,\r\n    Track.Source.Unknown,\r\n  ] as T,\r\n  options: UseTracksOptions = {},\r\n): UseTracksHookReturnType<T> {\r\n  const room = useEnsureRoom(options.room);\r\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\r\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\r\n\r\n  const sources_ = React.useMemo(() => {\r\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\r\n  }, [JSON.stringify(sources)]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackReferencesObservable(room, sources_, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n      onlySubscribed: options.onlySubscribed,\r\n    }).subscribe(({ trackReferences, participants }) => {\r\n      log.debug('setting track bundles', trackReferences, participants);\r\n      setTrackReferences(trackReferences);\r\n      setParticipants(participants);\r\n    });\r\n    return () => subscription.unsubscribe();\r\n  }, [\r\n    room,\r\n    JSON.stringify(options.onlySubscribed),\r\n    JSON.stringify(options.updateOnlyOn),\r\n    JSON.stringify(sources),\r\n  ]);\r\n\r\n  const maybeTrackReferences = React.useMemo(() => {\r\n    if (isSourcesWithOptions(sources)) {\r\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\r\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\r\n        Array.from(trackReferences);\r\n      participants.forEach((participant) => {\r\n        if (requirePlaceholder.has(participant.identity)) {\r\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\r\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\r\n            if (\r\n              trackReferences.find(\r\n                ({ participant: p, publication }) =>\r\n                  participant.identity === p.identity && publication.source === placeholderSource,\r\n              )\r\n            ) {\r\n              return;\r\n            }\r\n            log.debug(\r\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\r\n            );\r\n            const placeholder: TrackReferencePlaceholder = {\r\n              participant,\r\n              source: placeholderSource,\r\n            };\r\n            trackReferencesWithPlaceholders.push(placeholder);\r\n          });\r\n        }\r\n      });\r\n      return trackReferencesWithPlaceholders;\r\n    } else {\r\n      return trackReferences;\r\n    }\r\n  }, [trackReferences, participants, sources]);\r\n\r\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\r\n}\r\n\r\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\r\n  const _difference = new Set(setA);\r\n  for (const elem of setB) {\r\n    _difference.delete(elem);\r\n  }\r\n  return _difference;\r\n}\r\n\r\nexport function requiredPlaceholders<T extends SourcesArray>(\r\n  sources: T,\r\n  participants: Participant[],\r\n): Map<Participant['identity'], Track.Source[]> {\r\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\r\n  if (isSourcesWithOptions(sources)) {\r\n    const sourcesThatNeedPlaceholder = sources\r\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\r\n      .map((sourceWithOption) => sourceWithOption.source);\r\n\r\n    participants.forEach((participant) => {\r\n      const sourcesOfSubscribedTracks = participant\r\n        .getTrackPublications()\r\n        .map((pub) => pub.track?.source)\r\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\r\n      const placeholderNeededForThisParticipant = Array.from(\r\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\r\n      );\r\n      // If the participant needs placeholder add it to the placeholder map.\r\n      if (placeholderNeededForThisParticipant.length > 0) {\r\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\r\n      }\r\n    });\r\n  }\r\n  return placeholderMap;\r\n}\r\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\r\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { Track } from 'livekit-client';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackRefBySourceOrName(\r\n  source: TrackSource<Track.Source>,\r\n): TrackReferenceOrPlaceholder {\r\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\r\n\r\n  const { trackObserver } = React.useMemo(() => {\r\n    return setupMediaTrack(source);\r\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackObserver.subscribe((publication) => {\r\n      setPublication(publication);\r\n    });\r\n    return () => subscription?.unsubscribe();\r\n  }, [trackObserver]);\r\n\r\n  return {\r\n    participant: source.participant,\r\n    source: source.source ?? Track.Source.Unknown,\r\n    publication,\r\n  };\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\r\n\r\n/**\r\n * This function `useTrackByName` allows you to access a track by referencing its track name.\r\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\r\n * for both a passed participant argument and, if not available, a valid participant context.\r\n *\r\n * @public\r\n */\r\nexport function useTrackByName(name: string, participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useTrackRefBySourceOrName({ name, participant: p });\r\n}\r\n","import * as React from 'react';\r\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\r\nimport { setupChat } from '@livekit/components-core';\r\nimport { ConnectionState, Room } from 'livekit-client';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\nimport { useConnectionState } from './useConnectionStatus';\r\n\r\n/**\r\n * The `useChat` hook provides chat functionality for a LiveKit room.\r\n *\r\n * @remarks\r\n * Message history is not persisted and will be lost if the component is refreshed.\r\n * You may want to persist message history in the browser, a cache or a database.\r\n *\r\n * @returns An object containing:\r\n * - `chatMessages` - Array of received chat messages\r\n * - `send` - Function to send a new message\r\n * - `isSending` - Boolean indicating if a message is currently being sent\r\n *\r\n * @example\r\n * ```tsx\r\n * function ChatComponent() {\r\n *   const { chatMessages, send, isSending } = useChat();\r\n *\r\n *   return (\r\n *     <div>\r\n *       {chatMessages.map((msg) => (\r\n *         <div key={msg.timestamp}>\r\n *           {msg.from?.identity}: {msg.message}\r\n *         </div>\r\n *       ))}\r\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\r\n *         Send Message\r\n *       </button>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n * @public\r\n */\r\nexport function useChat(options?: ChatOptions & { room?: Room }) {\r\n  const room = useEnsureRoom(options?.room);\r\n  const connectionState = useConnectionState(room);\r\n  const isDisconnected = React.useMemo(\r\n    () => connectionState === ConnectionState.Disconnected,\r\n    [connectionState],\r\n  ); // used to reset the messages on room disconnect\r\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\r\n    () => setupChat(room, options),\r\n    [room, options, isDisconnected],\r\n  );\r\n  const isSending = useObservableState(setup.isSendingObservable, false);\r\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\r\n\r\n  return { send: setup.send, chatMessages, isSending };\r\n}\r\n","import type { LocalUserChoices } from '@livekit/components-core';\r\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * Options for the `usePersistentDeviceSettings` hook.\r\n * @alpha\r\n */\r\nexport interface UsePersistentUserChoicesOptions {\r\n  /**\r\n   * The default value to use if reading from local storage returns no results or fails.\r\n   */\r\n  defaults?: Partial<LocalUserChoices>;\r\n  /**\r\n   * Whether to prevent saving to persistent storage.\r\n   * @defaultValue false\r\n   */\r\n  preventSave?: boolean;\r\n  /**\r\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\r\n   * @defaultValue false\r\n   */\r\n  preventLoad?: boolean;\r\n}\r\n\r\n/**\r\n * A hook that provides access to user choices stored in local storage, such as\r\n * selected media devices and their current state (on or off), as well as the user name.\r\n * @alpha\r\n */\r\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\r\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\r\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\r\n  );\r\n\r\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\r\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\r\n  }, []);\r\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\r\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\r\n  }, []);\r\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\r\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\r\n  }, []);\r\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\r\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\r\n  }, []);\r\n  const saveUsername = React.useCallback((username: string) => {\r\n    setSettings((prev) => ({ ...prev, username: username }));\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    saveUserChoices(userChoices, options.preventSave ?? false);\r\n  }, [userChoices, options.preventSave]);\r\n\r\n  return {\r\n    userChoices,\r\n    saveAudioInputEnabled,\r\n    saveVideoInputEnabled,\r\n    saveAudioInputDeviceId,\r\n    saveVideoInputDeviceId,\r\n    saveUsername,\r\n  };\r\n}\r\n","import * as React from 'react';\r\nimport { LocalParticipant } from 'livekit-client';\r\nimport type { Participant, Room } from 'livekit-client';\r\nimport { encryptionStatusObservable } from '@livekit/components-core';\r\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface UseIsEncryptedOptions {\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\r\n  const p = useEnsureParticipant(participant);\r\n\r\n  const room = useEnsureRoom(options.room);\r\n\r\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\r\n  const isEncrypted = useObservableState(\r\n    observer,\r\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\r\n  );\r\n  return isEncrypted;\r\n}\r\n","import * as React from 'react';\r\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\r\nimport { Track, createAudioAnalyser } from 'livekit-client';\r\nimport {\r\n  type TrackReference,\r\n  isTrackReference,\r\n  type TrackReferenceOrPlaceholder,\r\n} from '@livekit/components-core';\r\n\r\n/**\r\n * @alpha\r\n * Hook for tracking the volume of an audio track using the Web Audio API.\r\n */\r\nexport function useTrackVolume(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\r\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\r\n) {\r\n  const track = isTrackReference(trackOrTrackReference)\r\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\r\n    : trackOrTrackReference;\r\n  const [volume, setVolume] = React.useState(0);\r\n  React.useEffect(() => {\r\n    if (!track || !track.mediaStream) {\r\n      return;\r\n    }\r\n\r\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\r\n\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n\r\n    const updateVolume = () => {\r\n      analyser.getByteFrequencyData(dataArray);\r\n      let sum = 0;\r\n      for (let i = 0; i < dataArray.length; i++) {\r\n        const a = dataArray[i];\r\n        sum += a * a;\r\n      }\r\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\r\n    };\r\n\r\n    const interval = setInterval(updateVolume, 1000 / 30);\r\n\r\n    return () => {\r\n      cleanup();\r\n      clearInterval(interval);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\r\n\r\n  return volume;\r\n}\r\n\r\nconst normalizeFrequencies = (frequencies: Float32Array) => {\r\n  const normalizeDb = (value: number) => {\r\n    const minDb = -100;\r\n    const maxDb = -10;\r\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\r\n    db = Math.sqrt(db);\r\n\r\n    return db;\r\n  };\r\n\r\n  // Normalize all frequency values\r\n  return frequencies.map((value) => {\r\n    if (value === -Infinity) {\r\n      return 0;\r\n    }\r\n    return normalizeDb(value);\r\n  });\r\n};\r\n\r\n/**\r\n * Interface for configuring options for the useMultibandTrackVolume hook.\r\n * @alpha\r\n */\r\nexport interface MultiBandTrackVolumeOptions {\r\n  bands?: number;\r\n  /**\r\n   * cut off of frequency bins on the lower end\r\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\r\n   */\r\n  loPass?: number;\r\n  /**\r\n   * cut off of frequency bins on the higher end\r\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\r\n   */\r\n  hiPass?: number;\r\n  /**\r\n   * update should run every x ms\r\n   */\r\n  updateInterval?: number;\r\n  analyserOptions?: AnalyserOptions;\r\n}\r\n\r\nconst multibandDefaults = {\r\n  bands: 5,\r\n  loPass: 100,\r\n  hiPass: 600,\r\n  updateInterval: 32,\r\n  analyserOptions: { fftSize: 2048 },\r\n} as const satisfies MultiBandTrackVolumeOptions;\r\n\r\n/**\r\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\r\n * @alpha\r\n */\r\nexport function useMultibandTrackVolume(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\r\n  options: MultiBandTrackVolumeOptions = {},\r\n) {\r\n  const track =\r\n    trackOrTrackReference instanceof Track\r\n      ? trackOrTrackReference\r\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\r\n  const opts = { ...multibandDefaults, ...options };\r\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\r\n    new Array(opts.bands).fill(0),\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!track || !track?.mediaStream) {\r\n      setFrequencyBands((val) => val.slice().fill(0));\r\n      return;\r\n    }\r\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\r\n\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Float32Array(bufferLength);\r\n\r\n    const updateVolume = () => {\r\n      analyser.getFloatFrequencyData(dataArray);\r\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\r\n      for (let i = 0; i < dataArray.length; i++) {\r\n        frequencies[i] = dataArray[i];\r\n      }\r\n      frequencies = frequencies.slice(opts.loPass, opts.hiPass);\r\n\r\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\r\n      const totalBins = normalizedFrequencies.length;\r\n      const chunks: Array<number> = [];\r\n      for (let i = 0; i < opts.bands; i++) {\r\n        // Use proportional distribution to evenly divide bins across bands\r\n        const startIndex = Math.floor((i * totalBins) / opts.bands);\r\n        const endIndex = Math.floor(((i + 1) * totalBins) / opts.bands);\r\n        const chunk = normalizedFrequencies.slice(startIndex, endIndex);\r\n        const chunkLength = chunk.length;\r\n        if (chunkLength === 0) {\r\n          chunks.push(0);\r\n        } else {\r\n          const summedVolumes = chunk.reduce((acc, val) => (acc += val), 0);\r\n          chunks.push(summedVolumes / chunkLength);\r\n        }\r\n      }\r\n\r\n      setFrequencyBands(chunks);\r\n    };\r\n\r\n    const interval = setInterval(updateVolume, opts.updateInterval);\r\n\r\n    return () => {\r\n      cleanup();\r\n      clearInterval(interval);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\r\n\r\n  return frequencyBands;\r\n}\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface AudioWaveformOptions {\r\n  barCount?: number;\r\n  volMultiplier?: number;\r\n  updateInterval?: number;\r\n}\r\n\r\nconst waveformDefaults = {\r\n  barCount: 120,\r\n  volMultiplier: 5,\r\n  updateInterval: 20,\r\n} as const satisfies AudioWaveformOptions;\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport function useAudioWaveform(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\r\n  options: AudioWaveformOptions = {},\r\n) {\r\n  const track =\r\n    trackOrTrackReference instanceof Track\r\n      ? trackOrTrackReference\r\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\r\n  const opts = { ...waveformDefaults, ...options };\r\n\r\n  const aggregateWave = React.useRef(new Float32Array());\r\n  const timeRef = React.useRef(performance.now());\r\n  const updates = React.useRef(0);\r\n  const [bars, setBars] = React.useState<number[]>([]);\r\n\r\n  const onUpdate = React.useCallback((wave: Float32Array) => {\r\n    setBars(\r\n      Array.from(\r\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\r\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\r\n      ),\r\n    );\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (!track || !track?.mediaStream) {\r\n      return;\r\n    }\r\n    const { analyser, cleanup } = createAudioAnalyser(track, {\r\n      fftSize: getFFTSizeValue(opts.barCount),\r\n    });\r\n\r\n    const bufferLength = getFFTSizeValue(opts.barCount);\r\n    const dataArray = new Float32Array(bufferLength);\r\n\r\n    const update = () => {\r\n      updateWaveform = requestAnimationFrame(update);\r\n      analyser.getFloatTimeDomainData(dataArray);\r\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\r\n      updates.current += 1;\r\n\r\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\r\n        const newData = dataArray.map((v) => v / updates.current);\r\n        onUpdate(newData);\r\n        timeRef.current = performance.now();\r\n        updates.current = 0;\r\n      }\r\n    };\r\n\r\n    let updateWaveform = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cleanup();\r\n      cancelAnimationFrame(updateWaveform);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\r\n\r\n  return {\r\n    bars,\r\n  };\r\n}\r\n\r\nfunction getFFTSizeValue(x: number) {\r\n  if (x < 32) return 32;\r\n  else return pow2ceil(x);\r\n}\r\n\r\n// function sigmoid(x: number, k = 2, s = 0) {\r\n//   return 1 / (1 + Math.exp(-(x - s) / k));\r\n// }\r\n\r\nfunction pow2ceil(v: number) {\r\n  let p = 2;\r\n  while ((v >>= 1)) {\r\n    p <<= 1;\r\n  }\r\n  return p;\r\n}\r\n\r\nfunction filterData(audioData: Float32Array, numSamples: number) {\r\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\r\n  const filteredData = new Float32Array(numSamples);\r\n  for (let i = 0; i < numSamples; i++) {\r\n    const blockStart = blockSize * i; // the location of the first sample in the block\r\n    let sum = 0;\r\n    for (let j = 0; j < blockSize; j++) {\r\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\r\n    }\r\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\r\n  }\r\n  return filteredData;\r\n}\r\n\r\n// function normalizeData(audioData: Float32Array) {\r\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\r\n//   return audioData.map((n) => n * multiplier);\r\n// }\r\n","import * as React from 'react';\r\nimport type { TrackReference } from '@livekit/components-core';\r\nimport { participantTracksObservable } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\nimport type { Room, Track } from 'livekit-client';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useParticipants } from './useParticipants';\r\n\r\ntype UseParticipantTracksOptions = {\r\n  participantIdentity?: string;\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\r\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\r\n * @public\r\n */\r\nexport function useParticipantTracks<TrackSource extends Track.Source>(\r\n  sources: Array<TrackSource>,\r\n  optionsOrParticipantIdentity:\r\n    | UseParticipantTracksOptions\r\n    | UseParticipantTracksOptions['participantIdentity'] = {},\r\n): Array<TrackReference> {\r\n  let participantIdentity: UseParticipantTracksOptions['participantIdentity'];\r\n  let room: UseParticipantTracksOptions['room'];\r\n  if (typeof optionsOrParticipantIdentity === 'string') {\r\n    participantIdentity = optionsOrParticipantIdentity;\r\n  } else {\r\n    participantIdentity = optionsOrParticipantIdentity?.participantIdentity;\r\n    room = optionsOrParticipantIdentity?.room;\r\n  }\r\n\r\n  const participantContext = useMaybeParticipantContext();\r\n  const participants = useParticipants({ room, updateOnlyOn: [] });\r\n\r\n  const p = React.useMemo(() => {\r\n    if (participantIdentity) {\r\n      return participants.find((p) => p.identity === participantIdentity);\r\n    }\r\n    return participantContext;\r\n  }, [participantIdentity, participants, participantContext]);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (!p) {\r\n      return undefined;\r\n    }\r\n    return participantTracksObservable(p, { sources });\r\n  }, [p, JSON.stringify(sources)]);\r\n\r\n  const trackRefs = useObservableState(observable, [] as Array<TrackReference>);\r\n\r\n  return trackRefs;\r\n}\r\n","import * as React from 'react';\r\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @internal\r\n * @deprecated this is an internal hook that's only used by deprecated APIs\r\n */\r\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\r\n  const observable = React.useMemo(\r\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\r\n    [ref?.publication?.track],\r\n  );\r\n  return useObservableState(observable, {\r\n    timestamp: Date.now(),\r\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\r\n  });\r\n}\r\n","import {\r\n  type ReceivedTranscriptionSegment,\r\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\r\n  dedupeSegments,\r\n  // getActiveTranscriptionSegments,\r\n  getTrackReferenceId,\r\n  trackTranscriptionObserver,\r\n  type TrackReferenceOrPlaceholder,\r\n  // didActiveSegmentsChange,\r\n} from '@livekit/components-core';\r\nimport type { TranscriptionSegment } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useTrackSyncTime } from './useTrackSyncTime';\r\n\r\n/**\r\n * @alpha\r\n * @deprecated Use useTranscription instead\r\n */\r\nexport interface TrackTranscriptionOptions {\r\n  /**\r\n   * how many transcription segments should be buffered in state\r\n   * @defaultValue 100\r\n   */\r\n  bufferSize?: number;\r\n  /**\r\n   * optional callback for retrieving newly incoming transcriptions only\r\n   */\r\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\r\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\r\n  // maxAge?: number;\r\n}\r\n\r\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\r\n  bufferSize: 100,\r\n  // maxAge: 2_000,\r\n} as const satisfies TrackTranscriptionOptions;\r\n\r\n/**\r\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\r\n * @alpha\r\n * @deprecated Use useTranscription instead\r\n */\r\nexport function useTrackTranscription(\r\n  trackRef: TrackReferenceOrPlaceholder | undefined,\r\n  options?: TrackTranscriptionOptions,\r\n) {\r\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\r\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\r\n\r\n  const syncTimestamps = useTrackSyncTime(trackRef);\r\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\r\n    opts.onTranscription?.(newSegments);\r\n    setSegments((prevSegments) =>\r\n      dedupeSegments(\r\n        prevSegments,\r\n        // when first receiving a segment, add the current media timestamp to it\r\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\r\n        opts.bufferSize,\r\n      ),\r\n    );\r\n  };\r\n  React.useEffect(() => {\r\n    if (!trackRef?.publication) {\r\n      return;\r\n    }\r\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\r\n      handleSegmentMessage(...evt);\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\r\n\r\n  return { segments };\r\n}\r\n","import { participantAttributesObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { attributes } = useParticipantAttributes({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantAttributesOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = props.participant ?? participantContext;\r\n  const attributeObserver = React.useMemo(\r\n    // weird typescript constraint\r\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\r\n    [p],\r\n  );\r\n  const attributeState = useObservableState(attributeObserver, {\r\n    attributes: p?.attributes,\r\n  });\r\n\r\n  return attributeState;\r\n}\r\n\r\n/**\r\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\r\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipantAttribute(\r\n  attributeKey: string,\r\n  options: UseParticipantAttributesOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\r\n\r\n  React.useEffect(() => {\r\n    if (!p) {\r\n      return;\r\n    }\r\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\r\n      if (val.changed[attributeKey] !== undefined) {\r\n        setAttribute(val.attributes[attributeKey]);\r\n      }\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [p, attributeKey]);\r\n\r\n  return attribute;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\r\nimport type { RemoteParticipant } from 'livekit-client';\r\nimport {\r\n  ParticipantAgentAttributes,\r\n  type ReceivedTranscriptionSegment,\r\n  type TrackReference,\r\n} from '@livekit/components-core';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useTrackTranscription } from './useTrackTranscription';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useParticipantAttributes } from './useParticipantAttributes';\r\nimport { AgentState } from './useAgent';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface VoiceAssistant {\r\n  /**\r\n   * The agent participant.\r\n   */\r\n  agent: RemoteParticipant | undefined;\r\n  /**\r\n   * The current state of the agent.\r\n   */\r\n  state: AgentState;\r\n  /**\r\n   * The microphone track published by the agent or associated avatar worker (if any).\r\n   */\r\n  audioTrack: TrackReference | undefined;\r\n  /**\r\n   * The camera track published by the agent or associated avatar worker (if any).\r\n   */\r\n  videoTrack: TrackReference | undefined;\r\n  /**\r\n   * The transcriptions of the agent's microphone track (if any).\r\n   */\r\n  agentTranscriptions: ReceivedTranscriptionSegment[];\r\n  /**\r\n   * The agent's participant attributes.\r\n   */\r\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\r\n}\r\n\r\nconst state_attribute = ParticipantAgentAttributes.AgentState;\r\n\r\n/**\r\n * This hook looks for the first agent-participant in the room.\r\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\r\n * @example\r\n * ```tsx\r\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\r\n * ```\r\n * @beta\r\n */\r\nexport function useVoiceAssistant(): VoiceAssistant {\r\n  const remoteParticipants = useRemoteParticipants();\r\n  const agent = remoteParticipants.find(\r\n    (p) =>\r\n      p.kind === ParticipantKind.AGENT &&\r\n      !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\r\n  );\r\n  const worker = remoteParticipants.find(\r\n    (p) =>\r\n      p.kind === ParticipantKind.AGENT &&\r\n      p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agent?.identity,\r\n  );\r\n  const agentTracks = useParticipantTracks(\r\n    [Track.Source.Microphone, Track.Source.Camera],\r\n    agent?.identity,\r\n  );\r\n  const workerTracks = useParticipantTracks(\r\n    [Track.Source.Microphone, Track.Source.Camera],\r\n    worker?.identity,\r\n  );\r\n  const audioTrack =\r\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\r\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\r\n  const videoTrack =\r\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\r\n    workerTracks.find((t) => t.source === Track.Source.Camera);\r\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\r\n  const connectionState = useConnectionState();\r\n  const { attributes } = useParticipantAttributes({ participant: agent });\r\n\r\n  const state: AgentState = React.useMemo(() => {\r\n    if (connectionState === ConnectionState.Disconnected) {\r\n      return 'disconnected';\r\n    } else if (\r\n      connectionState === ConnectionState.Connecting ||\r\n      !agent ||\r\n      !attributes?.[state_attribute]\r\n    ) {\r\n      return 'connecting';\r\n    } else {\r\n      return attributes[state_attribute] as AgentState;\r\n    }\r\n  }, [attributes, agent, connectionState]);\r\n\r\n  return {\r\n    agent,\r\n    state,\r\n    audioTrack,\r\n    videoTrack,\r\n    agentTranscriptions,\r\n    agentAttributes: attributes,\r\n  };\r\n}\r\n","import { recordingStatusObservable } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport type { Room } from 'livekit-client';\r\n\r\n/**\r\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\r\n * @example\r\n * ```tsx\r\n * const isRecording = useIsRecording();\r\n * ```\r\n * @public\r\n */\r\nexport function useIsRecording(room?: Room) {\r\n  const r = useEnsureRoom(room);\r\n  const connectionState = useConnectionState(r);\r\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\r\n  const isRecording = useObservableState(observable, r.isRecording);\r\n\r\n  return isRecording;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, Room } from 'livekit-client';\r\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @beta */\r\nexport type UseTextStreamOptions = {\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * @beta\r\n * @param topic - the topic to listen to\r\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\r\n * @example\r\n * ```tsx\r\n * const { textStreams } = useTextStream('my-topic');\r\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\r\n * ```\r\n */\r\nexport function useTextStream(topic: string, options?: UseTextStreamOptions) {\r\n  const room = useEnsureRoom(options?.room);\r\n\r\n  const connectionState = useConnectionState(room);\r\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\r\n\r\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\r\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\r\n\r\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\r\n\r\n  return { textStreams };\r\n}\r\n","import * as React from 'react';\r\nimport { useTextStream } from './useTextStream';\r\nimport { DataTopic, ParticipantAgentAttributes } from '@livekit/components-core';\r\nimport { Room } from 'livekit-client';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface UseTranscriptionsOptions {\r\n  room?: Room;\r\n  participantIdentities?: string[];\r\n  trackSids?: string[];\r\n}\r\n\r\n/**\r\n * @beta\r\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\r\n * if no options are provided, it will return all transcriptions\r\n * @example\r\n * ```tsx\r\n * const transcriptions = useTranscriptions();\r\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\r\n * ```\r\n */\r\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\r\n  const { participantIdentities, trackSids } = opts ?? {};\r\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION, { room: opts?.room });\r\n\r\n  const filteredMessages = React.useMemo(\r\n    () =>\r\n      textStreams\r\n        .filter((stream) =>\r\n          participantIdentities\r\n            ? participantIdentities.includes(stream.participantInfo.identity)\r\n            : true,\r\n        )\r\n        .filter((stream) =>\r\n          trackSids\r\n            ? trackSids.includes(\r\n                stream.streamInfo.attributes?.[ParticipantAgentAttributes.TranscribedTrackId] ?? '',\r\n              )\r\n            : true,\r\n        ),\r\n    [textStreams, participantIdentities, trackSids],\r\n  );\r\n\r\n  return filteredMessages;\r\n}\r\n","import { Mutex, type Room } from 'livekit-client';\r\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\r\nimport { log } from '@livekit/components-core';\r\n\r\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\r\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\r\n\r\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\r\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\r\n\r\n/** @public */\r\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\r\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\r\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\r\n};\r\n\r\n/**\r\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\r\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\r\n * running. This hook sequentializes these two operations, so they always happen in order and\r\n * never overlap.\r\n *\r\n * @example\r\n * ```ts\r\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\r\n *\r\n * // Connecting to a room:\r\n * useEffect(() => {\r\n *   connect();\r\n *   return () => disconnect();\r\n * }, [connect, disconnect]);\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\r\n  room: R,\r\n): UseSequentialRoomConnectDisconnectResults<R> {\r\n  const connectDisconnectQueueRef = useRef<\r\n    Array<\r\n      | {\r\n          type: 'connect';\r\n          room: Room;\r\n          args: Parameters<typeof Room.prototype.connect>;\r\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\r\n          reject: (err: Error) => void;\r\n        }\r\n      | {\r\n          type: 'disconnect';\r\n          room: Room;\r\n          args: Parameters<typeof Room.prototype.disconnect>;\r\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\r\n          reject: (err: Error) => void;\r\n        }\r\n    >\r\n  >([]);\r\n\r\n  // Process room connection / disconnection events and execute them in series\r\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\r\n  // events\r\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\r\n  const processConnectsAndDisconnects = useCallback(async () => {\r\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\r\n      while (true) {\r\n        const message = connectDisconnectQueueRef.current.pop();\r\n        if (!message) {\r\n          unlock();\r\n          break;\r\n        }\r\n\r\n        switch (message.type) {\r\n          case 'connect':\r\n            await message.room\r\n              .connect(...message.args)\r\n              .then(message.resolve)\r\n              .catch(message.reject);\r\n            break;\r\n          case 'disconnect':\r\n            await message.room\r\n              .disconnect(...message.args)\r\n              .then(message.resolve)\r\n              .catch(message.reject);\r\n            break;\r\n        }\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\r\n  const checkRoomThreshold = useCallback((now: Date) => {\r\n    let roomChangesInThreshold = 0;\r\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\r\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\r\n      if (isWithinThreshold) {\r\n        roomChangesInThreshold += 1;\r\n      }\r\n      return isWithinThreshold;\r\n    });\r\n\r\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\r\n      log.warn(\r\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\r\n  useEffect(() => {\r\n    connectDisconnectQueueRef.current = [];\r\n\r\n    const now = new Date();\r\n    roomChangedTimesRef.current.push(now);\r\n    checkRoomThreshold(now);\r\n  }, [room, checkRoomThreshold]);\r\n\r\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\r\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\r\n    let connectDisconnectsInThreshold = 0;\r\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\r\n      const isWithinThreshold =\r\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\r\n      if (isWithinThreshold) {\r\n        connectDisconnectsInThreshold += 1;\r\n      }\r\n      return isWithinThreshold;\r\n    });\r\n\r\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\r\n      log.warn(\r\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  const connect = useCallback(\r\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (!room) {\r\n          throw new Error('Called connect(), but room was unset');\r\n        }\r\n        const now = new Date();\r\n        checkConnectDisconnectThreshold(now);\r\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\r\n        connectDisconnectEnqueueTimes.current.push(now);\r\n        processConnectsAndDisconnects();\r\n      });\r\n    },\r\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\r\n  );\r\n\r\n  const disconnect = useCallback(\r\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (!room) {\r\n          throw new Error('Called discconnect(), but room was unset');\r\n        }\r\n        const now = new Date();\r\n        checkConnectDisconnectThreshold(now);\r\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\r\n        connectDisconnectEnqueueTimes.current.push(now);\r\n        processConnectsAndDisconnects();\r\n      });\r\n    },\r\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\r\n  );\r\n\r\n  return {\r\n    connect: room ? connect : null,\r\n    disconnect: room ? disconnect : null,\r\n  } as UseSequentialRoomConnectDisconnectResults<R>;\r\n}\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import {\r\n  ConnectionState,\r\n  LocalTrackPublication,\r\n  ParticipantEvent,\r\n  ParticipantKind,\r\n  RemoteParticipant,\r\n  RoomEvent,\r\n  Track,\r\n  Participant,\r\n} from 'livekit-client';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport { EventEmitter } from 'events';\r\nimport * as React from 'react';\r\nimport { ParticipantAgentAttributes, TrackReference } from '@livekit/components-core';\r\n\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { UseSessionReturn } from './useSession';\r\nimport { useMaybeSessionContext } from '../context';\r\nimport { useParticipantInfo } from './useParticipantInfo';\r\n\r\n// FIXME: make this 10 seconds once room dispatch booting info is discoverable\r\nconst DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS = 20_000;\r\n\r\n/** @see https://github.com/livekit/agents/blob/65170238db197f62f479eb7aaef1c0e18bfad6e7/livekit-agents/livekit/agents/voice/events.py#L97 */\r\ntype AgentSdkStates = 'initializing' | 'idle' | 'listening' | 'thinking' | 'speaking';\r\n\r\n/**\r\n * State representing the current status of the agent, whether it is ready for speach, etc\r\n *\r\n * For most agents (which have the preconnect audio buffer feature enabled), this is the lifecycle:\r\n *   connecting  pre-connect-buffering  initializing/listening/thinking/speaking\r\n *\r\n * For agents without the preconnect audio feature enabled:\r\n *   connecting  initializing  idle/listening/thinking/speaking\r\n *\r\n * If an agent fails to connect:\r\n *   connecting  pre-connect-buffering/initializing  failed\r\n *\r\n * Legacy useVoiceAssistant hook:\r\n *   disconnected  connecting  initializing  listening/thinking/speaking\r\n *\r\n * @beta\r\n * */\r\nexport type AgentState =\r\n  | 'disconnected'\r\n  | 'connecting'\r\n  | 'pre-connect-buffering'\r\n  | 'failed'\r\n  | AgentSdkStates;\r\n\r\n/** @beta */\r\nexport enum AgentEvent {\r\n  CameraChanged = 'cameraChanged',\r\n  MicrophoneChanged = 'microphoneChanged',\r\n  StateChanged = 'stateChanged',\r\n}\r\n\r\n/** @beta */\r\nexport type AgentCallbacks = {\r\n  [AgentEvent.CameraChanged]: (newTrack: TrackReference | undefined) => void;\r\n  [AgentEvent.MicrophoneChanged]: (newTrack: TrackReference | undefined) => void;\r\n  [AgentEvent.StateChanged]: (newAgentState: AgentState) => void;\r\n};\r\n\r\ntype AgentStateCommon = {\r\n  // FIXME: maybe add some sort of schema to this?\r\n  attributes: Participant['attributes'];\r\n\r\n  internal: {\r\n    emitter: TypedEventEmitter<AgentCallbacks>;\r\n\r\n    agentParticipant: RemoteParticipant | null;\r\n    workerParticipant: RemoteParticipant | null;\r\n  };\r\n};\r\n\r\ntype AgentStateAvailable = AgentStateCommon & {\r\n  state: 'listening' | 'thinking' | 'speaking';\r\n  failureReasons: null;\r\n\r\n  /** The agent's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: true;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: true;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStatePreConnectBuffering = AgentStateCommon & {\r\n  state: 'pre-connect-buffering';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: true;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStateUnAvailable = AgentStateCommon & {\r\n  state: 'initializing' | 'idle';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: true;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStateConnecting = AgentStateCommon & {\r\n  state: 'connecting';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: true;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentStateDisconnected = AgentStateCommon & {\r\n  state: 'disconnected';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: true;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentStateFailed = AgentStateCommon & {\r\n  state: 'failed';\r\n  failureReasons: Array<string>;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: true;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentActions = {\r\n  /** Returns a promise that resolves once the agent is connected and available for user input */\r\n  waitUntilConnected: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /**\r\n   * Returns a promise that resolves once the client could be listening for user speech (`canListen` is true)\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  waitUntilCouldBeListening: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /** Returns a promise that resolves once the client has disconnected from the agent either for an expected or unexpected reason. */\r\n  waitUntilFinished: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /** Returns a promise that resolves once the agent has published a camera track */\r\n  waitUntilCamera: (signal?: AbortSignal) => Promise<TrackReference>;\r\n\r\n  /** Returns a promise that resolves once the agent has published a microphone track */\r\n  waitUntilMicrophone: (signal?: AbortSignal) => Promise<TrackReference>;\r\n};\r\n\r\ntype AgentStateCases =\r\n  | AgentStateConnecting\r\n  | AgentStateDisconnected\r\n  | AgentStateAvailable\r\n  | AgentStatePreConnectBuffering\r\n  | AgentStateUnAvailable\r\n  | AgentStateFailed;\r\n\r\n/** @beta */\r\nexport type UseAgentReturn = AgentStateCases & AgentActions;\r\n\r\nconst generateDerivedStateValues = <State extends AgentState>(state: State) =>\r\n  ({\r\n    isConnected: state === 'listening' || state === 'thinking' || state === 'speaking',\r\n    canListen:\r\n      state === 'pre-connect-buffering' ||\r\n      state === 'listening' ||\r\n      state === 'thinking' ||\r\n      state === 'speaking',\r\n    isFinished: state === 'disconnected' || state === 'failed',\r\n    isPending: state === 'connecting' || state === 'initializing' || state === 'idle',\r\n  }) as {\r\n    isConnected: State extends 'listening' | 'thinking' | 'speaking' ? true : false;\r\n    canListen: State extends 'pre-connect-buffering' | 'listening' | 'thinking' | 'speaking'\r\n      ? true\r\n      : false;\r\n    isFinished: State extends 'disconnected' | 'failed' ? true : false;\r\n    isPending: State extends 'connecting' | 'initializing' | 'idle' ? true : false;\r\n  };\r\n\r\n/** Internal hook used by useSession to store global agent state */\r\nexport const useAgentTimeoutIdStore = (): {\r\n  agentTimeoutFailureReason: string | null;\r\n  startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\r\n  clearAgentTimeout: () => void;\r\n  clearAgentTimeoutFailureReason: () => void;\r\n  updateAgentTimeoutState: (agentState: AgentState) => void;\r\n  updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\r\n} => {\r\n  const [agentTimeoutFailureReason, setAgentTimeoutFailureReason] = React.useState<string | null>(\r\n    null,\r\n  );\r\n  const [agentTimeoutId, setAgentTimeoutId] = React.useState<ReturnType<typeof setTimeout> | null>(\r\n    null,\r\n  );\r\n\r\n  const agentStateRef = React.useRef<AgentState>('connecting');\r\n  const agentParticipantExistsRef = React.useRef(false);\r\n\r\n  const startAgentConnectedTimeout = (agentConnectTimeoutMilliseconds?: number) => {\r\n    return setTimeout(() => {\r\n      if (!agentParticipantExistsRef.current) {\r\n        setAgentTimeoutFailureReason('Agent did not join the room.');\r\n        return;\r\n      }\r\n\r\n      const { isConnected } = generateDerivedStateValues(agentStateRef.current);\r\n      if (!isConnected) {\r\n        setAgentTimeoutFailureReason('Agent joined the room but did not complete initializing.');\r\n        return;\r\n      }\r\n    }, agentConnectTimeoutMilliseconds ?? DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS);\r\n  };\r\n\r\n  return {\r\n    agentTimeoutFailureReason,\r\n    startAgentTimeout: React.useCallback(\r\n      (agentConnectTimeoutMilliseconds?: number) => {\r\n        if (agentTimeoutId) {\r\n          clearTimeout(agentTimeoutId);\r\n        }\r\n\r\n        setAgentTimeoutFailureReason(null);\r\n        setAgentTimeoutId(startAgentConnectedTimeout(agentConnectTimeoutMilliseconds));\r\n        agentStateRef.current = 'connecting';\r\n        agentParticipantExistsRef.current = false;\r\n      },\r\n      [agentTimeoutId],\r\n    ),\r\n    clearAgentTimeout: React.useCallback(() => {\r\n      if (agentTimeoutId) {\r\n        clearTimeout(agentTimeoutId);\r\n      }\r\n\r\n      setAgentTimeoutFailureReason(null);\r\n      setAgentTimeoutId(null);\r\n      agentStateRef.current = 'connecting';\r\n      agentParticipantExistsRef.current = false;\r\n    }, [agentTimeoutId]),\r\n    clearAgentTimeoutFailureReason: React.useCallback(() => {\r\n      setAgentTimeoutFailureReason(null);\r\n    }, []),\r\n\r\n    updateAgentTimeoutState: React.useCallback((agentState: AgentState) => {\r\n      agentStateRef.current = agentState;\r\n    }, []),\r\n    updateAgentTimeoutParticipantExists: React.useCallback((agentParticipantExists: boolean) => {\r\n      agentParticipantExistsRef.current = agentParticipantExists;\r\n    }, []),\r\n  };\r\n};\r\n\r\ntype SessionStub = Pick<UseSessionReturn, 'connectionState' | 'room' | 'internal'>;\r\n\r\n/** Internal hook used by useAgent which generates a function that when called, will return a\r\n * promise which resolves when agent.isAvailable is enabled. */\r\nfunction useAgentWaitUntilDerivedStates(\r\n  emitter: TypedEventEmitter<AgentCallbacks>,\r\n  state: AgentState,\r\n) {\r\n  const stateRef = React.useRef(state);\r\n  React.useEffect(() => {\r\n    stateRef.current = state;\r\n  }, [state]);\r\n\r\n  const waitUntilConnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { isConnected } = generateDerivedStateValues(stateRef.current);\r\n      if (isConnected) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { isConnected } = generateDerivedStateValues(state);\r\n          if (!isConnected) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilConnected - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilCouldBeListening = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { canListen } = generateDerivedStateValues(stateRef.current);\r\n      if (canListen) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { canListen } = generateDerivedStateValues(state);\r\n          if (!canListen) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilCouldBeListening - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilFinished = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { isFinished } = generateDerivedStateValues(stateRef.current);\r\n      if (isFinished) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { isFinished } = generateDerivedStateValues(state);\r\n          if (!isFinished) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilFinished - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished };\r\n}\r\n\r\n/**\r\n * useAgent encapculates all agent state, normalizing some quirks around how LiveKit Agents work.\r\n * @beta\r\n */\r\nexport function useAgent(session?: SessionStub): UseAgentReturn {\r\n  const sessionFromContext = useMaybeSessionContext();\r\n  session = session ?? sessionFromContext;\r\n  if (!session) {\r\n    throw new Error(\r\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\r\n    );\r\n  }\r\n\r\n  const {\r\n    room,\r\n    internal: {\r\n      agentConnectTimeoutMilliseconds,\r\n\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    },\r\n  } = session;\r\n\r\n  const emitter = React.useMemo(() => new EventEmitter() as TypedEventEmitter<AgentCallbacks>, []);\r\n\r\n  const roomRemoteParticipants = useRemoteParticipants({ room });\r\n\r\n  const agentParticipant = React.useMemo(() => {\r\n    return (\r\n      roomRemoteParticipants.find(\r\n        (p) =>\r\n          p.kind === ParticipantKind.AGENT &&\r\n          !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\r\n      ) ?? null\r\n    );\r\n  }, [roomRemoteParticipants]);\r\n  const workerParticipant = React.useMemo(() => {\r\n    if (!agentParticipant) {\r\n      return null;\r\n    }\r\n    return (\r\n      roomRemoteParticipants.find(\r\n        (p) =>\r\n          p.kind === ParticipantKind.AGENT &&\r\n          p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agentParticipant.identity,\r\n      ) ?? null\r\n    );\r\n  }, [agentParticipant, roomRemoteParticipants]);\r\n\r\n  // 1. Listen for agent participant attribute changes\r\n  const [agentParticipantAttributes, setAgentParticipantAttributes] = React.useState<\r\n    Participant['attributes']\r\n  >(agentParticipant?.attributes ?? {});\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    const handleAttributesChanged = (attributes: UseAgentReturn['attributes']) => {\r\n      setAgentParticipantAttributes(attributes);\r\n    };\r\n\r\n    agentParticipant.on(ParticipantEvent.AttributesChanged, handleAttributesChanged);\r\n    return () => {\r\n      agentParticipant.off(ParticipantEvent.AttributesChanged, handleAttributesChanged);\r\n    };\r\n  }, [agentParticipant, emitter]);\r\n\r\n  // 2. Listen for track updates\r\n  const agentTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\r\n    room,\r\n    participantIdentity: agentParticipant?.identity,\r\n  });\r\n  const workerTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\r\n    room,\r\n    participantIdentity: workerParticipant?.identity,\r\n  });\r\n\r\n  const videoTrack = React.useMemo(\r\n    () =>\r\n      agentTracks.find((t) => t.source === Track.Source.Camera) ??\r\n      workerTracks.find((t) => t.source === Track.Source.Camera),\r\n    [agentTracks, workerTracks],\r\n  );\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.CameraChanged, videoTrack);\r\n  }, [emitter, videoTrack]);\r\n\r\n  const audioTrack = React.useMemo(\r\n    () =>\r\n      agentTracks.find((t) => t.source === Track.Source.Microphone) ??\r\n      workerTracks.find((t) => t.source === Track.Source.Microphone),\r\n    [agentTracks, workerTracks],\r\n  );\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.MicrophoneChanged, audioTrack);\r\n  }, [emitter, audioTrack]);\r\n\r\n  // Listen for room connection state updates\r\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\r\n  React.useEffect(() => {\r\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\r\n      setRoomConnectionState(connectionState);\r\n    };\r\n\r\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    return () => {\r\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    };\r\n  }, [room]);\r\n\r\n  // When the agent participant connects, reset the timeout failure state\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    clearAgentTimeoutFailureReason();\r\n  }, [agentParticipant]);\r\n\r\n  // If the agent participant disconnects in the middle of a conversation unexpectedly, mark that as an explicit failure\r\n  const [agentDisconnectedFailureReason, setAgentDisconnectedFailureReason] = React.useState<\r\n    string | null\r\n  >(null);\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    const onParticipantDisconnect = (participant: RemoteParticipant) => {\r\n      if (participant.identity !== agentParticipant?.identity) {\r\n        return;\r\n      }\r\n      setAgentDisconnectedFailureReason('Agent left the room unexpectedly.');\r\n    };\r\n\r\n    room.on(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\r\n\r\n    return () => {\r\n      room.off(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\r\n    };\r\n  }, [agentParticipant, room]);\r\n\r\n  React.useEffect(() => {\r\n    if (roomConnectionState !== ConnectionState.Disconnected) {\r\n      return;\r\n    }\r\n    // Clear the agent disconnect failure state when the room disconnects\r\n    setAgentDisconnectedFailureReason(null);\r\n  }, [roomConnectionState]);\r\n\r\n  const [localMicTrack, setLocalMicTrack] = React.useState<LocalTrackPublication | null>(\r\n    () => room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null,\r\n  );\r\n  React.useEffect(() => {\r\n    const handleLocalParticipantTrackPublished = () => {\r\n      setLocalMicTrack(room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null);\r\n    };\r\n    const handleLocalParticipantTrackUnPublished = () => {\r\n      setLocalMicTrack(null);\r\n    };\r\n\r\n    room.localParticipant.on(\r\n      ParticipantEvent.LocalTrackPublished,\r\n      handleLocalParticipantTrackPublished,\r\n    );\r\n    room.localParticipant.on(\r\n      ParticipantEvent.LocalTrackUnpublished,\r\n      handleLocalParticipantTrackUnPublished,\r\n    );\r\n    return () => {\r\n      room.localParticipant.off(\r\n        ParticipantEvent.LocalTrackPublished,\r\n        handleLocalParticipantTrackPublished,\r\n      );\r\n      room.localParticipant.off(\r\n        ParticipantEvent.LocalTrackUnpublished,\r\n        handleLocalParticipantTrackUnPublished,\r\n      );\r\n    };\r\n  }, [room.localParticipant]);\r\n\r\n  const failureReasons = React.useMemo(() => {\r\n    const reasons = [];\r\n    if (agentTimeoutFailureReason) {\r\n      reasons.push(agentTimeoutFailureReason);\r\n    }\r\n    if (agentDisconnectedFailureReason) {\r\n      reasons.push(agentDisconnectedFailureReason);\r\n    }\r\n    return reasons;\r\n  }, [agentTimeoutFailureReason, agentDisconnectedFailureReason]);\r\n\r\n  const state = React.useMemo(() => {\r\n    if (failureReasons.length > 0) {\r\n      return 'failed';\r\n    }\r\n\r\n    let state: AgentState = 'disconnected';\r\n\r\n    if (roomConnectionState !== ConnectionState.Disconnected) {\r\n      state = 'connecting';\r\n    }\r\n\r\n    // If the microphone preconnect buffer is active, then a special 'pre-connect-buffering' state\r\n    // is set\r\n    if (localMicTrack) {\r\n      state = 'pre-connect-buffering';\r\n    }\r\n\r\n    if (agentParticipant && agentParticipantAttributes[ParticipantAgentAttributes.AgentState]) {\r\n      state = agentParticipantAttributes[ParticipantAgentAttributes.AgentState] as AgentSdkStates;\r\n    }\r\n\r\n    return state;\r\n  }, [\r\n    failureReasons,\r\n    roomConnectionState,\r\n    localMicTrack,\r\n    agentParticipant,\r\n    agentParticipantAttributes,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.StateChanged, state);\r\n    updateAgentTimeoutState(state);\r\n  }, [emitter, state]);\r\n  React.useEffect(() => {\r\n    updateAgentTimeoutParticipantExists(agentParticipant !== null);\r\n  }, [agentParticipant]);\r\n\r\n  // When the session room begins connecting, start the agent timeout\r\n  const isSessionDisconnected = session.connectionState === 'disconnected';\r\n  React.useEffect(() => {\r\n    if (isSessionDisconnected) {\r\n      return;\r\n    }\r\n\r\n    startAgentTimeout(agentConnectTimeoutMilliseconds);\r\n    return () => {\r\n      clearAgentTimeout();\r\n    };\r\n  }, [isSessionDisconnected, agentConnectTimeoutMilliseconds]);\r\n\r\n  const {\r\n    identity: agentParticipantIdentity,\r\n    name: agentParticipantName,\r\n    metadata: agentParticipantMetadata,\r\n  } = useParticipantInfo({ participant: agentParticipant ?? undefined });\r\n\r\n  const agentState: AgentStateCases = React.useMemo(() => {\r\n    const common: AgentStateCommon = {\r\n      attributes: agentParticipantAttributes,\r\n\r\n      internal: {\r\n        agentParticipant,\r\n        workerParticipant,\r\n        emitter,\r\n      },\r\n    };\r\n\r\n    switch (state) {\r\n      case 'disconnected':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n\r\n      case 'connecting':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n\r\n      case 'initializing':\r\n      case 'idle':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'pre-connect-buffering':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'listening':\r\n      case 'thinking':\r\n      case 'speaking':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'failed':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state: 'failed',\r\n          ...generateDerivedStateValues('failed'),\r\n          failureReasons,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n    }\r\n  }, [\r\n    agentParticipantIdentity,\r\n    agentParticipantName,\r\n    agentParticipantMetadata,\r\n    agentParticipantAttributes,\r\n    emitter,\r\n    agentParticipant,\r\n    state,\r\n    videoTrack,\r\n    audioTrack,\r\n  ]);\r\n\r\n  const { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished } =\r\n    useAgentWaitUntilDerivedStates(emitter, state);\r\n\r\n  const waitUntilCamera = React.useCallback(\r\n    (signal?: AbortSignal) => {\r\n      return new Promise<TrackReference>((resolve, reject) => {\r\n        const stateChangedHandler = (camera: TrackReference | undefined) => {\r\n          if (!camera) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve(camera);\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilCamera - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.CameraChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.CameraChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilMicrophone = React.useCallback(\r\n    (signal?: AbortSignal) => {\r\n      return new Promise<TrackReference>((resolve, reject) => {\r\n        const stateChangedHandler = (microphone: TrackReference | undefined) => {\r\n          if (!microphone) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve(microphone);\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilMicrophone - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.MicrophoneChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.MicrophoneChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return React.useMemo(() => {\r\n    return {\r\n      ...agentState,\r\n      waitUntilConnected,\r\n      waitUntilCouldBeListening,\r\n      waitUntilFinished,\r\n      waitUntilCamera,\r\n      waitUntilMicrophone,\r\n    };\r\n  }, [\r\n    agentState,\r\n    waitUntilConnected,\r\n    waitUntilCouldBeListening,\r\n    waitUntilFinished,\r\n    waitUntilCamera,\r\n    waitUntilMicrophone,\r\n  ]);\r\n}\r\n","import * as React from 'react';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport {\r\n  Room,\r\n  RoomEvent,\r\n  ConnectionState,\r\n  TrackPublishOptions,\r\n  Track,\r\n  TokenSourceConfigurable,\r\n  TokenSourceFixed,\r\n  TokenSourceFetchOptions,\r\n  RoomConnectOptions,\r\n  decodeTokenPayload,\r\n} from 'livekit-client';\r\nimport { EventEmitter } from 'events';\r\n\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { AgentState, useAgent, useAgentTimeoutIdStore } from './useAgent';\r\nimport { TrackReference } from '@livekit/components-core';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\n\r\n/** @beta */\r\nexport enum SessionEvent {\r\n  ConnectionStateChanged = 'connectionStateChanged',\r\n  /**\r\n   * Emits when an error is encountered while attempting to create a track.\r\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\r\n   * args: (error: Error, kind: MediaDeviceKind)\r\n   */\r\n  MediaDevicesError = 'mediaDevicesError',\r\n  /**\r\n   * Emits when an error is received while decrypting frame received frame information.\r\n   * args: (error: Error)\r\n   */\r\n  EncryptionError = 'encryptionError',\r\n}\r\n\r\n/** @beta */\r\nexport type SessionCallbacks = {\r\n  [SessionEvent.ConnectionStateChanged]: (newAgentConnectionState: ConnectionState) => void;\r\n  [SessionEvent.MediaDevicesError]: (error: Error) => void;\r\n  [SessionEvent.EncryptionError]: (error: Error) => void;\r\n};\r\n\r\n/** @beta */\r\nexport type SessionConnectOptions = {\r\n  /** Optional abort signal which if triggered will terminate connecting even if it isn't complete */\r\n  signal?: AbortSignal;\r\n\r\n  tracks?: {\r\n    microphone?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n    camera?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n    screenShare?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n  };\r\n\r\n  /** Options for Room.connect(.., .., opts) */\r\n  roomConnectOptions?: RoomConnectOptions;\r\n};\r\n\r\n/** @beta */\r\nexport type SwitchActiveDeviceOptions = {\r\n  /**\r\n   *  If true, adds an `exact` constraint to the getUserMedia request.\r\n   *  The request will fail if this option is true and the device specified is not actually available\r\n   */\r\n  exact?: boolean;\r\n};\r\n\r\ntype SessionStateCommon = {\r\n  room: Room;\r\n  internal: {\r\n    emitter: TypedEventEmitter<SessionCallbacks>;\r\n    tokenSource: TokenSourceConfigurable | TokenSourceFixed;\r\n    agentConnectTimeoutMilliseconds?: number;\r\n\r\n    agentTimeoutFailureReason: string | null;\r\n    startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\r\n    clearAgentTimeout: () => void;\r\n    clearAgentTimeoutFailureReason: () => void;\r\n    updateAgentTimeoutState: (agentState: AgentState) => void;\r\n    updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\r\n  };\r\n};\r\n\r\ntype SessionStateConnecting = SessionStateCommon & {\r\n  connectionState: ConnectionState.Connecting;\r\n  isConnected: false;\r\n\r\n  local: {\r\n    cameraTrack: undefined;\r\n    microphoneTrack: undefined;\r\n    screenShareTrack: undefined;\r\n  };\r\n};\r\n\r\ntype SessionStateConnected = SessionStateCommon & {\r\n  connectionState:\r\n    | ConnectionState.Connected\r\n    | ConnectionState.Reconnecting\r\n    | ConnectionState.SignalReconnecting;\r\n  isConnected: true;\r\n\r\n  local: {\r\n    cameraTrack?: TrackReference;\r\n    microphoneTrack?: TrackReference;\r\n    screenShareTrack?: TrackReference;\r\n  };\r\n};\r\n\r\ntype SessionStateDisconnected = SessionStateCommon & {\r\n  connectionState: ConnectionState.Disconnected;\r\n  isConnected: false;\r\n\r\n  local: {\r\n    cameraTrack: undefined;\r\n    microphoneTrack: undefined;\r\n    screenShareTrack: undefined;\r\n  };\r\n};\r\n\r\ntype SessionActions = {\r\n  /** Returns a promise that resolves once the room connects. */\r\n  waitUntilConnected: (signal?: AbortSignal) => void;\r\n  /** Returns a promise that resolves once the room disconnects */\r\n  waitUntilDisconnected: (signal?: AbortSignal) => void;\r\n\r\n  prepareConnection: () => Promise<void>;\r\n\r\n  /** Connect to the underlying room and dispatch any agents */\r\n  start: (options?: SessionConnectOptions) => Promise<void>;\r\n\r\n  /** Disconnect from the underlying room */\r\n  end: () => Promise<void>;\r\n};\r\n\r\n/** @beta */\r\nexport type UseSessionReturn = (\r\n  | SessionStateConnecting\r\n  | SessionStateConnected\r\n  | SessionStateDisconnected\r\n) &\r\n  SessionActions;\r\n\r\ntype UseSessionCommonOptions = {\r\n  room?: Room;\r\n\r\n  /**\r\n   * Amount of time in milliseonds the system will wait for an agent to join the room, before\r\n   * transitioning to the \"failure\" state.\r\n   */\r\n  agentConnectTimeoutMilliseconds?: number;\r\n};\r\n\r\ntype UseSessionConfigurableOptions = UseSessionCommonOptions & TokenSourceFetchOptions;\r\ntype UseSessionFixedOptions = UseSessionCommonOptions;\r\n\r\n/**\r\n * Given two TokenSourceFetchOptions values, check to see if they are deep equal.\r\n *\r\n * FIXME: swap this for an import from livekit-client once\r\n * https://github.com/livekit/client-sdk-js/pull/1733 is merged and published!\r\n * */\r\nfunction areTokenSourceFetchOptionsEqual(a: TokenSourceFetchOptions, b: TokenSourceFetchOptions) {\r\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]) as Set<\r\n    keyof TokenSourceFetchOptions\r\n  >;\r\n\r\n  for (const key of allKeysSet) {\r\n    switch (key) {\r\n      case 'roomName':\r\n      case 'participantName':\r\n      case 'participantIdentity':\r\n      case 'participantMetadata':\r\n      case 'participantAttributes':\r\n      case 'agentName':\r\n      case 'agentMetadata':\r\n        if (a[key] !== b[key]) {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        // ref: https://stackoverflow.com/a/58009992\r\n        const exhaustiveCheckedKey: never = key;\r\n        throw new Error(`Options key ${exhaustiveCheckedKey} not being checked for equality!`);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/** Internal hook used by useSession to manage creating a function which can be used to wait\r\n * until the session is in a given state before resolving. */\r\nfunction useSessionWaitUntilConnectionState(\r\n  emitter: TypedEventEmitter<SessionCallbacks>,\r\n  connectionState: UseSessionReturn['connectionState'],\r\n) {\r\n  const connectionStateRef = React.useRef(connectionState);\r\n  React.useEffect(() => {\r\n    connectionStateRef.current = connectionState;\r\n  }, [connectionState]);\r\n\r\n  const waitUntilConnectionState = React.useCallback(\r\n    async (state: UseSessionReturn['connectionState'], signal?: AbortSignal) => {\r\n      if (connectionStateRef.current === state) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const onceEventOccurred = (newState: UseSessionReturn['connectionState']) => {\r\n          if (newState !== state) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(\r\n            new Error(\r\n              `useSession(/* ... */).waitUntilConnectionState(${state}, /* signal */) - signal aborted`,\r\n            ),\r\n          );\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(SessionEvent.ConnectionStateChanged, onceEventOccurred);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(SessionEvent.ConnectionStateChanged, onceEventOccurred);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return waitUntilConnectionState;\r\n}\r\n\r\n/** Internal hook used by useSession to manage creating a function that properly invokes\r\n * tokenSource.fetch(...) with any fetch options */\r\nfunction useSessionTokenSourceFetch(\r\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\r\n  unstableRestOptions: Exclude<UseSessionConfigurableOptions, keyof UseSessionCommonOptions>,\r\n) {\r\n  const isConfigurable = tokenSource instanceof TokenSourceConfigurable;\r\n\r\n  const memoizedTokenFetchOptionsRef = React.useRef<TokenSourceFetchOptions | null>(\r\n    isConfigurable ? unstableRestOptions : null,\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!isConfigurable) {\r\n      memoizedTokenFetchOptionsRef.current = null;\r\n      return;\r\n    }\r\n\r\n    if (\r\n      memoizedTokenFetchOptionsRef.current !== null &&\r\n      areTokenSourceFetchOptionsEqual(memoizedTokenFetchOptionsRef.current, unstableRestOptions)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    memoizedTokenFetchOptionsRef.current = unstableRestOptions;\r\n  }, [isConfigurable, unstableRestOptions]);\r\n\r\n  const tokenSourceFetch = React.useCallback(async () => {\r\n    if (isConfigurable) {\r\n      if (!memoizedTokenFetchOptionsRef.current) {\r\n        throw new Error(\r\n          `AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!`,\r\n        );\r\n      }\r\n      return tokenSource.fetch(memoizedTokenFetchOptionsRef.current);\r\n    } else {\r\n      return tokenSource.fetch();\r\n    }\r\n  }, [isConfigurable, tokenSource]);\r\n\r\n  return tokenSourceFetch;\r\n}\r\n\r\n/**\r\n * A Session represents a managed connection to a Room which can contain Agents.\r\n * @beta\r\n */\r\nexport function useSession(\r\n  tokenSource: TokenSourceConfigurable,\r\n  options?: UseSessionConfigurableOptions,\r\n): UseSessionReturn;\r\n/**\r\n * A Session represents a managed connection to a Room which can contain Agents.\r\n * @beta\r\n */\r\nexport function useSession(\r\n  tokenSource: TokenSourceFixed,\r\n  options?: UseSessionFixedOptions,\r\n): UseSessionReturn;\r\nexport function useSession(\r\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\r\n  options: UseSessionConfigurableOptions | UseSessionFixedOptions = {},\r\n): UseSessionReturn {\r\n  const { room: optionsRoom, agentConnectTimeoutMilliseconds, ...restOptions } = options;\r\n\r\n  const roomFromContext = useMaybeRoomContext();\r\n  const room = React.useMemo(\r\n    () => roomFromContext ?? optionsRoom ?? new Room(),\r\n    [roomFromContext, optionsRoom],\r\n  );\r\n\r\n  const emitter = React.useMemo(\r\n    () => new EventEmitter() as TypedEventEmitter<SessionCallbacks>,\r\n    [],\r\n  );\r\n\r\n  const generateDerivedConnectionStateValues = React.useCallback(\r\n    <State extends UseSessionReturn['connectionState']>(connectionState: State) =>\r\n      ({\r\n        isConnected:\r\n          connectionState === ConnectionState.Connected ||\r\n          connectionState === ConnectionState.Reconnecting ||\r\n          connectionState === ConnectionState.SignalReconnecting,\r\n      }) as {\r\n        isConnected: State extends\r\n          | ConnectionState.Connected\r\n          | ConnectionState.Reconnecting\r\n          | ConnectionState.SignalReconnecting\r\n          ? true\r\n          : false;\r\n      },\r\n    [],\r\n  );\r\n\r\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\r\n  React.useEffect(() => {\r\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\r\n      setRoomConnectionState(connectionState);\r\n    };\r\n\r\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    return () => {\r\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    };\r\n  }, [room]);\r\n\r\n  React.useEffect(() => {\r\n    const handleMediaDevicesError = async (error: Error) => {\r\n      emitter.emit(SessionEvent.MediaDevicesError, error);\r\n    };\r\n\r\n    room.on(RoomEvent.MediaDevicesError, handleMediaDevicesError);\r\n    return () => {\r\n      room.off(RoomEvent.MediaDevicesError, handleMediaDevicesError);\r\n    };\r\n  }, [room, emitter]);\r\n\r\n  React.useEffect(() => {\r\n    const handleEncryptionError = async (error: Error) => {\r\n      emitter.emit(SessionEvent.EncryptionError, error);\r\n    };\r\n\r\n    room.on(RoomEvent.EncryptionError, handleEncryptionError);\r\n    return () => {\r\n      room.off(RoomEvent.EncryptionError, handleEncryptionError);\r\n    };\r\n  }, [room, emitter]);\r\n\r\n  const { localParticipant } = useLocalParticipant({ room });\r\n  const cameraPublication = localParticipant.getTrackPublication(Track.Source.Camera);\r\n  const localCamera = React.useMemo(() => {\r\n    if (!cameraPublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.Camera,\r\n      participant: localParticipant,\r\n      publication: cameraPublication,\r\n    };\r\n  }, [localParticipant, cameraPublication]);\r\n  const microphonePublication = localParticipant.getTrackPublication(Track.Source.Microphone);\r\n  const localMicrophone = React.useMemo(() => {\r\n    if (!microphonePublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.Microphone,\r\n      participant: localParticipant,\r\n      publication: microphonePublication,\r\n    };\r\n  }, [localParticipant, microphonePublication]);\r\n  const screenSharePublication = localParticipant.getTrackPublication(Track.Source.ScreenShare);\r\n  const localScreenShare = React.useMemo(() => {\r\n    if (!screenSharePublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.ScreenShare,\r\n      participant: localParticipant,\r\n      publication: screenSharePublication,\r\n    };\r\n  }, [localParticipant, screenSharePublication]);\r\n\r\n  const {\r\n    agentTimeoutFailureReason,\r\n    startAgentTimeout,\r\n    clearAgentTimeout,\r\n    clearAgentTimeoutFailureReason,\r\n    updateAgentTimeoutState,\r\n    updateAgentTimeoutParticipantExists,\r\n  } = useAgentTimeoutIdStore();\r\n\r\n  const sessionInternal: UseSessionReturn['internal'] = React.useMemo(\r\n    () => ({\r\n      emitter,\r\n      tokenSource,\r\n      agentConnectTimeoutMilliseconds,\r\n\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    }),\r\n    [\r\n      emitter,\r\n      agentConnectTimeoutMilliseconds,\r\n      tokenSource,\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    ],\r\n  );\r\n\r\n  const conversationState = React.useMemo(():\r\n    | SessionStateConnecting\r\n    | SessionStateConnected\r\n    | SessionStateDisconnected => {\r\n    const common: SessionStateCommon = {\r\n      room,\r\n      internal: sessionInternal,\r\n    };\r\n\r\n    switch (roomConnectionState) {\r\n      case ConnectionState.Connecting:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: ConnectionState.Connecting,\r\n          ...generateDerivedConnectionStateValues(ConnectionState.Connecting),\r\n\r\n          local: {\r\n            cameraTrack: undefined,\r\n            microphoneTrack: undefined,\r\n            screenShareTrack: undefined,\r\n          },\r\n        };\r\n\r\n      case ConnectionState.Connected:\r\n      case ConnectionState.Reconnecting:\r\n      case ConnectionState.SignalReconnecting:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: roomConnectionState,\r\n          ...generateDerivedConnectionStateValues(roomConnectionState),\r\n\r\n          local: {\r\n            cameraTrack: localCamera,\r\n            microphoneTrack: localMicrophone,\r\n            screenShareTrack: localScreenShare,\r\n          },\r\n        };\r\n\r\n      case ConnectionState.Disconnected:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: ConnectionState.Disconnected,\r\n          ...generateDerivedConnectionStateValues(ConnectionState.Disconnected),\r\n\r\n          local: {\r\n            cameraTrack: undefined,\r\n            microphoneTrack: undefined,\r\n            screenShareTrack: undefined,\r\n          },\r\n        };\r\n    }\r\n  }, [\r\n    sessionInternal,\r\n    room,\r\n    roomConnectionState,\r\n    localCamera,\r\n    localMicrophone,\r\n    generateDerivedConnectionStateValues,\r\n  ]);\r\n  React.useEffect(() => {\r\n    emitter.emit(SessionEvent.ConnectionStateChanged, conversationState.connectionState);\r\n  }, [emitter, conversationState.connectionState]);\r\n\r\n  const waitUntilConnectionState = useSessionWaitUntilConnectionState(\r\n    emitter,\r\n    conversationState.connectionState,\r\n  );\r\n\r\n  const waitUntilConnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      return waitUntilConnectionState(\r\n        ConnectionState.Connected /* FIXME: should I check for other states too? */,\r\n        signal,\r\n      );\r\n    },\r\n    [waitUntilConnectionState],\r\n  );\r\n\r\n  const waitUntilDisconnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      return waitUntilConnectionState(ConnectionState.Disconnected, signal);\r\n    },\r\n    [waitUntilConnectionState],\r\n  );\r\n\r\n  const agent = useAgent(\r\n    React.useMemo(\r\n      () => ({\r\n        connectionState: conversationState.connectionState,\r\n        room,\r\n        internal: sessionInternal,\r\n      }),\r\n      [conversationState, room, sessionInternal],\r\n    ),\r\n  );\r\n\r\n  const tokenSourceFetch = useSessionTokenSourceFetch(tokenSource, restOptions);\r\n\r\n  const start = React.useCallback(\r\n    async (connectOptions: SessionConnectOptions = {}) => {\r\n      const {\r\n        signal,\r\n        tracks = { microphone: { enabled: true, publishOptions: { preConnectBuffer: true } } },\r\n        roomConnectOptions,\r\n      } = connectOptions;\r\n\r\n      await waitUntilDisconnected(signal);\r\n\r\n      const onSignalAbort = () => {\r\n        room.disconnect();\r\n      };\r\n      signal?.addEventListener('abort', onSignalAbort);\r\n\r\n      let tokenDispatchesAgent = false;\r\n      await Promise.all([\r\n        tokenSourceFetch().then(({ serverUrl, participantToken }) => {\r\n          const participantTokenPayload = decodeTokenPayload(participantToken);\r\n          const participantTokenAgentDispatchCount =\r\n            participantTokenPayload.roomConfig?.agents?.length ?? 0;\r\n          tokenDispatchesAgent = participantTokenAgentDispatchCount > 0;\r\n\r\n          return room.connect(serverUrl, participantToken, roomConnectOptions);\r\n        }),\r\n\r\n        // Start microphone (with preconnect buffer) by default\r\n        tracks.microphone?.enabled\r\n          ? room.localParticipant.setMicrophoneEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.microphone?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n        tracks.camera?.enabled\r\n          ? room.localParticipant.setCameraEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.camera?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n        tracks.screenShare?.enabled\r\n          ? room.localParticipant.setScreenShareEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.screenShare?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n      ]);\r\n\r\n      await waitUntilConnected(signal);\r\n      if (tokenDispatchesAgent) {\r\n        await agent.waitUntilConnected(signal);\r\n      }\r\n\r\n      signal?.removeEventListener('abort', onSignalAbort);\r\n    },\r\n    [room, waitUntilDisconnected, tokenSourceFetch, waitUntilConnected, agent.waitUntilConnected],\r\n  );\r\n\r\n  const end = React.useCallback(async () => {\r\n    await room.disconnect();\r\n  }, [room]);\r\n\r\n  const prepareConnection = React.useCallback(async () => {\r\n    const credentials = await tokenSourceFetch();\r\n    await room.prepareConnection(credentials.serverUrl, credentials.participantToken);\r\n  }, [tokenSourceFetch, room]);\r\n  React.useEffect(\r\n    () => {\r\n      prepareConnection().catch((err) => {\r\n        // FIXME: figure out a better logging solution?\r\n        console.warn('WARNING: Room.prepareConnection failed:', err);\r\n      });\r\n    },\r\n    [\r\n      /* note: no prepareConnection here, this effect should only ever run once! */\r\n    ],\r\n  );\r\n\r\n  return React.useMemo(\r\n    () => ({\r\n      ...conversationState,\r\n\r\n      waitUntilConnected,\r\n      waitUntilDisconnected,\r\n\r\n      prepareConnection,\r\n      start,\r\n      end,\r\n    }),\r\n    [conversationState, waitUntilConnected, waitUntilDisconnected, prepareConnection, start, end],\r\n  );\r\n}\r\n","import * as React from 'react';\r\nimport TypedEventEmitter, { EventMap } from 'typed-emitter';\r\n\r\n/** @public */\r\nexport function useEvents<\r\n  Emitter extends TypedEventEmitter<EventMap>,\r\n  EmitterEventMap extends Emitter extends TypedEventEmitter<infer EM> ? EM : never,\r\n  Event extends Parameters<Emitter['on']>[0],\r\n  Callback extends EmitterEventMap[Event],\r\n>(\r\n  instance: Emitter | { internal: { emitter: Emitter } } | null | undefined,\r\n  event: Event,\r\n  handlerFn: Callback | undefined,\r\n  dependencies?: React.DependencyList,\r\n) {\r\n  const fallback = React.useMemo(() => () => {}, []);\r\n  const wrappedCallback = React.useCallback(handlerFn ?? fallback, dependencies ?? []);\r\n  const callback = dependencies ? wrappedCallback : handlerFn;\r\n\r\n  const emitter = React.useMemo(() => {\r\n    if (!instance) {\r\n      return null;\r\n    }\r\n    if ('internal' in instance) {\r\n      return instance.internal.emitter;\r\n    }\r\n    return instance;\r\n  }, [instance]);\r\n\r\n  React.useEffect(() => {\r\n    if (!emitter || !callback) {\r\n      return;\r\n    }\r\n    emitter.on(event, callback);\r\n    return () => {\r\n      emitter.off(event, callback);\r\n    };\r\n  }, [emitter, event, callback]);\r\n}\r\n","import * as React from 'react';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport { SendTextOptions } from 'livekit-client';\r\nimport { EventEmitter } from 'events';\r\nimport {\r\n  ReceivedMessage,\r\n  ReceivedChatMessage,\r\n  TextStreamData,\r\n  ReceivedUserTranscriptionMessage,\r\n  ReceivedAgentTranscriptionMessage,\r\n} from '@livekit/components-core';\r\n\r\nimport { useAgent } from './useAgent';\r\nimport { useTranscriptions } from './useTranscriptions';\r\nimport { useChat } from './useChat';\r\nimport { UseSessionReturn } from './useSession';\r\nimport { useEnsureSession } from '../context';\r\n\r\n/** @beta */\r\nexport type UseSessionMessagesReturn = {\r\n  messages: Array<ReceivedMessage>;\r\n\r\n  /** Is a send operation currently in progress? */\r\n  isSending: boolean;\r\n\r\n  send: (message: string, options?: SendTextOptions) => Promise<ReceivedChatMessage>;\r\n\r\n  internal: {\r\n    emitter: TypedEventEmitter<MessagesCallbacks>;\r\n  };\r\n};\r\n\r\n/** @beta */\r\nexport enum MessagesEvent {\r\n  /**\r\n   * Emits when a new message is received from a participant\r\n   * args: (message: ReceivedMessage)\r\n   */\r\n  MessageReceived = 'messageReceived',\r\n}\r\n\r\n/** @beta */\r\nexport type MessagesCallbacks = {\r\n  [MessagesEvent.MessageReceived]: (message: ReceivedMessage) => void;\r\n};\r\n\r\n/** @beta */\r\nexport function useSessionMessages(session?: UseSessionReturn): UseSessionMessagesReturn {\r\n  const { room } = useEnsureSession(session);\r\n\r\n  const emitter = React.useMemo(\r\n    () => new EventEmitter() as TypedEventEmitter<MessagesCallbacks>,\r\n    [],\r\n  );\r\n\r\n  const agent = useAgent(session);\r\n\r\n  const transcriptions: Array<TextStreamData> = useTranscriptions({ room });\r\n  const chatOptions = React.useMemo(() => ({ room }), [room]);\r\n  const chat = useChat(chatOptions);\r\n\r\n  const transcriptionMessages: Array<\r\n    ReceivedUserTranscriptionMessage | ReceivedAgentTranscriptionMessage\r\n  > = React.useMemo(() => {\r\n    return transcriptions.map((transcription) => {\r\n      switch (transcription.participantInfo.identity) {\r\n        case room.localParticipant.identity:\r\n          return {\r\n            type: 'userTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from: room.localParticipant,\r\n          };\r\n\r\n        case agent.internal.agentParticipant?.identity:\r\n        case agent.internal.workerParticipant?.identity:\r\n          return {\r\n            type: 'agentTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from:\r\n              agent.internal.agentParticipant?.identity === transcription.participantInfo.identity\r\n                ? agent.internal.agentParticipant\r\n                : agent.internal.workerParticipant!,\r\n          };\r\n\r\n        default:\r\n          // FIXME: what should happen if an associated participant is not found?\r\n          //\r\n          // For now, just assume it is an agent transcription, since maybe it is from an agent\r\n          // which disconencted from the room or something like that.\r\n          return {\r\n            type: 'agentTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from: Array.from(room.remoteParticipants.values()).find(\r\n              (p) => p.identity === transcription.participantInfo.identity,\r\n            ),\r\n          };\r\n      }\r\n    });\r\n  }, [transcriptions, room]);\r\n\r\n  const receivedMessages = React.useMemo(() => {\r\n    const merged: Array<ReceivedMessage> = [...transcriptionMessages, ...chat.chatMessages];\r\n    return merged;\r\n  }, [transcriptionMessages, chat.chatMessages]);\r\n\r\n  const messageFirstReceivedTimeMapRef = React.useRef(new Map<ReceivedMessage['id'], Date>());\r\n  const sortedReceivedMessages = React.useMemo(() => {\r\n    const now = new Date();\r\n    for (const message of receivedMessages) {\r\n      if (messageFirstReceivedTimeMapRef.current.has(message.id)) {\r\n        continue;\r\n      }\r\n\r\n      messageFirstReceivedTimeMapRef.current.set(message.id, now);\r\n    }\r\n\r\n    return receivedMessages.sort((a, b) => {\r\n      const aFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(a.id);\r\n      const bFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(b.id);\r\n      if (typeof aFirstReceivedAt === 'undefined' || typeof bFirstReceivedAt === 'undefined') {\r\n        return 0;\r\n      }\r\n\r\n      return aFirstReceivedAt.getTime() - bFirstReceivedAt.getTime();\r\n    });\r\n  }, [receivedMessages]);\r\n\r\n  const previouslyReceivedMessageIdsRef = React.useRef(new Set());\r\n  React.useEffect(() => {\r\n    for (const message of sortedReceivedMessages) {\r\n      if (previouslyReceivedMessageIdsRef.current.has(message.id)) {\r\n        continue;\r\n      }\r\n\r\n      previouslyReceivedMessageIdsRef.current.add(message.id);\r\n      emitter.emit(MessagesEvent.MessageReceived, message);\r\n    }\r\n  }, [sortedReceivedMessages]);\r\n\r\n  return React.useMemo(\r\n    () => ({\r\n      messages: sortedReceivedMessages,\r\n      send: chat.send,\r\n      isSending: chat.isSending,\r\n      internal: { emitter },\r\n    }),\r\n    [sortedReceivedMessages, chat.send, chat.isSending],\r\n  );\r\n}\r\n"],"names":["useLatest","current","storedValue","React","useResizeObserver","target","callback","resizeObserver","getResizeObserver","storedCallback","didUnsubscribe","targetEl","cb","entry","observer","createResizeObserver","ticking","allEntries","callbacks","entries","obs","triggered","i","cbs","cbIndex","_resizeObserver","useSize","size","setSize","width","height","resizeCallback","useObservableState","observable","startWith","resetWhenObservableChanges","state","setState","subscription","useMediaQuery","query","getMatches","matches","setMatches","handleChange","matchMedia","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","roomAudioPlaybackAllowedObservable","canPlayAudio","r","f","n","clsx","chain","args","e","mergeProps","result","props","key","a","b","useClearPinButton","dispatch","useLayoutContext","className","setupClearPinButton","useConnectionQualityIndicator","options","p","useEnsureParticipant","connectionQualityObserver","setupConnectionQualityIndicator","quality","useConnectionState","connectionStateObserver","useDataChannel","topicOrCallback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","useDisconnectButton","connectionState","disconnect","setupDisconnectButton","ConnectionState","useFacingMode","trackReference","LocalTrackPublication","localTrack","facingMode","facingModeFromLocalTrack","useFocusToggle","trackRef","useEnsureTrackRef","layoutContext","useMaybeLayoutContext","setupFocusToggle","inFocus","isTrackReferencePinned","event","_a","_c","_b","_e","_d","useGridLayout","gridElement","trackCount","gridLayouts","GRID_LAYOUTS","layout","selectGridLayout","useIsMuted","sourceOrTrackRef","passedParticipant","ref","isMuted","setIsMuted","listener","mutedObserver","getTrackReferenceId","useIsSpeaking","participant","createIsSpeakingObserver","isProp","prop","mergePropsReactAria","cloneSingleChild","children","child","warnAboutMissingStyles","el","log","roomOptionsStringifyReplacer","val","defaultRoomProps","useLiveKitRoom","token","serverUrl","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","setRoom","shouldConnect","Room","htmlProps","setupLiveKitRoom","onSignalConnected","localP","handleMediaDeviceError","kind","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useLocalParticipant","localParticipant","setLocalParticipant","isMicrophoneEnabled","setIsMicrophoneEnabled","isCameraEnabled","setIsCameraEnabled","isScreenShareEnabled","setIsScreenShareEnabled","lastMicrophoneError","setLastMicrophoneError","lastCameraError","setLastCameraError","microphoneTrack","setMicrophoneTrack","cameraTrack","setCameraTrack","handleUpdate","media","observeParticipantMedia","useLocalParticipantPermissions","permissionObserver","participantPermissionObserver","useMediaDeviceSelect","track","requestPermissions","roomContext","useMaybeRoomContext","roomFallback","deviceObserver","createMediaDeviceObserver","devices","currentDeviceId","setCurrentDeviceId","activeDeviceObservable","setActiveMediaDevice","setupDeviceSelector","deviceId","useMediaDevices","useVisualStableUpdate","trackReferences","maxItemsOnPage","lastTrackRefs","lastMaxItemsOnPage","layoutChanged","sortedTrackRefs","sortTrackReferences","updatedTrackRefs","updatePages","error","usePagination","itemPerPage","currentPage","setCurrentPage","totalPageCount","lastItemIndex","firstItemIndex","changePage","direction","goToPage","num","tracksOnPage","useParticipantInfo","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useParticipantTile","onParticipantClick","disableSpeakingIndicator","mergedProps","setupParticipantTile","micTrack","Track","micRef","isVideoMuted","isAudioMuted","isSpeaking","useRemoteParticipants","participants","setParticipants","connectedParticipantsObserver","useParticipants","remoteParticipants","usePinnedTracks","useEnsureLayoutContext","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","ensuredRoom","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useStartAudio","handleStartAudioPlayback","setupStartAudio","useStartVideo","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","setupStartVideo","canPlayVideo","useSwipe","element","touchStart","touchEnd","minSwipeDistance","onTouchStart","onTouchMove","onTouchEnd","distance","isLeftSwipe","isRightSwipe","elementCopy","useChatToggle","setupChatToggle","useToken","tokenEndpoint","roomName","setToken","params","res","accessToken","useTrackMutedIndicator","mediaMutedObserver","setupTrackMutedIndicator","useTrackToggle","source","onChange","initialState","captureOptions","publishOptions","onDeviceError","roomFromContext","userInteractionRef","toggle","pendingObserver","enabledObserver","setupMediaToggle","setupManualToggle","pending","enabled","newProps","clickHandler","evt","useTracks","sources","setTrackReferences","sources_","s","isSourceWitOptions","trackReferencesObservable","isSourcesWithOptions","requirePlaceholder","requiredPlaceholders","trackReferencesWithPlaceholders","placeholderSource","publication","placeholder","difference","setA","setB","_difference","elem","placeholderMap","sourcesThatNeedPlaceholder","sourceWithOption","sourcesOfSubscribedTracks","pub","trackSource","placeholderNeededForThisParticipant","useTrackRefBySourceOrName","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","useTrackByName","useChat","isDisconnected","setup","setupChat","chatMessages","usePersistentUserChoices","userChoices","setSettings","loadUserChoices","saveAudioInputEnabled","isEnabled","prev","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","username","saveUserChoices","useIsEncrypted","encryptionStatusObservable","useTrackVolume","trackOrTrackReference","isTrackReference","volume","setVolume","cleanup","analyser","createAudioAnalyser","bufferLength","dataArray","interval","sum","normalizeFrequencies","frequencies","normalizeDb","value","db","multibandDefaults","useMultibandTrackVolume","opts","frequencyBands","setFrequencyBands","normalizedFrequencies","totalBins","chunks","startIndex","endIndex","chunk","chunkLength","summedVolumes","acc","waveformDefaults","useAudioWaveform","aggregateWave","timeRef","updates","bars","setBars","onUpdate","wave","filterData","v","getFFTSizeValue","update","updateWaveform","newData","x","pow2ceil","audioData","numSamples","blockSize","filteredData","blockStart","j","useParticipantTracks","optionsOrParticipantIdentity","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","trackSyncTimeObserver","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","addTimestampsToTranscription","trackTranscriptionObserver","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","state_attribute","ParticipantAgentAttributes","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","attributes","useIsRecording","recordingStatusObservable","useTextStream","textStreamData","setupTextStream","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream","CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY","CONNECT_DISCONNECT_WARNING_THRESHOLD_MS","ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY","ROOM_CHANGE_WARNING_THRESHOLD_MS","useSequentialRoomConnectDisconnect","connectDisconnectQueueRef","useRef","processConnectsAndDisconnectsLock","useMemo","Mutex","processConnectsAndDisconnects","useCallback","unlock","roomChangedTimesRef","checkRoomThreshold","now","roomChangesInThreshold","isWithinThreshold","useEffect","connectDisconnectEnqueueTimes","checkConnectDisconnectThreshold","connectDisconnectsInThreshold","resolve","reject","R","ReflectApply","receiver","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","arg","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","index","ret","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS","AgentEvent","generateDerivedStateValues","useAgentTimeoutIdStore","agentTimeoutFailureReason","setAgentTimeoutFailureReason","agentTimeoutId","setAgentTimeoutId","agentStateRef","agentParticipantExistsRef","startAgentConnectedTimeout","agentConnectTimeoutMilliseconds","isConnected","agentState","agentParticipantExists","useAgentWaitUntilDerivedStates","stateRef","waitUntilConnected","signal","stateChangedHandler","abortHandler","waitUntilCouldBeListening","canListen","waitUntilFinished","isFinished","useAgent","session","sessionFromContext","useMaybeSessionContext","startAgentTimeout","clearAgentTimeout","clearAgentTimeoutFailureReason","updateAgentTimeoutState","updateAgentTimeoutParticipantExists","roomRemoteParticipants","agentParticipant","workerParticipant","agentParticipantAttributes","setAgentParticipantAttributes","handleAttributesChanged","ParticipantEvent","roomConnectionState","setRoomConnectionState","handleConnectionStateChanged","agentDisconnectedFailureReason","setAgentDisconnectedFailureReason","onParticipantDisconnect","localMicTrack","setLocalMicTrack","handleLocalParticipantTrackPublished","handleLocalParticipantTrackUnPublished","failureReasons","reasons","isSessionDisconnected","agentParticipantIdentity","agentParticipantName","agentParticipantMetadata","common","waitUntilCamera","camera","waitUntilMicrophone","microphone","SessionEvent","areTokenSourceFetchOptionsEqual","allKeysSet","exhaustiveCheckedKey","useSessionWaitUntilConnectionState","connectionStateRef","onceEventOccurred","newState","useSessionTokenSourceFetch","tokenSource","unstableRestOptions","isConfigurable","TokenSourceConfigurable","memoizedTokenFetchOptionsRef","useSession","optionsRoom","restOptions","generateDerivedConnectionStateValues","handleMediaDevicesError","cameraPublication","localCamera","microphonePublication","localMicrophone","screenSharePublication","localScreenShare","sessionInternal","conversationState","waitUntilConnectionState","waitUntilDisconnected","tokenSourceFetch","start","tracks","roomConnectOptions","onSignalAbort","tokenDispatchesAgent","participantToken","decodeTokenPayload","_f","end","prepareConnection","credentials","useEvents","instance","handlerFn","dependencies","fallback","wrappedCallback","MessagesEvent","useSessionMessages","useEnsureSession","transcriptions","chatOptions","chat","transcriptionMessages","transcription","receivedMessages","messageFirstReceivedTimeMapRef","sortedReceivedMessages","aFirstReceivedAt","bFirstReceivedAt","previouslyReceivedMessageIdsRef"],"mappings":";;;;AAIA,MAAMA,KAAY,CAAIC,MAAe;AACnC,QAAMC,IAAcC,EAAM,OAAOF,CAAO;AACxC,SAAAE,EAAM,UAAU,MAAM;AACpB,IAAAD,EAAY,UAAUD;AAAA,EACxB,CAAC,GACMC;AACT;AAQO,SAASE,GACdC,GACAC,GACA;AACA,QAAMC,IAAiBC,GAAA,GACjBC,IAAiBT,GAAUM,CAAQ;AAEzC,SAAAH,EAAM,gBAAgB,MAAM;AAC1B,QAAIO,IAAiB;AAErB,UAAMC,IAAWN,EAAO;AACxB,QAAI,CAACM,EAAU;AAEf,aAASC,EAAGC,GAA4BC,GAA0B;AAChE,MAAIJ,KACJD,EAAe,QAAQI,GAAOC,CAAQ;AAAA,IACxC;AAEA,WAAAP,KAAA,QAAAA,EAAgB,UAAUI,GAAyBC,IAE5C,MAAM;AACX,MAAAF,IAAiB,IACjBH,KAAA,QAAAA,EAAgB,YAAYI,GAAyBC;AAAA,IACvD;AAAA,EACF,GAAG,CAACP,EAAO,SAASE,GAAgBE,CAAc,CAAC,GAE5CF,KAAA,gBAAAA,EAAgB;AACzB;AAEA,SAASQ,KAAuB;AAC9B,MAAIC,IAAU,IACVC,IAAoC,CAAA;AAExC,QAAMC,wBAAgE,IAAA;AAEtE,MAAI,OAAO,SAAW;AACpB;AAGF,QAAMJ,IAAW,IAAI,eAAe,CAACK,GAAgCC,MAAwB;AAC3F,IAAAH,IAAaA,EAAW,OAAOE,CAAO,GACjCH,KACH,OAAO,sBAAsB,MAAM;AACjC,YAAMK,wBAAgB,IAAA;AACtB,eAASC,IAAI,GAAGA,IAAIL,EAAW,QAAQK,KAAK;AAC1C,YAAID,EAAU,IAAIJ,EAAWK,CAAC,EAAE,MAAM,EAAG;AACzC,QAAAD,EAAU,IAAIJ,EAAWK,CAAC,EAAE,MAAM;AAClC,cAAMC,IAAML,EAAU,IAAID,EAAWK,CAAC,EAAE,MAAM;AAC9C,QAAAC,KAAA,QAAAA,EAAK,QAAQ,CAACX,MAAOA,EAAGK,EAAWK,CAAC,GAAGF,CAAG;AAAA,MAC5C;AACA,MAAAH,IAAa,CAAA,GACbD,IAAU;AAAA,IACZ,CAAC,GAEHA,IAAU;AAAA,EACZ,CAAC;AAED,SAAO;AAAA,IACL,UAAAF;AAAA,IACA,UAAUT,GAAqBC,GAAqC;AAClE,MAAAQ,EAAS,QAAQT,CAAM;AACvB,YAAMkB,IAAML,EAAU,IAAIb,CAAM,KAAK,CAAA;AACrC,MAAAkB,EAAI,KAAKjB,CAAQ,GACjBY,EAAU,IAAIb,GAAQkB,CAAG;AAAA,IAC3B;AAAA,IACA,YAAYlB,GAAqBC,GAAqC;AACpE,YAAMiB,IAAML,EAAU,IAAIb,CAAM,KAAK,CAAA;AACrC,UAAIkB,EAAI,WAAW,GAAG;AACpB,QAAAT,EAAS,UAAUT,CAAM,GACzBa,EAAU,OAAOb,CAAM;AACvB;AAAA,MACF;AACA,YAAMmB,IAAUD,EAAI,QAAQjB,CAAQ;AACpC,MAAIkB,MAAY,MAAID,EAAI,OAAOC,GAAS,CAAC,GACzCN,EAAU,IAAIb,GAAQkB,CAAG;AAAA,IAC3B;AAAA,EAAA;AAEJ;AAEA,IAAIE;AAEJ,MAAMjB,KAAoB,MACvBiB,OAAmBA,KAAkBV,OAO3BW,KAAU,CAACrB,MAA4C;AAClE,QAAM,CAACsB,GAAMC,CAAO,IAAIzB,EAAM,SAAS,EAAE,OAAO,GAAG,QAAQ,GAAG;AAC9D,EAAAA,EAAM,gBAAgB,MAAM;AAC1B,QAAIE,EAAO,SAAS;AAClB,YAAM,EAAE,OAAAwB,GAAO,QAAAC,EAAA,IAAWzB,EAAO,QAAQ,sBAAA;AACzC,MAAAuB,EAAQ,EAAE,OAAAC,GAAO,QAAAC,GAAQ;AAAA,IAC3B;AAAA,EACF,GAAG,CAACzB,EAAO,OAAO,CAAC;AAEnB,QAAM0B,IAAiB5B,EAAM;AAAA,IAC3B,CAACU,MAA+Be,EAAQf,EAAM,WAAW;AAAA,IACzD,CAAA;AAAA,EAAC;AAGH,SAAAT,GAAkBC,GAAQ0B,CAAc,GACjCJ;AACT;ACpHO,SAASK,EACdC,GACAC,GACAC,IAA6B,IAC7B;AACA,QAAM,CAACC,GAAOC,CAAQ,IAAIlC,EAAM,SAAY+B,CAAS;AACrD,SAAA/B,EAAM,UAAU,MAAM;AAKpB,QAJIgC,KACFE,EAASH,CAAS,GAGhB,OAAO,SAAW,OAAe,CAACD,EAAY;AAClD,UAAMK,IAAeL,EAAW,UAAUI,CAAQ;AAClD,WAAO,MAAMC,EAAa,YAAA;AAAA,EAC5B,GAAG,CAACL,GAAYE,CAA0B,CAAC,GACpCC;AACT;ACjBO,SAASG,GAAcC,GAAwB;AACpD,QAAMC,IAAa,CAACD,MAEd,OAAO,SAAW,MACb,OAAO,WAAWA,CAAK,EAAE,UAE3B,IAGH,CAACE,GAASC,CAAU,IAAIxC,EAAM,SAAkBsC,EAAWD,CAAK,CAAC;AAEvE,WAASI,IAAe;AACtB,IAAAD,EAAWF,EAAWD,CAAK,CAAC;AAAA,EAC9B;AAEA,SAAArC,EAAM,UAAU,MAAM;AACpB,UAAM0C,IAAa,OAAO,WAAWL,CAAK;AAG1C,WAAAI,EAAA,GAGIC,EAAW,cACbA,EAAW,YAAYD,CAAY,IAEnCC,EAAW,iBAAiB,UAAUD,CAAY,GAG7C,MAAM;AACX,MAAIC,EAAW,iBACbA,EAAW,eAAeD,CAAY,IAEtCC,EAAW,oBAAoB,UAAUD,CAAY;AAAA,IAEzD;AAAA,EAEF,GAAG,CAACJ,CAAK,CAAC,GAEHE;AACT;AC9BO,SAASI,GAAiBC,GAG/B;AACA,QAAMC,IAAcC,EAAcF,CAAI,GAChCG,IAAa/C,EAAM,YAAY,YAAY;AAC/C,UAAM6C,EAAY,WAAA;AAAA,EACpB,GAAG,CAACA,CAAW,CAAC,GAEVf,IAAa9B,EAAM;AAAA,IACvB,MAAMgD,GAAmCH,CAAW;AAAA,IACpD,CAACA,CAAW;AAAA,EAAA,GAER,EAAE,cAAAI,EAAA,IAAiBpB,EAAmBC,GAAY;AAAA,IACtD,cAAce,EAAY;AAAA,EAAA,CAC3B;AAED,SAAO,EAAE,cAAAI,GAAc,YAAAF,EAAA;AACzB;ACjCA,SAASG,GAAE,GAAE;AAAC,MAAI,GAAEC,GAAEC,IAAE;AAAG,MAAa,OAAO,KAAjB,YAA8B,OAAO,KAAjB,SAAmB,CAAAA,KAAG;AAAA,WAAoB,OAAO,KAAjB,SAAmB,KAAG,MAAM,QAAQ,CAAC,GAAE;AAAC,QAAI,IAAE,EAAE;AAAO,SAAI,IAAE,GAAE,IAAE,GAAE,IAAI,GAAE,CAAC,MAAID,IAAED,GAAE,EAAE,CAAC,CAAC,OAAKE,MAAIA,KAAG,MAAKA,KAAGD;AAAA,EAAE,MAAM,MAAIA,KAAK,EAAE,GAAEA,CAAC,MAAIC,MAAIA,KAAG,MAAKA,KAAGD;AAAG,SAAOC;AAAC;AAAQ,SAASC,KAAM;AAAC,WAAQ,GAAE,GAAEF,IAAE,GAAEC,IAAE,IAAG,IAAE,UAAU,QAAOD,IAAE,GAAEA,IAAI,EAAC,IAAE,UAAUA,CAAC,OAAK,IAAED,GAAE,CAAC,OAAKE,MAAIA,KAAG,MAAKA,KAAG;AAAG,SAAOA;AAAC;ACkBxW,SAASE,MAASvC,GAA4C;AACnE,SAAO,IAAIwC,MAAgB;AACzB,eAAWpD,KAAYY;AACrB,UAAI,OAAOZ,KAAa;AACtB,YAAI;AACF,UAAAA,EAAS,GAAGoD,CAAI;AAAA,QAClB,SAASC,GAAG;AACV,kBAAQ,MAAMA,CAAC;AAAA,QACjB;AAAA,EAGN;AACF;AAoBO,SAASC,KAAiCF,GAA6C;AAG5F,QAAMG,IAAgB,EAAE,GAAGH,EAAK,CAAC,EAAA;AACjC,WAASpC,IAAI,GAAGA,IAAIoC,EAAK,QAAQpC,KAAK;AACpC,UAAMwC,IAAQJ,EAAKpC,CAAC;AACpB,eAAWyC,KAAOD,GAAO;AACvB,YAAME,IAAIH,EAAOE,CAAG,GACdE,IAAIH,EAAMC,CAAG;AAGnB,MACE,OAAOC,KAAM,cACb,OAAOC,KAAM;AAAA,MAEbF,EAAI,CAAC,MAAM,OACXA,EAAI,CAAC,MAAM,OACXA,EAAI,WAAW,CAAC;AAAA,MAAe,MAC/BA,EAAI,WAAW,CAAC;AAAA,MAAe,KAE/BF,EAAOE,CAAG,IAAIN,GAAMO,GAAGC,CAAC,KAIvBF,MAAQ,eAAeA,MAAQ,uBAChC,OAAOC,KAAM,YACb,OAAOC,KAAM,WAEbJ,EAAOE,CAAG,IAAIP,GAAKQ,GAAGC,CAAC,IAEvBJ,EAAOE,CAAG,IAAIE,MAAM,SAAYA,IAAID;AAAA,IAExC;AAAA,EACF;AAEA,SAAOH;AACT;AC1EO,SAASK,GAAkBJ,GAA4B;AAC5D,QAAM,EAAE,OAAA1B,GAAO,UAAA+B,MAAaC,KAAmB;AAc/C,SAAO,EAAE,aAZWjE,EAAM,QAAQ,MAAM;AACtC,UAAM,EAAE,WAAAkE,EAAA,IAAcC,GAAA;AAQtB,WAPoBV,EAAWE,GAAO;AAAA,MACpC,WAAAO;AAAA,MACA,UAAU,EAACjC,KAAA,QAAAA,EAAO;AAAA,MAClB,SAAS,MAAM;AACb,QAAI+B,KAAUA,EAAS,EAAE,KAAK,aAAa;AAAA,MAC7C;AAAA,IAAA,CACD;AAAA,EAEH,GAAG,CAACL,GAAOK,GAAU/B,CAAK,CAAC,EAElB;AACX;ACPO,SAASmC,GAA8BC,IAA6C,IAAI;AAC7F,QAAMC,IAAIC,EAAqBF,EAAQ,WAAW,GAE5C,EAAE,WAAAH,GAAW,2BAAAM,EAAA,IAA8BxE,EAAM;AAAA,IACrD,MAAMyE,GAAgCH,CAAC;AAAA,IACvC,CAACA,CAAC;AAAA,EAAA,GAGEI,IAAU7C,EAAmB2C,GAA2BF,EAAE,iBAAiB;AAEjF,SAAO,EAAE,WAAAJ,GAAW,SAAAQ,EAAA;AACtB;ACjBO,SAASC,GAAmB/B,GAAa;AAE9C,QAAMM,IAAIJ,EAAcF,CAAI,GACtBd,IAAa9B,EAAM,QAAQ,MAAM4E,GAAwB1B,CAAC,GAAG,CAACA,CAAC,CAAC;AAEtE,SADwBrB,EAAmBC,GAAYoB,EAAE,KAAK;AAEhE;AC8BO,SAAS2B,GACdC,GACA3E,GACA;AACA,QAAM4E,IAAY,OAAOD,KAAoB,aAAaA,IAAkB3E,GAEtE6E,IAAQ,OAAOF,KAAoB,WAAWA,IAAkB,QAChElC,IAAOqC,GAAA,GACP,EAAE,MAAAC,GAAM,mBAAAC,GAAmB,qBAAAC,EAAA,IAAwBpF,EAAM;AAAA,IAC7D,MAAMqF,GAAwBzC,GAAMoC,GAAOD,CAAS;AAAA,IACpD,CAACnC,GAAMoC,GAAOD,CAAS;AAAA,EAAA,GAGnBO,IAAUzD,EAAmBsD,GAAmB,MAAS,GACzDI,IAAY1D,EAAmBuD,GAAqB,EAAK;AAE/D,SAAO;AAAA,IACL,SAAAE;AAAA,IACA,MAAAJ;AAAA,IACA,WAAAK;AAAA,EAAA;AAEJ;ACpDO,SAASC,GAAoB7B,GAA8B;AAChE,QAAMf,IAAOqC,GAAA,GACPQ,IAAkBd,GAAmB/B,CAAI;AAY/C,SAAO,EAAE,aAVW5C,EAAM,QAAQ,MAAM;AACtC,UAAM,EAAE,WAAAkE,GAAW,YAAAwB,MAAeC,GAAsB/C,CAAI;AAM5D,WALoBa,EAAWE,GAAO;AAAA,MACpC,WAAAO;AAAA,MACA,SAAS,MAAMwB,EAAW/B,EAAM,cAAc,EAAI;AAAA,MAClD,UAAU8B,MAAoBG,EAAgB;AAAA,IAAA,CAC/C;AAAA,EAEH,GAAG,CAAChD,GAAMe,GAAO8B,CAAe,CAAC,EAExB;AACX;ACzBO,SAASI,GACdC,GACyD;AACzD,MAAIA,EAAe,uBAAuBC,IAAuB;AAC/D,UAAMC,IAAaF,EAAe,YAAY;AAC9C,QAAIE,GAAY;AACd,YAAM,EAAE,YAAAC,EAAA,IAAeC,GAAyBF,CAAU;AAC1D,aAAOC;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;ACEO,SAASE,GAAe,EAAE,UAAAC,GAAU,OAAAzC,KAA8B;AACvE,QAAMmC,IAAiBO,GAAkBD,CAAQ,GAE3CE,IAAgBC,GAAA,GAChB,EAAE,WAAArC,MAAclE,EAAM,QAAQ,MAAMwG,GAAA,GAAoB,EAAE,GAE1DC,IAAmBzG,EAAM,QAAQ,MAC9B0G,GAAuBZ,GAAgBQ,KAAA,gBAAAA,EAAe,IAAI,KAAK,GACrE,CAACR,GAAgBQ,KAAA,gBAAAA,EAAe,IAAI,KAAK,CAAC;AA0B7C,SAAO,EAAE,aAxBWtG,EAAM;AAAA,IACxB,MACEyD,EAAWE,GAAO;AAAA,MAChB,WAAAO;AAAA,MACA,SAAS,CAACyC,MAA2D;;AAEnE,SAAAC,IAAAjD,EAAM,YAAN,QAAAiD,EAAA,KAAAjD,GAAgBgD,IAGZF,KACFI,IAAAP,KAAA,iBAAAQ,IAAAR,EAAe,KAAI,aAAnB,QAAAO,EAAA,KAAAC,GAA8B;AAAA,UAC5B,KAAK;AAAA,QAAA,MAGPC,IAAAT,KAAA,iBAAAU,IAAAV,EAAe,KAAI,aAAnB,QAAAS,EAAA,KAAAC,GAA8B;AAAA,UAC5B,KAAK;AAAA,UACL,gBAAAlB;AAAA,QAAA;AAAA,MAGN;AAAA,IAAA,CACD;AAAA,IACH,CAACnC,GAAOO,GAAW4B,GAAgBW,GAASH,KAAA,gBAAAA,EAAe,GAAG;AAAA,EAAA,GAG1C,SAAAG,EAAA;AACxB;ACxCO,SAASQ,GAEdC,GAEAC,GACA9C,IAEI,CAAA,GACyE;AAC7E,QAAM+C,IAAc/C,EAAQ,eAAegD,IACrC,EAAE,OAAA3F,GAAO,QAAAC,MAAWJ,GAAQ2F,CAAW,GACvCI,IAASC,GAAiBH,GAAaD,GAAYzF,GAAOC,CAAM;AAEtE,SAAA3B,EAAM,UAAU,MAAM;AACpB,IAAIkH,EAAY,WAAWI,MACzBJ,EAAY,QAAQ,MAAM,YAAY,kBAAkBI,KAAA,gBAAAA,EAAQ,QAAQ,UAAU,GAClFJ,EAAY,QAAQ,MAAM,YAAY,kBAAkBI,KAAA,gBAAAA,EAAQ,KAAK,UAAU;AAAA,EAEnF,GAAG,CAACJ,GAAaI,CAAM,CAAC,GAEjB;AAAA,IACL,QAAAA;AAAA,IACA,gBAAgB5F;AAAA,IAChB,iBAAiBC;AAAA,EAAA;AAErB;ACRO,SAAS6F,GACdC,GACApD,IAA6B,IAC7B;;AACA,QAAMqD,IACJ,OAAOD,KAAqB,WAAWpD,EAAQ,cAAcoD,EAAiB,aAC1EnD,IAAIC,EAAqBmD,CAAiB,GAC1CC,IACJ,OAAOF,KAAqB,WACxB,EAAE,aAAanD,GAAG,QAAQmD,EAAA,IAC1BA,GACA,CAACG,GAASC,CAAU,IAAI7H,EAAM;AAAA,IAClC,CAAC,GAAE4G,IAAAe,EAAI,gBAAJ,QAAAf,EAAiB,YAAWE,IAAAxC,EAAE,oBAAoBqD,EAAI,MAAM,MAAhC,QAAAb,EAAmC;AAAA,EAAA;AAGpE,SAAA9G,EAAM,UAAU,MAAM;AACpB,UAAM8H,IAAWC,GAAcJ,CAAG,EAAE,UAAUE,CAAU;AACxD,WAAO,MAAMC,EAAS,YAAA;AAAA,EACxB,GAAG,CAACE,GAAoBL,CAAG,CAAC,CAAC,GAEtBC;AACT;AC1CO,SAASK,GAAcC,GAA2B;AACvD,QAAM5D,IAAIC,EAAqB2D,CAAW,GACpCpG,IAAa9B,EAAM,QAAQ,MAAMmI,GAAyB7D,CAAC,GAAG,CAACA,CAAC,CAAC;AAGvE,SAFmBzC,EAAmBC,GAAYwC,EAAE,UAAU;AAGhE;ACdO,SAAS8D,GACdC,GACW;AACX,SAAOA,MAAS;AAClB;AAGO,SAAS5E,MAGXE,GAAU;AACb,SAAO2E,EAAoB,GAAG3E,EAAM,OAAOyE,EAAM,CAAC;AACpD;AAGO,SAASG,GACdC,GACA7E,GACAC,GACA;AACA,SAAO5D,EAAM,SAAS,IAAIwI,GAAU,CAACC,MAG/BzI,EAAM,eAAeyI,CAAK,KAAKzI,EAAM,SAAS,KAAKwI,CAAQ,KACzDC,EAAM,MAAM,cAEd9E,UAAU,CAAA,IACVA,EAAM,YAAYN,GAAKoF,EAAM,MAAM,WAAW9E,EAAM,SAAS,GAC7DA,EAAM,QAAQ,EAAE,GAAG8E,EAAM,MAAM,OAAO,GAAG9E,EAAM,MAAA,IAE1C3D,EAAM,aAAayI,GAAO,EAAE,GAAG9E,GAAO,KAAAC,GAAK,KAE7C6E,CACR;AACH;AAKO,SAASC,GAAuBC,GAAkB;;AACvD,MACE,OAAO,SAAW,OAClB,OAAO,UAAY;AAAA,KAElB/B,IAAA,mCAAS,QAAT,gBAAAA,EAAc,cAAa;AAAA,IAE1BE,IAAA,mCAAS,QAAT,gBAAAA,EAAc,cAAa,gBAC7B;AACA,UAAM5G,IAAe,SAAS,cAAc,oBAAoB;AAChE,IAAIA,KAAU,CAAC,iBAAiBA,CAAM,EAAE,iBAAiB,0BAA0B,KACjF0I,EAAI;AAAA,MACF;AAAA,IAAA;AAAA,EAGN;AACF;AAQO,SAASC,GAA6BjF,GAAakF,GAAc;AACtE,SAAIlF,MAAQ,eAAekF,KAAO,OAAOA,KAAQ,YAAY,UAAUA,IAC9DA,EAAI,OAETlF,MAAQ,UAAUkF,IACb,iBAEFA;AACT;ACnEA,MAAMC,KAA8C;AAAA,EAClD,SAAS;AAAA,EACT,OAAO;AAAA,EACP,OAAO;AACT;AAaO,SAASC,GACdrF,GAIA;AACA,QAAM;AAAA,IACJ,OAAAsF;AAAA,IACA,WAAAC;AAAA,IACA,SAAA7E;AAAA,IACA,MAAM8E;AAAA,IACN,gBAAAC;AAAA,IACA,SAAAC;AAAA,IACA,OAAAC;AAAA,IACA,OAAAC;AAAA,IACA,QAAAC;AAAA,IACA,aAAAC;AAAA,IACA,gBAAAC;AAAA,IACA,SAAAC;AAAA,IACA,sBAAAC;AAAA,IACA,mBAAAC;AAAA,IACA,sBAAAC;AAAA,IACA,GAAGC;AAAA,EAAA,IACD,EAAE,GAAGhB,IAAkB,GAAGpF,EAAA;AAC9B,EAAIU,KAAW8E,KACbP,EAAI;AAAA,IACF;AAAA,EAAA;AAIJ,QAAM,CAAChG,GAAMoH,CAAO,IAAIhK,EAAM,SAAA,GAExBiK,IAAgBjK,EAAM,OAAOqJ,CAAO;AAE1C,EAAArJ,EAAM,UAAU,MAAM;AACpB,IAAAgK,EAAQb,KAAc,IAAIe,GAAK7F,CAAO,CAAC;AAAA,EACzC,GAAG,CAAC8E,GAAY,KAAK,UAAU9E,GAASwE,EAA4B,CAAC,CAAC;AAEtE,QAAMsB,IAAYnK,EAAM,QAAQ,MAAM;AACpC,UAAM,EAAE,WAAAkE,EAAA,IAAckG,GAAA;AACtB,WAAO3G,EAAWsG,GAAM,EAAE,WAAA7F,GAAW;AAAA,EACvC,GAAG,CAAC6F,CAAI,CAAC;AAET,SAAA/J,EAAM,UAAU,MAAM;AACpB,QAAI,CAAC4C,EAAM;AACX,UAAMyH,IAAoB,MAAM;AAC9B,YAAMC,IAAS1H,EAAK;AAEpB,MAAAgG,EAAI,MAAM,gCAAgC,GAC1C,QAAQ,IAAI;AAAA,QACV0B,EAAO,qBAAqB,CAAC,CAAChB,GAAO,OAAOA,KAAU,YAAYA,IAAQ,MAAS;AAAA,QACnFgB,EAAO,iBAAiB,CAAC,CAACf,GAAO,OAAOA,KAAU,YAAYA,IAAQ,MAAS;AAAA,QAC/Ee,EAAO,sBAAsB,CAAC,CAACd,GAAQ,OAAOA,KAAW,YAAYA,IAAS,MAAS;AAAA,MAAA,CACxF,EAAE,MAAM,CAAChG,MAAM;AACd,QAAAoF,EAAI,KAAKpF,CAAC,GACVmG,KAAA,QAAAA,EAAUnG;AAAA,MACZ,CAAC;AAAA,IACH,GAEM+G,IAAyB,CAAC/G,GAAUgH,MAA2B;AACnE,YAAMC,IAAqBC,GAAmB,WAAWlH,CAAC;AAC1D,MAAAoG,KAAA,QAAAA,EAAuBa,GAAoBD;AAAA,IAC7C,GACMG,IAAwB,CAACnH,MAAa;AAC1C,MAAAqG,KAAA,QAAAA,EAAoBrG;AAAA,IACtB,GACMoH,IAAqB,CAACC,MAA8B;AACxD,MAAAnB,KAAA,QAAAA,EAAiBmB;AAAA,IACnB,GACMC,IAAkB,MAAM;AAC5B,MAAArB,KAAA,QAAAA;AAAA,IACF;AAEA,WAAA7G,EACG,GAAGmI,EAAU,iBAAiBV,CAAiB,EAC/C,GAAGU,EAAU,mBAAmBR,CAAsB,EACtD,GAAGQ,EAAU,iBAAiBJ,CAAqB,EACnD,GAAGI,EAAU,cAAcH,CAAkB,EAC7C,GAAGG,EAAU,WAAWD,CAAe,GAEnC,MAAM;AACX,MAAAlI,EACG,IAAImI,EAAU,iBAAiBV,CAAiB,EAChD,IAAIU,EAAU,mBAAmBR,CAAsB,EACvD,IAAIQ,EAAU,iBAAiBJ,CAAqB,EACpD,IAAII,EAAU,cAAcH,CAAkB,EAC9C,IAAIG,EAAU,WAAWD,CAAe;AAAA,IAC7C;AAAA,EACF,GAAG;AAAA,IACDlI;AAAA,IACA0G;AAAA,IACAC;AAAA,IACAC;AAAA,IACAG;AAAA,IACAE;AAAA,IACAD;AAAA,IACAH;AAAA,IACAC;AAAA,EAAA,CACD,GAED1J,EAAM,UAAU,MAAM;AACpB,QAAK4C,GAEL;AAAA,UAAIkH,GAAsB;AACxB,QAAAlH,EAAK,qBAAqB;AAAA,UACxB,cAAc;AAAA,YACZ,OAAOkH;AAAA,UAAA;AAAA,UAET,SAAS;AAAA,YACP,OAAO;AAAA,YACP,eAAe;AAAA,UAAA;AAAA,QACjB,CACD;AACD;AAAA,MACF;AAEA,UAAIT,GAAS;AAGX,YAFAY,EAAc,UAAU,IACxBrB,EAAI,MAAM,YAAY,GAClB,CAACK,GAAO;AACV,UAAAL,EAAI,MAAM,cAAc;AACxB;AAAA,QACF;AACA,YAAI,CAACM,GAAW;AACd,UAAAN,EAAI,KAAK,yBAAyB,GAClCe,KAAA,QAAAA,EAAU,MAAM,yBAAyB;AACzC;AAAA,QACF;AACA,QAAA/G,EAAK,QAAQsG,GAAWD,GAAOG,CAAc,EAAE,MAAM,CAAC5F,MAAM;AAC1D,UAAAoF,EAAI,KAAKpF,CAAC,GACNyG,EAAc,YAAY,OAC5BN,KAAA,QAAAA,EAAUnG;AAAA,QAEd,CAAC;AAAA,MACH;AACE,QAAAoF,EAAI,MAAM,wCAAwC,GAClDqB,EAAc,UAAU,IACxBrH,EAAK,WAAA;AAAA;AAAA,EAET,GAAG;AAAA,IACDyG;AAAA,IACAJ;AAAA,IACA,KAAK,UAAUG,CAAc;AAAA,IAC7BxG;AAAA,IACA+G;AAAA,IACAT;AAAA,IACAY;AAAA,EAAA,CACD,GAED9J,EAAM,UAAU,MAAM;AACpB,QAAK4C;AACL,aAAO,MAAM;AACX,QAAAgG,EAAI,KAAK,0BAA0B,GACnChG,EAAK,WAAA;AAAA,MACP;AAAA,EACF,GAAG,CAACA,CAAI,CAAC,GAEF,EAAE,MAAAA,GAAM,WAAAuH,EAAA;AACjB;ACjKO,SAASa,GAAoB3G,IAAsC,IAAI;AAC5E,QAAMzB,IAAOE,EAAcuB,EAAQ,IAAI,GACjC,CAAC4G,GAAkBC,CAAmB,IAAIlL,EAAM,SAAS4C,EAAK,gBAAgB,GAE9E,CAACuI,GAAqBC,CAAsB,IAAIpL,EAAM;AAAA,IAC1DiL,EAAiB;AAAA,EAAA,GAEb,CAACI,GAAiBC,CAAkB,IAAItL,EAAM,SAASiL,EAAiB,eAAe,GACvF,CAACM,GAAsBC,CAAuB,IAAIxL,EAAM;AAAA,IAC5DiL,EAAiB;AAAA,EAAA,GAGb,CAACQ,GAAqBC,CAAsB,IAAI1L,EAAM;AAAA,IAC1DiL,EAAiB;AAAA,EAAA,GAEb,CAACU,GAAiBC,CAAkB,IAAI5L,EAAM,SAASiL,EAAiB,eAAe,GAEvF,CAACY,GAAiBC,CAAkB,IAAI9L,EAAM;AAAA,IAClD;AAAA,EAAA,GAEI,CAAC+L,GAAaC,CAAc,IAAIhM,EAAM,SAAuC,MAAS,GAEtFiM,IAAe,CAACC,MAA8C;AAClE,IAAAZ,EAAmBY,EAAM,eAAe,GACxCd,EAAuBc,EAAM,mBAAmB,GAChDV,EAAwBU,EAAM,oBAAoB,GAClDF,EAAeE,EAAM,WAAW,GAChCJ,EAAmBI,EAAM,eAAe,GACxCR,EAAuBQ,EAAM,YAAY,mBAAmB,GAC5DN,EAAmBM,EAAM,YAAY,eAAe,GACpDhB,EAAoBgB,EAAM,WAAW;AAAA,EACvC;AACA,SAAAlM,EAAM,UAAU,MAAM;AACpB,UAAM8H,IAAWqE,GAAwBvJ,EAAK,gBAAgB,EAAE,UAAUqJ,CAAY;AAEtF,WAAO,MAAMnE,EAAS,YAAA;AAAA,EACxB,GAAG,CAAClF,CAAI,CAAC,GAEF;AAAA,IACL,qBAAAuI;AAAA,IACA,sBAAAI;AAAA,IACA,iBAAAF;AAAA,IACA,iBAAAQ;AAAA,IACA,aAAAE;AAAA,IACA,qBAAAN;AAAA,IACA,iBAAAE;AAAA,IACA,kBAAAV;AAAA,EAAA;AAEJ;ACzDO,SAASmB,KAAoE;AAClF,QAAMxJ,IAAOqC,GAAA,GACPoH,IAAqBrM,EAAM;AAAA,IAC/B,MAAMsM,GAA8B1J,EAAK,gBAAgB;AAAA,IACzD,CAACA,CAAI;AAAA,EAAA;AAGP,SADoBf,EAAmBwK,GAAoBzJ,EAAK,iBAAiB,WAAW;AAE9F;ACiBO,SAAS2J,GAAqB;AAAA,EACnC,MAAA/B;AAAA,EACA,MAAA5H;AAAA,EACA,OAAA4J;AAAA,EACA,oBAAAC;AAAA,EACA,SAAA9C;AACF,GAA8B;AAC5B,QAAM+C,IAAcC,GAAA,GAEdC,IAAe5M,EAAM,QAAQ,MAAM4C,KAAQ8J,KAAe,IAAIxC,GAAA,GAAQ,CAACtH,GAAM8J,CAAW,CAAC,GAGzFG,IAAiB7M,EAAM;AAAA,IAC3B,MAAM8M,GAA0BtC,GAAMb,GAAS8C,CAAkB;AAAA,IACjE,CAACjC,GAAMiC,GAAoB9C,CAAO;AAAA,EAAA,GAE9BoD,IAAUlL,EAAmBgL,GAAgB,EAAuB,GAEpE,CAACG,GAAiBC,CAAkB,IAAIjN,EAAM;AAAA,KAClD4M,KAAA,gBAAAA,EAAc,gBAAgBpC,OAAS;AAAA,EAAA,GAEnC,EAAE,WAAAtG,GAAW,wBAAAgJ,GAAwB,sBAAAC,EAAA,IAAyBnN,EAAM;AAAA,IACxE,MAAMoN,GAAoB5C,GAAMoC,CAAY;AAAA,IAC5C,CAACpC,GAAMoC,GAAcJ,CAAK;AAAA,EAAA;AAG5B,SAAAxM,EAAM,UAAU,MAAM;AACpB,UAAM8H,IAAWoF,EAAuB,UAAU,CAACG,MAAa;AAC9D,MAAKA,MAGLzE,EAAI,KAAK,sBAAsByE,CAAQ,GACvCJ,EAAmBI,CAAQ;AAAA,IAC7B,CAAC;AACD,WAAO,MAAM;AACX,MAAAvF,KAAA,QAAAA,EAAU;AAAA,IACZ;AAAA,EACF,GAAG,CAACoF,CAAsB,CAAC,GAEpB,EAAE,SAAAH,GAAS,WAAA7I,GAAW,gBAAgB8I,GAAiB,sBAAAG,EAAA;AAChE;AClEO,SAASG,GAAgB;AAAA,EAC9B,MAAA9C;AAAA,EACA,SAAAb;AACF,GAGG;AACD,QAAMkD,IAAiB7M,EAAM;AAAA,IAC3B,MAAM8M,GAA0BtC,GAAMb,CAAO;AAAA,IAC7C,CAACa,GAAMb,CAAO;AAAA,EAAA;AAGhB,SADgB9H,EAAmBgL,GAAgB,EAAuB;AAE5E;ACEO,SAASU,GAEdC,GACAC,GACApJ,IAAwC,CAAA,GACT;AAC/B,QAAMqJ,IAAgB1N,EAAM,OAAsC,EAAE,GAC9D2N,IAAqB3N,EAAM,OAAe,EAAE,GAC5C4N,IAAgBH,MAAmBE,EAAmB,SAEtDE,IACJ,OAAOxJ,EAAQ,sBAAuB,aAClCA,EAAQ,mBAAmBmJ,CAAe,IAC1CM,GAAoBN,CAAe;AAEzC,MAAIO,IAAkD,CAAC,GAAGF,CAAe;AACzE,MAAID,MAAkB;AACpB,QAAI;AACF,MAAAG,IAAmBC,GAAYN,EAAc,SAASG,GAAiBJ,CAAc;AAAA,IACvF,SAASQ,GAAO;AACd,MAAArF,EAAI,MAAM,uCAAuCqF,CAAK;AAAA,IACxD;AAIF,SAAIL,IACFF,EAAc,UAAUG,IAExBH,EAAc,UAAUK,GAE1BJ,EAAmB,UAAUF,GAEtBM;AACT;AC/CO,SAASG,GAAcC,GAAqBX,GAAgD;AACjG,QAAM,CAACY,GAAaC,CAAc,IAAIrO,EAAM,SAAS,CAAC,GAChDsO,IAAiB,KAAK,IAAI,KAAK,KAAKd,EAAgB,SAASW,CAAW,GAAG,CAAC;AAClF,EAAIC,IAAcE,KAChBD,EAAeC,CAAc;AAE/B,QAAMC,IAAgBH,IAAcD,GAC9BK,IAAiBD,IAAgBJ,GAEjCM,IAAa,CAACC,MAAmC;AACrD,IAAAL,EAAe,CAACpM,MACVyM,MAAc,SACZzM,MAAUqM,IACLrM,IAEFA,IAAQ,IAEXA,MAAU,IACLA,IAEFA,IAAQ,CAElB;AAAA,EACH,GAEM0M,IAAW,CAACC,MAAgB;AAChC,IAAIA,IAAMN,IACRD,EAAeC,CAAc,IACpBM,IAAM,IACfP,EAAe,CAAC,IAEhBA,EAAeO,CAAG;AAAA,EAEtB,GAIMC,IAFyBtB,GAAsBC,GAAiBW,CAAW,EAErC,MAAMK,GAAgBD,CAAa;AAE/E,SAAO;AAAA,IACL,gBAAAD;AAAA,IACA,UAAU,MAAMG,EAAW,MAAM;AAAA,IACjC,UAAU,MAAMA,EAAW,UAAU;AAAA,IACrC,SAASE;AAAA,IACT,gBAAAH;AAAA,IACA,eAAAD;AAAA,IACA,QAAQM;AAAA,IACR,aAAAT;AAAA,EAAA;AAEJ;AC3CO,SAASU,GAAmBnL,IAAmC,IAAI;AACxE,MAAIW,IAAIyK,GAAA;AACR,EAAIpL,EAAM,gBACRW,IAAIX,EAAM;AAEZ,QAAMqL,IAAehP,EAAM,QAAQ,MAAMiP,GAAwB3K,CAAC,GAAG,CAACA,CAAC,CAAC,GAClE,EAAE,UAAA4K,GAAU,MAAAC,GAAM,UAAAC,EAAA,IAAavN,EAAmBmN,GAAc;AAAA,IACpE,MAAM1K,KAAA,gBAAAA,EAAG;AAAA,IACT,UAAUA,KAAA,gBAAAA,EAAG;AAAA,IACb,UAAUA,KAAA,gBAAAA,EAAG;AAAA,EAAA,CACd;AAED,SAAO,EAAE,UAAA4K,GAAU,MAAAC,GAAM,UAAAC,EAAA;AAC3B;ACbO,SAASC,GACdhL,IAA4C,IACT;AACnC,QAAMC,IAAIC,EAAqBF,EAAQ,WAAW,GAC5CgI,IAAqBrM,EAAM,QAAQ,MAAMsM,GAA8BhI,CAAC,GAAG,CAACA,CAAC,CAAC;AAEpF,SADoBzC,EAAmBwK,GAAoB/H,EAAE,WAAW;AAE1E;ACDO,SAASgL,GAA0C;AAAA,EACxD,UAAAlJ;AAAA,EACA,oBAAAmJ;AAAA,EACA,0BAAAC;AAAA,EACA,WAAArF;AACF,GAA+B;AAC7B,QAAMrE,IAAiBO,GAAkBD,CAAQ,GAE3CqJ,IAAczP,EAAM,QAAQ,MAAM;AACtC,UAAM,EAAE,WAAAkE,EAAA,IAAcwL,GAAA;AACtB,WAAOjM,EAAW0G,GAAW;AAAA,MAC3B,WAAAjG;AAAA,MACA,SAAS,CAACyC,MAA2C;;AAEnD,aADAC,IAAAuD,EAAU,YAAV,QAAAvD,EAAA,KAAAuD,GAAoBxD,IAChB,OAAO4I,KAAuB,YAAY;AAC5C,gBAAM/C,IACJ1G,EAAe,eACfA,EAAe,YAAY,oBAAoBA,EAAe,MAAM;AACtE,UAAAyJ,EAAmB,EAAE,aAAazJ,EAAe,aAAa,OAAA0G,GAAO;AAAA,QACvE;AAAA,MACF;AAAA,IAAA,CACD;AAAA,EACH,GAAG;AAAA,IACDrC;AAAA,IACAoF;AAAA,IACAzJ,EAAe;AAAA,IACfA,EAAe;AAAA,IACfA,EAAe;AAAA,EAAA,CAChB,GAEK6J,IAAW7J,EAAe,YAAY,oBAAoB8J,EAAM,OAAO,UAAU,GACjFC,IAAS7P,EAAM,QAAQ,OACpB;AAAA,IACL,aAAa8F,EAAe;AAAA,IAC5B,QAAQ8J,EAAM,OAAO;AAAA,IACrB,aAAaD;AAAA,EAAA,IAEd,CAACA,GAAU7J,EAAe,WAAW,CAAC,GACnCgK,IAAetI,GAAW1B,CAAc,GACxCiK,IAAevI,GAAWqI,CAAM,GAChCG,IAAa/H,GAAcnC,EAAe,WAAW,GACrDG,IAAaJ,GAAcC,CAAc;AAC/C,SAAO;AAAA,IACL,cAAc;AAAA,MACZ,uBAAuBiK;AAAA,MACvB,uBAAuBD;AAAA,MACvB,oBAAoBN,MAA6B,KAAO,KAAQQ;AAAA,MAChE,6BAA6BlK,EAAe,YAAY;AAAA,MACxD,kBAAkBA,EAAe;AAAA,MACjC,uBAAuBG;AAAA,MACvB,GAAGwJ;AAAA,IAAA;AAAA,EACL;AAEJ;AC/CO,SAASQ,GAAsB5L,IAAwC,IAAI;AAChF,QAAMzB,IAAOE,EAAcuB,EAAQ,IAAI,GACjC,CAAC6L,GAAcC,CAAe,IAAInQ,EAAM,SAA8B,CAAA,CAAE;AAE9E,SAAAA,EAAM,UAAU,MAAM;AACpB,UAAM8H,IAAWsI,GAA8BxN,GAAM;AAAA,MACnD,sBAAsByB,EAAQ;AAAA,IAAA,CAC/B,EAAE,UAAU8L,CAAe;AAC5B,WAAO,MAAMrI,EAAS,YAAA;AAAA,EACxB,GAAG,CAAClF,GAAM,KAAK,UAAUyB,EAAQ,YAAY,CAAC,CAAC,GACxC6L;AACT;ACXO,SAASG,GAAgBhM,IAAkC,IAAI;AACpE,QAAMiM,IAAqBL,GAAsB5L,CAAO,GAClD,EAAE,kBAAA4G,EAAA,IAAqBD,GAAoB3G,CAAO;AAExD,SAAOrE,EAAM;AAAA,IACX,MAAM,CAACiL,GAAkB,GAAGqF,CAAkB;AAAA,IAC9C,CAACrF,GAAkBqF,CAAkB;AAAA,EAAA;AAEzC;AC1BO,SAASC,GAAgBjK,GAAkE;AAChG,SAAAA,IAAgBkK,GAAuBlK,CAAa,GAC7CtG,EAAM,QAAQ,OACfsG,KAAA,gBAAAA,EAAe,IAAI,WAAU,UAAaA,EAAc,IAAI,MAAM,UAAU,IACvEA,EAAc,IAAI,QAEpB,CAAA,GACN,CAACA,EAAc,IAAI,KAAK,CAAC;AAC9B;ACyBO,SAASmK,GACdC,GACArM,IAAuC,IACR;AAC/B,QAAMzB,IAAOqC,GAAA,GACP,CAAC0L,CAAY,IAAI3Q,EAAM,SAASqE,EAAQ,YAAY,GAEpDvC,IAAa9B,EAAM,QAAQ,MAC3B,OAAO0Q,KAAyB,WAC3BE,GAA6BhO,GAAM8N,GAAsB;AAAA,IAC9D,kBAAkBC;AAAA,EAAA,CACnB,IAEME,GAAgCjO,GAAM8N,GAAsB;AAAA,IACjE,kBAAkBC;AAAA,EAAA,CACnB,GAEF,CAAC/N,GAAM,KAAK,UAAU8N,CAAoB,GAAGC,CAAY,CAAC,GAIvD,CAACG,GAAoBC,CAAqB,IAAI/Q,EAAM,SAAS;AAAA,IACjE,GAAG;AAAA,EAAA,CACJ;AACD,SAAAA,EAAM,UAAU,MAAM;AACpB,UAAM8H,IAAWhG,EAAW,UAAU,CAACwC,MAAMyM,EAAsB,EAAE,GAAAzM,EAAA,CAAG,CAAC;AACzE,WAAO,MAAMwD,EAAS,YAAA;AAAA,EACxB,GAAG,CAAChG,CAAU,CAAC,GAERgP,EAAmB;AAC5B;ACxDO,SAASE,GAAY3M,IAA8B,IAAI;AAC5D,QAAMzB,IAAOE,EAAcuB,EAAQ,IAAI,GACjC2K,IAAehP,EAAM,QAAQ,MAAMiR,GAAiBrO,CAAI,GAAG,CAACA,CAAI,CAAC,GACjE,EAAE,MAAAuM,GAAM,UAAAC,MAAavN,EAAmBmN,GAAc;AAAA,IAC1D,MAAMpM,EAAK;AAAA,IACX,UAAUA,EAAK;AAAA,EAAA,CAChB;AAED,SAAO,EAAE,MAAAuM,GAAM,UAAAC,EAAA;AACjB;ACXO,SAAS8B,GAAwB7M,GAA0C;AAChF,QAAM8M,IAAcrO,EAAcuB,KAAA,gBAAAA,EAAS,IAAI,GAEzC+M,IAAkBpR,EAAM,QAAQ,MAAMqR,GAAsBF,CAAW,GAAG,CAACA,CAAW,CAAC;AAE7F,SADuBtP,EAAmBuP,GAAiBD,EAAY,cAAc;AAEvF;ACjBO,SAASG,GAAsBpB,GAAkC;AACtE,QAAM,CAACqB,GAAoBC,CAAqB,IAAIxR,EAAM;AAAA,IACxDyR,GAAiBvB,CAAY;AAAA,EAAA,GAEzBwB,IAAiBR,GAAA;AAEvB,SAAAlR,EAAM,UAAU,MAAM;AACpB,IAAAwR,EAAsBC,GAAiBvB,CAAY,CAAC;AAAA,EACtD,GAAG,CAACwB,GAAgBxB,CAAY,CAAC,GAC1BqB;AACT;ACGO,SAASI,GAAc,EAAE,MAAA/O,GAAM,OAAAe,KAA6B;AACjE,QAAMd,IAAcC,EAAcF,CAAI,GAChC,EAAE,WAAAsB,GAAW,oCAAAlB,GAAoC,0BAAA4O,EAAA,IAA6B5R,EAAM;AAAA,IACxF,MAAM6R,GAAA;AAAA,IACN,CAAA;AAAA,EAAC,GAEG/P,IAAa9B,EAAM;AAAA,IACvB,MAAMgD,EAAmCH,CAAW;AAAA,IACpD,CAACA,GAAaG,CAAkC;AAAA,EAAA,GAE5C,EAAE,cAAAC,EAAA,IAAiBpB,EAAmBC,GAAY;AAAA,IACtD,cAAce,EAAY;AAAA,EAAA,CAC3B;AAcD,SAAO,EAAE,aAZW7C,EAAM;AAAA,IACxB,MACEyD,EAAWE,GAAO;AAAA,MAChB,WAAAO;AAAA,MACA,SAAS,MAAM;AACb,QAAA0N,EAAyB/O,CAAW;AAAA,MACtC;AAAA,MACA,OAAO,EAAE,SAASI,IAAe,SAAS,QAAA;AAAA,IAAQ,CACnD;AAAA,IACH,CAACU,GAAOO,GAAWjB,GAAc2O,GAA0B/O,CAAW;AAAA,EAAA,GAGlD,cAAAI,EAAA;AACxB;AC5BO,SAAS6O,GAAc,EAAE,MAAAlP,GAAM,OAAAe,KAA6B;AACjE,QAAMd,IAAcC,EAAcF,CAAI,GAChC,EAAE,WAAAsB,GAAW,oCAAA6N,GAAoC,0BAAAC,EAAA,IAA6BhS,EAAM;AAAA,IACxF,MAAMiS,GAAA;AAAA,IACN,CAAA;AAAA,EAAC,GAEGnQ,IAAa9B,EAAM;AAAA,IACvB,MAAM+R,EAAmClP,CAAW;AAAA,IACpD,CAACA,GAAakP,CAAkC;AAAA,EAAA,GAE5C,EAAE,cAAAG,EAAA,IAAiBrQ,EAAmBC,GAAY;AAAA,IACtD,cAAce,EAAY;AAAA,EAAA,CAC3B;AAcD,SAAO,EAAE,aAZW7C,EAAM;AAAA,IACxB,MACEyD,EAAWE,GAAO;AAAA,MAChB,WAAAO;AAAA,MACA,SAAS,MAAM;AACb,QAAA8N,EAAyBnP,CAAW;AAAA,MACtC;AAAA,MACA,OAAO,EAAE,SAASqP,IAAe,SAAS,QAAA;AAAA,IAAQ,CACnD;AAAA,IACH,CAACvO,GAAOO,GAAWgO,GAAcF,GAA0BnP,CAAW;AAAA,EAAA,GAGlD,cAAAqP,EAAA;AACxB;ACxBO,SAASC,GAASC,GAAuC/N,IAA2B,IAAI;AAC7F,QAAMgO,IAAarS,EAAM,OAAsB,IAAI,GAC7CsS,IAAWtS,EAAM,OAAsB,IAAI,GAG3CuS,IAAmBlO,EAAQ,oBAAoB,IAE/CmO,IAAe,CAAC7L,MAAsB;AAC1C,IAAA2L,EAAS,UAAU,MACnBD,EAAW,UAAU1L,EAAM,cAAc,CAAC,EAAE;AAAA,EAC9C,GAEM8L,IAAc,CAAC9L,MAAsB;AACzC,IAAA2L,EAAS,UAAU3L,EAAM,cAAc,CAAC,EAAE;AAAA,EAC5C,GAEM+L,IAAa1S,EAAM,YAAY,MAAM;AACzC,QAAI,CAACqS,EAAW,WAAW,CAACC,EAAS;AACnC;AAEF,UAAMK,IAAWN,EAAW,UAAUC,EAAS,SACzCM,IAAcD,IAAWJ,GACzBM,IAAeF,IAAW,CAACJ;AAEjC,IAAIK,KAAevO,EAAQ,eAAaA,EAAQ,YAAA,GAC5CwO,KAAgBxO,EAAQ,gBAAcA,EAAQ,aAAA;AAAA,EACpD,GAAG,CAACkO,GAAkBlO,CAAO,CAAC;AAE9B,EAAArE,EAAM,UAAU,MAAM;AACpB,UAAM8S,IAAcV,EAAQ;AAC5B,WAAIU,MACFA,EAAY,iBAAiB,cAAcN,GAAc,EAAE,SAAS,IAAM,GAC1EM,EAAY,iBAAiB,aAAaL,GAAa,EAAE,SAAS,IAAM,GACxEK,EAAY,iBAAiB,YAAYJ,GAAY,EAAE,SAAS,IAAM,IAEjE,MAAM;AACX,MAAII,MACFA,EAAY,oBAAoB,cAAcN,CAAY,GAC1DM,EAAY,oBAAoB,aAAaL,CAAW,GACxDK,EAAY,oBAAoB,YAAYJ,CAAU;AAAA,IAE1D;AAAA,EACF,GAAG,CAACN,GAASM,CAAU,CAAC;AAC1B;AClDO,SAASK,GAAc,EAAE,OAAApP,KAA6B;AAC3D,QAAM,EAAE,UAAAK,GAAU,OAAA/B,MAAUgC,KAAmB,QACzC,EAAE,WAAAC,MAAclE,EAAM,QAAQ,MAAMgT,GAAA,GAAmB,EAAE;AAiB/D,SAAO,EAAE,aAfWhT,EAAM,QAAQ,MACzByD,EAAWE,GAAO;AAAA,IACvB,WAAAO;AAAA,IACA,SAAS,MAAM;AACb,MAAIF,KAAUA,EAAS,EAAE,KAAK,eAAe;AAAA,IAC/C;AAAA,IACA,gBAAgB/B,KAAA,QAAAA,EAAO,WAAW,SAAS;AAAA,IAC3C,uBAAuBA,IACnBA,EAAM,iBAAiB,KACrBA,EAAM,eAAe,QAAQ,CAAC,IAC9B,OACF;AAAA,EAAA,CACL,GACA,CAAC0B,GAAOO,GAAWF,GAAU/B,CAAK,CAAC,EAE7B;AACX;ACdO,SAASgR,GACdC,GACAC,GACA9O,IAA2B,CAAA,GAC3B;AACA,QAAM,CAAC4E,GAAOmK,CAAQ,IAAIpT,EAAM,SAA6B,MAAS;AAEtE,SAAAA,EAAM,UAAU,MAAM;;AACpB,QAAIkT,MAAkB;AACpB,YAAM,MAAM,oCAAoC;AAElD,UAAItM,IAAAvC,EAAQ,aAAR,gBAAAuC,EAAkB,cAAa;AACjC;AAeF,KAbqB,YAAY;AAC/B,MAAAgC,EAAI,MAAM,gBAAgB;AAC1B,YAAMyK,IAAS,IAAI,gBAAgB,EAAE,GAAGhP,EAAQ,UAAU,UAAA8O,GAAU,GAC9DG,IAAM,MAAM,MAAM,GAAGJ,CAAa,IAAIG,EAAO,SAAA,CAAU,EAAE;AAC/D,UAAI,CAACC,EAAI,IAAI;AACX,QAAA1K,EAAI;AAAA,UACF,uDAAuD0K,EAAI,MAAM,KAAKA,EAAI,UAAU;AAAA,QAAA;AAEtF;AAAA,MACF;AACA,YAAM,EAAE,aAAAC,EAAA,IAAgB,MAAMD,EAAI,KAAA;AAClC,MAAAF,EAASG,CAAW;AAAA,IACtB,GACA;AAAA,EACF,GAAG,CAACL,GAAeC,GAAU,KAAK,UAAU9O,CAAO,CAAC,CAAC,GAC9C4E;AACT;AC7BO,SAASuK,GACdpN,GAC+B;;AAC/B,QAAMN,IAAiBO,GAAkBD,CAAQ,GAE3C,EAAE,WAAAlC,GAAW,oBAAAuP,EAAA,IAAuBzT,EAAM;AAAA,IAC9C,MAAM0T,GAAyB5N,CAAc;AAAA,IAC7C,CAACkC,GAAoBlC,CAAc,CAAC;AAAA,EAAA;AAWtC,SAAO,EAAE,SAROjE;AAAA,IACd4R;AAAA,IACA,CAAC,GACC7M,IAAAd,EAAe,gBAAf,QAAAc,EAA4B,YAC5BE,IAAAhB,EAAe,YAAY,oBAAoBA,EAAe,MAAM,MAApE,QAAAgB,EAAuE;AAAA,EAAA,GAIzD,WAAA5C,EAAA;AACpB;ACjBO,SAASyP,GAAuC;AAAA,EACrD,QAAAC;AAAA,EACA,UAAAC;AAAA,EACA,cAAAC;AAAA,EACA,gBAAAC;AAAA,EACA,gBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,MAAArR;AAAA,EACA,GAAGmH;AACL,GAA2B;;AACzB,QAAMmK,IAAkBvH,GAAA,GAClBC,IAAe5M,EAAM,QAAQ,MAAM4C,KAAQsR,GAAiB,CAACtR,GAAMsR,CAAe,CAAC,GACnF1H,KAAQ5F,IAAAgG,KAAA,gBAAAA,EAAc,qBAAd,gBAAAhG,EAAgC,oBAAoBgN,IAE5DO,IAAqBnU,EAAM,OAAO,EAAK,GAEvC,EAAE,QAAAoU,GAAQ,WAAAlQ,GAAW,iBAAAmQ,GAAiB,iBAAAC,EAAA,IAAoBtU,EAAM;AAAA,IACpE,MACE4M,IACI2H,GAAoBX,GAAQhH,GAAcmH,GAAgBC,GAAgBC,CAAa,IACvFO,GAAA;AAAA,IACN,CAAC5H,GAAcgH,GAAQ,KAAK,UAAUG,CAAc,GAAGC,CAAc;AAAA,EAAA,GAGjES,IAAU5S,EAAmBwS,GAAiB,EAAK,GACnDK,IAAU7S,EAAmByS,GAAiBR,KAAgB,CAAC,EAACtH,KAAA,QAAAA,EAAO,UAAS;AAEtF,EAAAxM,EAAM,UAAU,MAAM;AACpB,IAAA6T,KAAA,QAAAA,EAAWa,GAASP,EAAmB,UACvCA,EAAmB,UAAU;AAAA,EAC/B,GAAG,CAACO,GAASb,CAAQ,CAAC,GAEtB7T,EAAM,UAAU,MAAM;AACpB,IAAI8T,MAAiB,WACnBlL,EAAI,MAAM,gCAAgCgL,GAAQE,CAAY,GAC9DM,EAAON,CAAY;AAAA,EAIvB,GAAG,CAAA,CAAE;AAEL,QAAMa,IAAW3U,EAAM,QAAQ,MAAMyD,EAAWsG,GAAM,EAAE,WAAA7F,GAAW,GAAG,CAAC6F,GAAM7F,CAAS,CAAC,GAEjF0Q,IAA2D5U,EAAM;AAAA,IACrE,CAAC6U,MAAQ;;AACP,MAAAV,EAAmB,UAAU,IAC7BC,EAAA,EAAS,MAAM,MAAOD,EAAmB,UAAU,EAAM,IACzDvN,IAAAmD,EAAK,YAAL,QAAAnD,EAAA,KAAAmD,GAAe8K;AAAA,IACjB;AAAA,IACA,CAAC9K,GAAMqK,CAAM;AAAA,EAAA;AAGf,SAAO;AAAA,IACL,QAAAA;AAAA,IACA,SAAAM;AAAA,IACA,SAAAD;AAAA,IACA,OAAAjI;AAAA,IACA,aAAa;AAAA,MACX,GAAGmI;AAAA,MACH,gBAAgBD;AAAA,MAChB,kBAAkBd;AAAA,MAClB,mBAAmBc;AAAA,MACnB,UAAUD;AAAA,MACV,SAASG;AAAA,IAAA;AAAA,EACX;AAEJ;AC5CO,SAASE,GACdC,IAAa;AAAA,EACXnF,EAAM,OAAO;AAAA,EACbA,EAAM,OAAO;AAAA,EACbA,EAAM,OAAO;AAAA,EACbA,EAAM,OAAO;AAAA,EACbA,EAAM,OAAO;AACf,GACAvL,IAA4B,CAAA,GACA;AAC5B,QAAMzB,IAAOE,EAAcuB,EAAQ,IAAI,GACjC,CAACmJ,GAAiBwH,CAAkB,IAAIhV,EAAM,SAA2B,CAAA,CAAE,GAC3E,CAACkQ,GAAcC,CAAe,IAAInQ,EAAM,SAAwB,CAAA,CAAE,GAElEiV,IAAWjV,EAAM,QAAQ,MACtB+U,EAAQ,IAAI,CAACG,MAAOC,GAAmBD,CAAC,IAAIA,EAAE,SAASA,CAAE,GAC/D,CAAC,KAAK,UAAUH,CAAO,CAAC,CAAC;AAE5B,SAAA/U,EAAM,UAAU,MAAM;AACpB,UAAMmC,IAAeiT,GAA0BxS,GAAMqS,GAAU;AAAA,MAC7D,sBAAsB5Q,EAAQ;AAAA,MAC9B,gBAAgBA,EAAQ;AAAA,IAAA,CACzB,EAAE,UAAU,CAAC,EAAE,iBAAAmJ,GAAiB,cAAA0C,QAAmB;AAClD,MAAAtH,EAAI,MAAM,yBAAyB4E,GAAiB0C,CAAY,GAChE8E,EAAmBxH,CAAe,GAClC2C,EAAgBD,CAAY;AAAA,IAC9B,CAAC;AACD,WAAO,MAAM/N,EAAa,YAAA;AAAA,EAC5B,GAAG;AAAA,IACDS;AAAA,IACA,KAAK,UAAUyB,EAAQ,cAAc;AAAA,IACrC,KAAK,UAAUA,EAAQ,YAAY;AAAA,IACnC,KAAK,UAAU0Q,CAAO;AAAA,EAAA,CACvB,GAE4B/U,EAAM,QAAQ,MAAM;AAC/C,QAAIqV,GAAqBN,CAAO,GAAG;AACjC,YAAMO,IAAqBC,GAAqBR,GAAS7E,CAAY,GAC/DsF,IACJ,MAAM,KAAKhI,CAAe;AAC5B,aAAA0C,EAAa,QAAQ,CAAChI,MAAgB;AACpC,QAAIoN,EAAmB,IAAIpN,EAAY,QAAQ,MACboN,EAAmB,IAAIpN,EAAY,QAAQ,KAAK,CAAA,GACxD,QAAQ,CAACuN,MAAsB;AACrD,cACEjI,EAAgB;AAAA,YACd,CAAC,EAAE,aAAalJ,GAAG,aAAAoR,QACjBxN,EAAY,aAAa5D,EAAE,YAAYoR,EAAY,WAAWD;AAAA,UAAA;AAGlE;AAEF,UAAA7M,EAAI;AAAA,YACF,OAAO6M,CAAiB,gCAAgCvN,EAAY,QAAQ;AAAA,UAAA;AAE9E,gBAAMyN,IAAyC;AAAA,YAC7C,aAAAzN;AAAA,YACA,QAAQuN;AAAA,UAAA;AAEV,UAAAD,EAAgC,KAAKG,CAAW;AAAA,QAClD,CAAC;AAAA,MAEL,CAAC,GACMH;AAAA,IACT;AACE,aAAOhI;AAAA,EAEX,GAAG,CAACA,GAAiB0C,GAAc6E,CAAO,CAAC;AAG7C;AAEA,SAASa,GAAcC,GAAcC,GAAsB;AACzD,QAAMC,IAAc,IAAI,IAAIF,CAAI;AAChC,aAAWG,KAAQF;AACjB,IAAAC,EAAY,OAAOC,CAAI;AAEzB,SAAOD;AACT;AAEO,SAASR,GACdR,GACA7E,GAC8C;AAC9C,QAAM+F,wBAAqB,IAAA;AAC3B,MAAIZ,GAAqBN,CAAO,GAAG;AACjC,UAAMmB,IAA6BnB,EAChC,OAAO,CAACoB,MAAqBA,EAAiB,eAAe,EAC7D,IAAI,CAACA,MAAqBA,EAAiB,MAAM;AAEpD,IAAAjG,EAAa,QAAQ,CAAChI,MAAgB;AACpC,YAAMkO,IAA4BlO,EAC/B,qBAAA,EACA,IAAI,CAACmO,MAAA;;AAAQ,gBAAAzP,IAAAyP,EAAI,UAAJ,gBAAAzP,EAAW;AAAA,OAAM,EAC9B,OAAO,CAAC0P,MAA6CA,MAAgB,MAAS,GAC3EC,IAAsC,MAAM;AAAA,QAChDX,GAAW,IAAI,IAAIM,CAA0B,GAAG,IAAI,IAAIE,CAAyB,CAAC;AAAA,MAAA;AAGpF,MAAIG,EAAoC,SAAS,KAC/CN,EAAe,IAAI/N,EAAY,UAAUqO,CAAmC;AAAA,IAEhF,CAAC;AAAA,EACH;AACA,SAAON;AACT;ACjJO,SAASO,GACd5C,GAC6B;AAC7B,QAAM,CAAC8B,GAAae,CAAc,IAAIzW,EAAM,SAAS0W,GAAqB9C,CAAM,CAAC,GAE3E,EAAE,eAAA+C,EAAA,IAAkB3W,EAAM,QAAQ,MAC/B4W,GAAgBhD,CAAM,GAC5B,CAACA,EAAO,YAAY,OAAOA,EAAO,YAAY,UAAUA,EAAO,MAAM,CAAC;AAEzE,SAAA5T,EAAM,UAAU,MAAM;AACpB,UAAMmC,IAAewU,EAAc,UAAU,CAACjB,MAAgB;AAC5D,MAAAe,EAAef,CAAW;AAAA,IAC5B,CAAC;AACD,WAAO,MAAMvT,KAAA,gBAAAA,EAAc;AAAA,EAC7B,GAAG,CAACwU,CAAa,CAAC,GAEX;AAAA,IACL,aAAa/C,EAAO;AAAA,IACpB,QAAQA,EAAO,UAAUhE,EAAM,OAAO;AAAA,IACtC,aAAA8F;AAAA,EAAA;AAEJ;AClBO,SAASmB,GAAe1H,GAAcjH,GAA2B;AACtE,QAAM5D,IAAIC,EAAqB2D,CAAW;AAC1C,SAAOsO,GAA0B,EAAE,MAAArH,GAAM,aAAa7K,GAAG;AAC3D;AC2BO,SAASwS,GAAQzS,GAAyC;AAC/D,QAAMzB,IAAOE,EAAcuB,KAAA,gBAAAA,EAAS,IAAI,GAClCoB,IAAkBd,GAAmB/B,CAAI,GACzCmU,IAAiB/W,EAAM;AAAA,IAC3B,MAAMyF,MAAoBG,EAAgB;AAAA,IAC1C,CAACH,CAAe;AAAA,EAAA,GAEZuR,IAAQhX,EAAM;AAAA,IAClB,MAAMiX,GAAUrU,GAAMyB,CAAO;AAAA,IAC7B,CAACzB,GAAMyB,GAAS0S,CAAc;AAAA,EAAA,GAE1BxR,IAAY1D,EAAmBmV,EAAM,qBAAqB,EAAK,GAC/DE,IAAerV,EAA0CmV,EAAM,mBAAmB,CAAA,CAAE;AAE1F,SAAO,EAAE,MAAMA,EAAM,MAAM,cAAAE,GAAc,WAAA3R,EAAA;AAC3C;AC1BO,SAAS4R,GAAyB9S,IAA2C,IAAI;AACtF,QAAM,CAAC+S,GAAaC,CAAW,IAAIrX,EAAM;AAAA,IACvCsX,GAAgBjT,EAAQ,UAAUA,EAAQ,eAAe,EAAK;AAAA,EAAA,GAG1DkT,IAAwBvX,EAAM,YAAY,CAACwX,MAAuB;AACtE,IAAAH,EAAY,CAACI,OAAU,EAAE,GAAGA,GAAM,cAAcD,IAAY;AAAA,EAC9D,GAAG,CAAA,CAAE,GACCE,IAAwB1X,EAAM,YAAY,CAACwX,MAAuB;AACtE,IAAAH,EAAY,CAACI,OAAU,EAAE,GAAGA,GAAM,cAAcD,IAAY;AAAA,EAC9D,GAAG,CAAA,CAAE,GACCG,IAAyB3X,EAAM,YAAY,CAACqN,MAAqB;AACrE,IAAAgK,EAAY,CAACI,OAAU,EAAE,GAAGA,GAAM,eAAepK,IAAW;AAAA,EAC9D,GAAG,CAAA,CAAE,GACCuK,IAAyB5X,EAAM,YAAY,CAACqN,MAAqB;AACrE,IAAAgK,EAAY,CAACI,OAAU,EAAE,GAAGA,GAAM,eAAepK,IAAW;AAAA,EAC9D,GAAG,CAAA,CAAE,GACCwK,IAAe7X,EAAM,YAAY,CAAC8X,MAAqB;AAC3D,IAAAT,EAAY,CAACI,OAAU,EAAE,GAAGA,GAAM,UAAAK,IAAqB;AAAA,EACzD,GAAG,CAAA,CAAE;AAEL,SAAA9X,EAAM,UAAU,MAAM;AACpB,IAAA+X,GAAgBX,GAAa/S,EAAQ,eAAe,EAAK;AAAA,EAC3D,GAAG,CAAC+S,GAAa/S,EAAQ,WAAW,CAAC,GAE9B;AAAA,IACL,aAAA+S;AAAA,IACA,uBAAAG;AAAA,IACA,uBAAAG;AAAA,IACA,wBAAAC;AAAA,IACA,wBAAAC;AAAA,IACA,cAAAC;AAAA,EAAA;AAEJ;AC9CO,SAASG,GAAe9P,GAA2B7D,IAAiC,IAAI;AAC7F,QAAMC,IAAIC,EAAqB2D,CAAW,GAEpCtF,IAAOE,EAAcuB,EAAQ,IAAI,GAEjC1D,IAAWX,EAAM,QAAQ,MAAMiY,GAA2BrV,GAAM0B,CAAC,GAAG,CAAC1B,GAAM0B,CAAC,CAAC;AAKnF,SAJoBzC;AAAA,IAClBlB;AAAA,IACA2D,EAAE,UAAWA,EAAuB,gBAAgB,CAAC,EAACA,KAAA,QAAAA,EAAG;AAAA,EAAA;AAG7D;ACfO,SAAS4T,GACdC,GACA9T,IAAgC,EAAE,SAAS,IAAI,uBAAuB,KACtE;AACA,QAAMmI,IAAQ4L,GAAiBD,CAAqB,IACAA,EAAsB,YAAY,QAClFA,GACE,CAACE,GAAQC,CAAS,IAAItY,EAAM,SAAS,CAAC;AAC5C,SAAAA,EAAM,UAAU,MAAM;AACpB,QAAI,CAACwM,KAAS,CAACA,EAAM;AACnB;AAGF,UAAM,EAAE,SAAA+L,GAAS,UAAAC,EAAA,IAAaC,GAAoBjM,GAAOnI,CAAO,GAE1DqU,IAAeF,EAAS,mBACxBG,IAAY,IAAI,WAAWD,CAAY,GAYvCE,IAAW,YAVI,MAAM;AACzB,MAAAJ,EAAS,qBAAqBG,CAAS;AACvC,UAAIE,IAAM;AACV,eAAS1X,IAAI,GAAGA,IAAIwX,EAAU,QAAQxX,KAAK;AACzC,cAAM0C,IAAI8U,EAAUxX,CAAC;AACrB,QAAA0X,KAAOhV,IAAIA;AAAA,MACb;AACA,MAAAyU,EAAU,KAAK,KAAKO,IAAMF,EAAU,MAAM,IAAI,GAAG;AAAA,IACnD,GAE2C,MAAO,EAAE;AAEpD,WAAO,MAAM;AACX,MAAAJ,EAAA,GACA,cAAcK,CAAQ;AAAA,IACxB;AAAA,EACF,GAAG,CAACpM,GAAOA,KAAA,gBAAAA,EAAO,aAAa,KAAK,UAAUnI,CAAO,CAAC,CAAC,GAEhDgU;AACT;AAEA,MAAMS,KAAuB,CAACC,MAA8B;AAC1D,QAAMC,IAAc,CAACC,MAAkB;AAGrC,QAAIC,IAAK,IAAK,KAAK,IAAI,MAAO,KAAK,IAAI,KAAOD,CAAK,CAAC,IAAI,KAAM;AAC9D,WAAAC,IAAK,KAAK,KAAKA,CAAE,GAEVA;AAAA,EACT;AAGA,SAAOH,EAAY,IAAI,CAACE,MAClBA,MAAU,SACL,IAEFD,EAAYC,CAAK,CACzB;AACH,GAyBME,KAAoB;AAAA,EACxB,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,gBAAgB;AAAA,EAChB,iBAAiB,EAAE,SAAS,KAAA;AAC9B;AAMO,SAASC,GACdjB,GACA9T,IAAuC,IACvC;;AACA,QAAMmI,IACJ2L,aAAiCvI,IAC7BuI,KACgDvR,IAAAuR,KAAA,gBAAAA,EAAuB,gBAAvB,gBAAAvR,EAAoC,OACpFyS,IAAO,EAAE,GAAGF,IAAmB,GAAG9U,EAAA,GAClC,CAACiV,GAAgBC,CAAiB,IAAIvZ,EAAM;AAAA,IAChD,IAAI,MAAMqZ,EAAK,KAAK,EAAE,KAAK,CAAC;AAAA,EAAA;AAG9B,SAAArZ,EAAM,UAAU,MAAM;AACpB,QAAI,CAACwM,KAAS,EAACA,KAAA,QAAAA,EAAO,cAAa;AACjC,MAAA+M,EAAkB,CAACzQ,MAAQA,EAAI,QAAQ,KAAK,CAAC,CAAC;AAC9C;AAAA,IACF;AACA,UAAM,EAAE,UAAA0P,GAAU,SAAAD,EAAA,IAAYE,GAAoBjM,GAAO6M,EAAK,eAAe,GAEvEX,IAAeF,EAAS,mBACxBG,IAAY,IAAI,aAAaD,CAAY,GA8BzCE,IAAW,YA5BI,MAAM;AACzB,MAAAJ,EAAS,sBAAsBG,CAAS;AACxC,UAAII,IAA4B,IAAI,aAAaJ,EAAU,MAAM;AACjE,eAASxX,IAAI,GAAGA,IAAIwX,EAAU,QAAQxX;AACpC,QAAA4X,EAAY5X,CAAC,IAAIwX,EAAUxX,CAAC;AAE9B,MAAA4X,IAAcA,EAAY,MAAMM,EAAK,QAAQA,EAAK,MAAM;AAExD,YAAMG,IAAwBV,GAAqBC,CAAW,GACxDU,IAAYD,EAAsB,QAClCE,IAAwB,CAAA;AAC9B,eAASvY,IAAI,GAAGA,IAAIkY,EAAK,OAAOlY,KAAK;AAEnC,cAAMwY,IAAa,KAAK,MAAOxY,IAAIsY,IAAaJ,EAAK,KAAK,GACpDO,IAAW,KAAK,OAAQzY,IAAI,KAAKsY,IAAaJ,EAAK,KAAK,GACxDQ,IAAQL,EAAsB,MAAMG,GAAYC,CAAQ,GACxDE,IAAcD,EAAM;AAC1B,YAAIC,MAAgB;AAClB,UAAAJ,EAAO,KAAK,CAAC;AAAA,aACR;AACL,gBAAMK,IAAgBF,EAAM,OAAO,CAACG,GAAKlR,MAASkR,KAAOlR,GAAM,CAAC;AAChE,UAAA4Q,EAAO,KAAKK,IAAgBD,CAAW;AAAA,QACzC;AAAA,MACF;AAEA,MAAAP,EAAkBG,CAAM;AAAA,IAC1B,GAE2CL,EAAK,cAAc;AAE9D,WAAO,MAAM;AACX,MAAAd,EAAA,GACA,cAAcK,CAAQ;AAAA,IACxB;AAAA,EACF,GAAG,CAACpM,GAAOA,KAAA,gBAAAA,EAAO,aAAa,KAAK,UAAUnI,CAAO,CAAC,CAAC,GAEhDiV;AACT;AAWA,MAAMW,KAAmB;AAAA,EACvB,UAAU;AAAA,EACV,eAAe;AAAA,EACf,gBAAgB;AAClB;AAKO,SAASC,GACd/B,GACA9T,IAAgC,IAChC;;AACA,QAAMmI,IACJ2L,aAAiCvI,IAC7BuI,KACgDvR,IAAAuR,KAAA,gBAAAA,EAAuB,gBAAvB,gBAAAvR,EAAoC,OACpFyS,IAAO,EAAE,GAAGY,IAAkB,GAAG5V,EAAA,GAEjC8V,IAAgBna,EAAM,OAAO,IAAI,cAAc,GAC/Coa,IAAUpa,EAAM,OAAO,YAAY,KAAK,GACxCqa,IAAUra,EAAM,OAAO,CAAC,GACxB,CAACsa,GAAMC,CAAO,IAAIva,EAAM,SAAmB,CAAA,CAAE,GAE7Cwa,IAAWxa,EAAM,YAAY,CAACya,MAAuB;AACzD,IAAAF;AAAA,MACE,MAAM;AAAA,QACJG,GAAWD,GAAMpB,EAAK,QAAQ,EAAE,IAAI,CAACsB,MAAM,KAAK,KAAKA,CAAC,IAAItB,EAAK,aAAa;AAAA;AAAA,MAAA;AAAA,IAE9E;AAAA,EAEJ,GAAG,CAAA,CAAE;AAEL,SAAArZ,EAAM,UAAU,MAAM;AACpB,QAAI,CAACwM,KAAS,EAACA,KAAA,QAAAA,EAAO;AACpB;AAEF,UAAM,EAAE,UAAAgM,GAAU,SAAAD,MAAYE,GAAoBjM,GAAO;AAAA,MACvD,SAASoO,GAAgBvB,EAAK,QAAQ;AAAA,IAAA,CACvC,GAEKX,IAAekC,GAAgBvB,EAAK,QAAQ,GAC5CV,IAAY,IAAI,aAAaD,CAAY,GAEzCmC,IAAS,MAAM;AAMnB,UALAC,IAAiB,sBAAsBD,CAAM,GAC7CrC,EAAS,uBAAuBG,CAAS,GACzCwB,EAAc,QAAQ,IAAI,CAACQ,GAAGxZ,MAAMwZ,IAAIhC,EAAUxX,CAAC,CAAC,GACpDkZ,EAAQ,WAAW,GAEf,YAAY,IAAA,IAAQD,EAAQ,WAAWf,EAAK,gBAAgB;AAC9D,cAAM0B,IAAUpC,EAAU,IAAI,CAACgC,MAAMA,IAAIN,EAAQ,OAAO;AACxD,QAAAG,EAASO,CAAO,GAChBX,EAAQ,UAAU,YAAY,IAAA,GAC9BC,EAAQ,UAAU;AAAA,MACpB;AAAA,IACF;AAEA,QAAIS,IAAiB,sBAAsBD,CAAM;AAEjD,WAAO,MAAM;AACX,MAAAtC,EAAA,GACA,qBAAqBuC,CAAc;AAAA,IACrC;AAAA,EACF,GAAG,CAACtO,GAAOA,KAAA,gBAAAA,EAAO,aAAa,KAAK,UAAUnI,CAAO,GAAGmW,CAAQ,CAAC,GAE1D;AAAA,IACL,MAAAF;AAAA,EAAA;AAEJ;AAEA,SAASM,GAAgBI,GAAW;AAClC,SAAIA,IAAI,KAAW,KACPC,GAASD,CAAC;AACxB;AAMA,SAASC,GAASN,GAAW;AAC3B,MAAIrW,IAAI;AACR,SAAQqW,MAAM;AACZ,IAAArW,MAAM;AAER,SAAOA;AACT;AAEA,SAASoW,GAAWQ,GAAyBC,GAAoB;AAC/D,QAAMC,IAAY,KAAK,MAAMF,EAAU,SAASC,CAAU,GACpDE,IAAe,IAAI,aAAaF,CAAU;AAChD,WAASha,IAAI,GAAGA,IAAIga,GAAYha,KAAK;AACnC,UAAMma,IAAaF,IAAYja;AAC/B,QAAI0X,IAAM;AACV,aAAS0C,IAAI,GAAGA,IAAIH,GAAWG;AAC7B,MAAA1C,IAAMA,IAAM,KAAK,IAAIqC,EAAUI,IAAaC,CAAC,CAAC;AAEhD,IAAAF,EAAala,CAAC,IAAI0X,IAAMuC;AAAA,EAC1B;AACA,SAAOC;AACT;ACnQO,SAASG,GACdzG,GACA0G,IAEyD,IAClC;AACvB,MAAIC,GACA9Y;AACJ,EAAI,OAAO6Y,KAAiC,WAC1CC,IAAsBD,KAEtBC,IAAsBD,KAAA,gBAAAA,EAA8B,qBACpD7Y,IAAO6Y,KAAA,gBAAAA,EAA8B;AAGvC,QAAME,IAAqB5M,GAAA,GACrBmB,IAAeG,GAAgB,EAAE,MAAAzN,GAAM,cAAc,CAAA,GAAI,GAEzD0B,IAAItE,EAAM,QAAQ,MAClB0b,IACKxL,EAAa,KAAK,CAAC5L,MAAMA,EAAE,aAAaoX,CAAmB,IAE7DC,GACN,CAACD,GAAqBxL,GAAcyL,CAAkB,CAAC,GAEpD7Z,IAAa9B,EAAM,QAAQ,MAAM;AACrC,QAAKsE;AAGL,aAAOsX,GAA4BtX,GAAG,EAAE,SAAAyQ,GAAS;AAAA,EACnD,GAAG,CAACzQ,GAAG,KAAK,UAAUyQ,CAAO,CAAC,CAAC;AAI/B,SAFkBlT,EAAmBC,GAAY,EAA2B;AAG9E;AC7CO,SAAS+Z,GAAiBlU,GAA8C;;AAC7E,QAAM7F,IAAa9B,EAAM;AAAA,IACvB;;AAAO,cAAA4G,IAAAe,KAAA,gBAAAA,EAAK,gBAAL,QAAAf,EAAkB,QAAQkV,GAAsBnU,KAAA,gBAAAA,EAAK,YAAY,KAAK,IAAI;AAAA;AAAA,IACjF,EAACf,IAAAe,KAAA,gBAAAA,EAAK,gBAAL,gBAAAf,EAAkB,KAAK;AAAA,EAAA;AAE1B,SAAO/E,EAAmBC,GAAY;AAAA,IACpC,WAAW,KAAK,IAAA;AAAA,IAChB,eAAc+E,KAAAC,IAAAa,KAAA,gBAAAA,EAAK,gBAAL,gBAAAb,EAAkB,UAAlB,gBAAAD,EAAyB;AAAA,EAAA,CACxC;AACH;ACeA,MAAMkV,KAA+B;AAAA,EACnC,YAAY;AAAA;AAEd;AAOO,SAASC,GACd5V,GACA/B,GACA;AACA,QAAMgV,IAAO,EAAE,GAAG0C,IAA8B,GAAG1X,EAAA,GAC7C,CAAC4X,GAAUC,CAAW,IAAIlc,EAAM,SAA8C,CAAA,CAAE,GAEhFmc,IAAiBN,GAAiBzV,CAAQ,GAC1CgW,IAAuB,CAACC,MAAwC;;AACpE,KAAAzV,IAAAyS,EAAK,oBAAL,QAAAzS,EAAA,KAAAyS,GAAuBgD,IACvBH;AAAA,MAAY,CAACI,MACXC;AAAA,QACED;AAAA;AAAA,QAEAD,EAAY,IAAI,CAACnH,MAAMsH,GAA6BtH,GAAGiH,CAAc,CAAC;AAAA,QACtE9C,EAAK;AAAA,MAAA;AAAA,IACP;AAAA,EAEJ;AACA,SAAArZ,EAAM,UAAU,MAAM;AACpB,QAAI,EAACoG,KAAA,QAAAA,EAAU;AACb;AAEF,UAAMjE,IAAesa,GAA2BrW,EAAS,WAAW,EAAE,UAAU,CAACyO,MAAQ;AACvF,MAAAuH,EAAqB,GAAGvH,CAAG;AAAA,IAC7B,CAAC;AACD,WAAO,MAAM;AACX,MAAA1S,EAAa,YAAA;AAAA,IACf;AAAA,EACF,GAAG,CAACiE,KAAY4B,GAAoB5B,CAAQ,GAAGgW,CAAoB,CAAC,GAE7D,EAAE,UAAAH,EAAA;AACX;ACrDO,SAASS,GAAyB/Y,IAAyC,IAAI;AACpF,QAAMgY,IAAqB5M,GAAA,GACrBzK,IAAIX,EAAM,eAAegY,GACzBgB,IAAoB3c,EAAM;AAAA;AAAA,IAE9B,MAAOsE,IAAIsY,GAA8BtY,CAAC,IAAIsY,GAA8BtY,CAAC;AAAA,IAC7E,CAACA,CAAC;AAAA,EAAA;AAMJ,SAJuBzC,EAAmB8a,GAAmB;AAAA,IAC3D,YAAYrY,KAAA,gBAAAA,EAAG;AAAA,EAAA,CAChB;AAGH;AAYO,SAASuY,GACdC,GACAzY,IAA2C,IAC3C;AACA,QAAMC,IAAIC,EAAqBF,EAAQ,WAAW,GAC5C,CAAC0Y,GAAWC,CAAY,IAAIhd,EAAM,SAASsE,EAAE,WAAWwY,CAAY,CAAC;AAE3E,SAAA9c,EAAM,UAAU,MAAM;AACpB,QAAI,CAACsE;AACH;AAEF,UAAMnC,IAAeya,GAA8BtY,CAAC,EAAE,UAAU,CAACwE,MAAQ;AACvE,MAAIA,EAAI,QAAQgU,CAAY,MAAM,UAChCE,EAAalU,EAAI,WAAWgU,CAAY,CAAC;AAAA,IAE7C,CAAC;AACD,WAAO,MAAM;AACX,MAAA3a,EAAa,YAAA;AAAA,IACf;AAAA,EACF,GAAG,CAACmC,GAAGwY,CAAY,CAAC,GAEbC;AACT;ACvBA,MAAME,KAAkBC,EAA2B;AAW5C,SAASC,KAAoC;AAClD,QAAM7M,IAAqBL,GAAA,GACrBmN,IAAQ9M,EAAmB;AAAA,IAC/B,CAAChM,MACCA,EAAE,SAAS+Y,GAAgB,SAC3B,EAAEH,EAA2B,mBAAmB5Y,EAAE;AAAA,EAAA,GAEhDgZ,IAAShN,EAAmB;AAAA,IAChC,CAAChM,MACCA,EAAE,SAAS+Y,GAAgB,SAC3B/Y,EAAE,WAAW4Y,EAA2B,eAAe,OAAME,KAAA,gBAAAA,EAAO;AAAA,EAAA,GAElEG,IAAc/B;AAAA,IAClB,CAAC5L,EAAM,OAAO,YAAYA,EAAM,OAAO,MAAM;AAAA,IAC7CwN,KAAA,gBAAAA,EAAO;AAAA,EAAA,GAEHI,IAAehC;AAAA,IACnB,CAAC5L,EAAM,OAAO,YAAYA,EAAM,OAAO,MAAM;AAAA,IAC7C0N,KAAA,gBAAAA,EAAQ;AAAA,EAAA,GAEJG,IACJF,EAAY,KAAK,CAACG,MAAMA,EAAE,WAAW9N,EAAM,OAAO,UAAU,KAC5D4N,EAAa,KAAK,CAACE,MAAMA,EAAE,WAAW9N,EAAM,OAAO,UAAU,GACzD+N,IACJJ,EAAY,KAAK,CAACG,MAAMA,EAAE,WAAW9N,EAAM,OAAO,MAAM,KACxD4N,EAAa,KAAK,CAACE,MAAMA,EAAE,WAAW9N,EAAM,OAAO,MAAM,GACrD,EAAE,UAAUgO,MAAwB5B,GAAsByB,CAAU,GACpEhY,IAAkBd,GAAA,GAClB,EAAE,YAAAkZ,EAAA,IAAenB,GAAyB,EAAE,aAAaU,GAAO,GAEhEnb,IAAoBjC,EAAM,QAAQ,MAClCyF,MAAoBG,EAAgB,eAC/B,iBAEPH,MAAoBG,EAAgB,cACpC,CAACwX,KACD,EAACS,KAAA,QAAAA,EAAaZ,OAEP,eAEAY,EAAWZ,EAAe,GAElC,CAACY,GAAYT,GAAO3X,CAAe,CAAC;AAEvC,SAAO;AAAA,IACL,OAAA2X;AAAA,IACA,OAAAnb;AAAA,IACA,YAAAwb;AAAA,IACA,YAAAE;AAAA,IACA,qBAAAC;AAAA,IACA,iBAAiBC;AAAA,EAAA;AAErB;AC7FO,SAASC,GAAelb,GAAa;AAC1C,QAAMM,IAAIJ,EAAcF,CAAI,GACtB6C,IAAkBd,GAAmBzB,CAAC,GACtCpB,IAAa9B,EAAM,QAAQ,MAAM+d,GAA0B7a,CAAC,GAAG,CAACA,GAAGuC,CAAe,CAAC;AAGzF,SAFoB5D,EAAmBC,GAAYoB,EAAE,WAAW;AAGlE;ACAO,SAAS8a,GAAchZ,GAAeX,GAAgC;AAC3E,QAAMzB,IAAOE,EAAcuB,KAAA,gBAAAA,EAAS,IAAI,GAGlC0S,IADkBpS,GAAmB/B,CAAI,MACJgD,EAAgB,cAErDqY,IAAiBje,EAAM,QAAQ,MAAMke,GAAgBtb,GAAMoC,CAAK,GAAG,CAACpC,GAAMoC,CAAK,CAAC;AAKtF,SAAO,EAAE,aAFWnD,EAFSkV,IAAiB,SAAYkH,GAEqB,EAAE,EAExE;AACX;ACVO,SAASE,GAAkB9E,GAAiC;AACjE,QAAM,EAAE,uBAAA+E,GAAuB,WAAAC,EAAA,IAAchF,KAAQ,CAAA,GAC/C,EAAE,aAAAiF,MAAgBN,GAAcO,GAAU,eAAe,EAAE,MAAMlF,KAAA,gBAAAA,EAAM,MAAM;AAoBnF,SAlByBrZ,EAAM;AAAA,IAC7B,MACEse,EACG;AAAA,MAAO,CAACE,MACPJ,IACIA,EAAsB,SAASI,EAAO,gBAAgB,QAAQ,IAC9D;AAAA,IAAA,EAEL;AAAA,MAAO,CAACA,MAAA;;AACP,eAAAH,IACIA,EAAU;AAAA,YACRzX,IAAA4X,EAAO,WAAW,eAAlB,gBAAA5X,EAA+BsW,EAA2B,wBAAuB;AAAA,QAAA,IAEnF;AAAA;AAAA,IAAA;AAAA,IAEV,CAACoB,GAAaF,GAAuBC,CAAS;AAAA,EAAA;AAIlD;AC3CA,MAAMI,KAAgD,GAChDC,KAA0C,KAE1CC,KAAyC,GACzCC,KAAmC;AA2BlC,SAASC,GACdjc,GAC8C;AAC9C,QAAMkc,IAA4BC,GAiBhC,EAAE,GAKEC,IAAoCC,GAAQ,MAAM,IAAIC,GAAA,GAAS,CAAA,CAAE,GACjEC,IAAgCC,GAAY,YACzCJ,EAAkC,KAAA,EAAO,KAAK,OAAOK,MAAW;AACrE,eAAa;AACX,YAAM/Z,IAAUwZ,EAA0B,QAAQ,IAAA;AAClD,UAAI,CAACxZ,GAAS;AACZ,QAAA+Z,EAAA;AACA;AAAA,MACF;AAEA,cAAQ/Z,EAAQ,MAAA;AAAA,QACd,KAAK;AACH,gBAAMA,EAAQ,KACX,QAAQ,GAAGA,EAAQ,IAAI,EACvB,KAAKA,EAAQ,OAAO,EACpB,MAAMA,EAAQ,MAAM;AACvB;AAAA,QACF,KAAK;AACH,gBAAMA,EAAQ,KACX,WAAW,GAAGA,EAAQ,IAAI,EAC1B,KAAKA,EAAQ,OAAO,EACpB,MAAMA,EAAQ,MAAM;AACvB;AAAA,MAAA;AAAA,IAEN;AAAA,EACF,CAAC,GACA,CAAA,CAAE,GAECga,IAAsBP,GAAoB,EAAE,GAC5CQ,IAAqBH,GAAY,CAACI,MAAc;AACpD,QAAIC,IAAyB;AAC7B,IAAAH,EAAoB,UAAUA,EAAoB,QAAQ,OAAO,CAACne,MAAM;AACtE,YAAMue,IAAoBF,EAAI,QAAA,IAAYre,EAAE,YAAYyd;AACxD,aAAIc,MACFD,KAA0B,IAErBC;AAAA,IACT,CAAC,GAEGD,IAAyBd,MAC3B/V,EAAI;AAAA,MACF,4EAA4E+V,EAAsC,QAAQC,EAAgC;AAAA,IAAA;AAAA,EAGhK,GAAG,CAAA,CAAE;AAGL,EAAAe,GAAU,MAAM;AACd,IAAAb,EAA0B,UAAU,CAAA;AAEpC,UAAMU,wBAAU,KAAA;AAChB,IAAAF,EAAoB,QAAQ,KAAKE,CAAG,GACpCD,EAAmBC,CAAG;AAAA,EACxB,GAAG,CAAC5c,GAAM2c,CAAkB,CAAC;AAE7B,QAAMK,IAAgCb,GAAoB,EAAE,GACtDc,IAAkCT,GAAY,CAACI,MAAc;AACjE,QAAIM,IAAgC;AACpC,IAAAF,EAA8B,UAAUA,EAA8B,QAAQ,OAAO,CAACze,MAAM;AAC1F,YAAMue,IACJF,EAAI,QAAA,IAAYre,EAAE,YAAYud;AAChC,aAAIgB,MACFI,KAAiC,IAE5BJ;AAAA,IACT,CAAC,GAEGI,IAAgCrB,MAClC7V,EAAI;AAAA,MACF,mGAAmG6V,EAA6C,QAAQC,EAAuC;AAAA,IAAA;AAAA,EAGrM,GAAG,CAAA,CAAE,GAECrV,IAAU+V;AAAA,IACd,UAAU7b,MACD,IAAI,QAAQ,CAACwc,GAASC,MAAW;AACtC,UAAI,CAACpd;AACH,cAAM,IAAI,MAAM,sCAAsC;AAExD,YAAM4c,wBAAU,KAAA;AAChB,MAAAK,EAAgCL,CAAG,GACnCV,EAA0B,QAAQ,KAAK,EAAE,MAAM,WAAW,MAAAlc,GAAM,MAAAW,GAAM,SAAAwc,GAAS,QAAAC,GAAQ,GACvFJ,EAA8B,QAAQ,KAAKJ,CAAG,GAC9CL,EAAA;AAAA,IACF,CAAC;AAAA,IAEH,CAACvc,GAAMid,GAAiCV,CAA6B;AAAA,EAAA,GAGjEzZ,IAAa0Z;AAAA,IACjB,UAAU7b,MACD,IAAI,QAAQ,CAACwc,GAASC,MAAW;AACtC,UAAI,CAACpd;AACH,cAAM,IAAI,MAAM,0CAA0C;AAE5D,YAAM4c,wBAAU,KAAA;AAChB,MAAAK,EAAgCL,CAAG,GACnCV,EAA0B,QAAQ,KAAK,EAAE,MAAM,cAAc,MAAAlc,GAAM,MAAAW,GAAM,SAAAwc,GAAS,QAAAC,GAAQ,GAC1FJ,EAA8B,QAAQ,KAAKJ,CAAG,GAC9CL,EAAA;AAAA,IACF,CAAC;AAAA,IAEH,CAACvc,GAAMid,GAAiCV,CAA6B;AAAA,EAAA;AAGvE,SAAO;AAAA,IACL,SAASvc,IAAOyG,IAAU;AAAA,IAC1B,YAAYzG,IAAO8C,IAAa;AAAA,EAAA;AAEpC;;;;;ACnJA,MAAIua,IAAI,OAAO,WAAY,WAAW,UAAU,MAC5CC,IAAeD,KAAK,OAAOA,EAAE,SAAU,aACvCA,EAAE,QACF,SAAsB/f,GAAQigB,GAAU5c,GAAM;AAC9C,WAAO,SAAS,UAAU,MAAM,KAAKrD,GAAQigB,GAAU5c,CAAI;AAAA,EAC/D,GAEI6c;AACJ,EAAIH,KAAK,OAAOA,EAAE,WAAY,aAC5BG,IAAiBH,EAAE,UACV,OAAO,wBAChBG,IAAiB,SAAwBlgB,GAAQ;AAC/C,WAAO,OAAO,oBAAoBA,CAAM,EACrC,OAAO,OAAO,sBAAsBA,CAAM,CAAC;AAAA,EAClD,IAEEkgB,IAAiB,SAAwBlgB,GAAQ;AAC/C,WAAO,OAAO,oBAAoBA,CAAM;AAAA,EAC5C;AAGA,WAASmgB,EAAmBC,GAAS;AACnC,IAAI,WAAW,QAAQ,QAAM,QAAQ,KAAKA,CAAO;AAAA,EACnD;AAEA,MAAIC,IAAc,OAAO,SAAS,SAAqBtH,GAAO;AAC5D,WAAOA,MAAUA;AAAA,EACnB;AAEA,WAASuH,IAAe;AACtB,IAAAA,EAAa,KAAK,KAAK,IAAI;AAAA,EAC7B;AACAC,EAAAA,GAAA,UAAiBD,GACjBC,GAAA,QAAA,OAAsBC,GAGtBF,EAAa,eAAeA,GAE5BA,EAAa,UAAU,UAAU,QACjCA,EAAa,UAAU,eAAe,GACtCA,EAAa,UAAU,gBAAgB;AAIvC,MAAIG,IAAsB;AAE1B,WAASC,EAAc9Y,GAAU;AAC/B,QAAI,OAAOA,KAAa;AACtB,YAAM,IAAI,UAAU,qEAAqE,OAAOA,CAAQ;AAAA,EAE5G;AAEA,SAAO,eAAe0Y,GAAc,uBAAuB;AAAA,IACzD,YAAY;AAAA,IACZ,KAAK,WAAW;AACd,aAAOG;AAAA,IACX;AAAA,IACE,KAAK,SAASE,GAAK;AACjB,UAAI,OAAOA,KAAQ,YAAYA,IAAM,KAAKN,EAAYM,CAAG;AACvD,cAAM,IAAI,WAAW,oGAAoGA,IAAM,GAAG;AAEpI,MAAAF,IAAsBE;AAAA,IAC1B;AAAA,EACA,CAAC,GAEDL,EAAa,OAAO,WAAW;AAE7B,KAAI,KAAK,YAAY,UACjB,KAAK,YAAY,OAAO,eAAe,IAAI,EAAE,aAC/C,KAAK,UAAU,uBAAO,OAAO,IAAI,GACjC,KAAK,eAAe,IAGtB,KAAK,gBAAgB,KAAK,iBAAiB;AAAA,EAC7C,GAIAA,EAAa,UAAU,kBAAkB,SAAyBpd,GAAG;AACnE,QAAI,OAAOA,KAAM,YAAYA,IAAI,KAAKmd,EAAYnd,CAAC;AACjD,YAAM,IAAI,WAAW,kFAAkFA,IAAI,GAAG;AAEhH,gBAAK,gBAAgBA,GACd;AAAA,EACT;AAEA,WAAS0d,EAAiBC,GAAM;AAC9B,WAAIA,EAAK,kBAAkB,SAClBP,EAAa,sBACfO,EAAK;AAAA,EACd;AAEA,EAAAP,EAAa,UAAU,kBAAkB,WAA2B;AAClE,WAAOM,EAAiB,IAAI;AAAA,EAC9B,GAEAN,EAAa,UAAU,OAAO,SAAcQ,GAAM;AAEhD,aADIzd,IAAO,CAAA,GACFpC,IAAI,GAAGA,IAAI,UAAU,QAAQA,IAAK,CAAAoC,EAAK,KAAK,UAAUpC,CAAC,CAAC;AACjE,QAAI8f,IAAWD,MAAS,SAEpBE,IAAS,KAAK;AAClB,QAAIA,MAAW;AACb,MAAAD,IAAWA,KAAWC,EAAO,UAAU;AAAA,aAChC,CAACD;AACR,aAAO;AAGT,QAAIA,GAAS;AACX,UAAIE;AAGJ,UAFI5d,EAAK,SAAS,MAChB4d,IAAK5d,EAAK,CAAC,IACT4d,aAAc;AAGhB,cAAMA;AAGR,UAAIC,IAAM,IAAI,MAAM,sBAAsBD,IAAK,OAAOA,EAAG,UAAU,MAAM,GAAG;AAC5E,YAAAC,EAAI,UAAUD,GACRC;AAAA,IACV;AAEE,QAAIC,IAAUH,EAAOF,CAAI;AAEzB,QAAIK,MAAY;AACd,aAAO;AAET,QAAI,OAAOA,KAAY;AACrB,MAAAnB,EAAamB,GAAS,MAAM9d,CAAI;AAAA;AAIhC,eAFI+d,IAAMD,EAAQ,QACdE,IAAYC,EAAWH,GAASC,CAAG,GAC9BngB,IAAI,GAAGA,IAAImgB,GAAK,EAAEngB;AACzB,QAAA+e,EAAaqB,EAAUpgB,CAAC,GAAG,MAAMoC,CAAI;AAGzC,WAAO;AAAA,EACT;AAEA,WAASke,EAAavhB,GAAQ8gB,GAAMlZ,GAAU4Z,GAAS;AACrD,QAAIC,GACAT,GACAU;AAsBJ,QApBAhB,EAAc9Y,CAAQ,GAEtBoZ,IAAShhB,EAAO,SACZghB,MAAW,UACbA,IAAShhB,EAAO,UAAU,uBAAO,OAAO,IAAI,GAC5CA,EAAO,eAAe,MAIlBghB,EAAO,gBAAgB,WACzBhhB,EAAO;AAAA,MAAK;AAAA,MAAe8gB;AAAA,MACflZ,EAAS,WAAWA,EAAS,WAAWA;AAAA,IAAQ,GAI5DoZ,IAAShhB,EAAO,UAElB0hB,IAAWV,EAAOF,CAAI,IAGpBY,MAAa;AAEf,MAAAA,IAAWV,EAAOF,CAAI,IAAIlZ,GAC1B,EAAE5H,EAAO;AAAA,aAEL,OAAO0hB,KAAa,aAEtBA,IAAWV,EAAOF,CAAI,IACpBU,IAAU,CAAC5Z,GAAU8Z,CAAQ,IAAI,CAACA,GAAU9Z,CAAQ,IAE7C4Z,IACTE,EAAS,QAAQ9Z,CAAQ,IAEzB8Z,EAAS,KAAK9Z,CAAQ,GAIxB6Z,IAAIb,EAAiB5gB,CAAM,GACvByhB,IAAI,KAAKC,EAAS,SAASD,KAAK,CAACC,EAAS,QAAQ;AACpD,MAAAA,EAAS,SAAS;AAGlB,UAAIC,IAAI,IAAI,MAAM,iDACED,EAAS,SAAS,MAAM,OAAOZ,CAAI,IAAI,mEAEvB;AACpC,MAAAa,EAAE,OAAO,+BACTA,EAAE,UAAU3hB,GACZ2hB,EAAE,OAAOb,GACTa,EAAE,QAAQD,EAAS,QACnBvB,EAAmBwB,CAAC;AAAA,IAC1B;AAGE,WAAO3hB;AAAA,EACT;AAEA,EAAAsgB,EAAa,UAAU,cAAc,SAAqBQ,GAAMlZ,GAAU;AACxE,WAAO2Z,EAAa,MAAMT,GAAMlZ,GAAU,EAAK;AAAA,EACjD,GAEA0Y,EAAa,UAAU,KAAKA,EAAa,UAAU,aAEnDA,EAAa,UAAU,kBACnB,SAAyBQ,GAAMlZ,GAAU;AACvC,WAAO2Z,EAAa,MAAMT,GAAMlZ,GAAU,EAAI;AAAA,EACpD;AAEA,WAASga,IAAc;AACrB,QAAI,CAAC,KAAK;AAGR,aAFA,KAAK,OAAO,eAAe,KAAK,MAAM,KAAK,MAAM,GACjD,KAAK,QAAQ,IACT,UAAU,WAAW,IAChB,KAAK,SAAS,KAAK,KAAK,MAAM,IAChC,KAAK,SAAS,MAAM,KAAK,QAAQ,SAAS;AAAA,EAErD;AAEA,WAASC,EAAU7hB,GAAQ8gB,GAAMlZ,GAAU;AACzC,QAAI7F,IAAQ,EAAE,OAAO,IAAO,QAAQ,QAAW,QAAQ/B,GAAQ,MAAM8gB,GAAM,UAAUlZ,EAAQ,GACzFka,IAAUF,EAAY,KAAK7f,CAAK;AACpC,WAAA+f,EAAQ,WAAWla,GACnB7F,EAAM,SAAS+f,GACRA;AAAA,EACT;AAEA,EAAAxB,EAAa,UAAU,OAAO,SAAcQ,GAAMlZ,GAAU;AAC1D,WAAA8Y,EAAc9Y,CAAQ,GACtB,KAAK,GAAGkZ,GAAMe,EAAU,MAAMf,GAAMlZ,CAAQ,CAAC,GACtC;AAAA,EACT,GAEA0Y,EAAa,UAAU,sBACnB,SAA6BQ,GAAMlZ,GAAU;AAC3C,WAAA8Y,EAAc9Y,CAAQ,GACtB,KAAK,gBAAgBkZ,GAAMe,EAAU,MAAMf,GAAMlZ,CAAQ,CAAC,GACnD;AAAA,EACb,GAGA0Y,EAAa,UAAU,iBACnB,SAAwBQ,GAAMlZ,GAAU;AACtC,QAAIma,GAAMf,GAAQgB,GAAU/gB,GAAGghB;AAK/B,QAHAvB,EAAc9Y,CAAQ,GAEtBoZ,IAAS,KAAK,SACVA,MAAW;AACb,aAAO;AAGT,QADAe,IAAOf,EAAOF,CAAI,GACdiB,MAAS;AACX,aAAO;AAET,QAAIA,MAASna,KAAYma,EAAK,aAAana;AACzC,MAAI,EAAE,KAAK,iBAAiB,IAC1B,KAAK,UAAU,uBAAO,OAAO,IAAI,KAEjC,OAAOoZ,EAAOF,CAAI,GACdE,EAAO,kBACT,KAAK,KAAK,kBAAkBF,GAAMiB,EAAK,YAAYna,CAAQ;AAAA,aAEtD,OAAOma,KAAS,YAAY;AAGrC,WAFAC,IAAW,IAEN/gB,IAAI8gB,EAAK,SAAS,GAAG9gB,KAAK,GAAGA;AAChC,YAAI8gB,EAAK9gB,CAAC,MAAM2G,KAAYma,EAAK9gB,CAAC,EAAE,aAAa2G,GAAU;AACzD,UAAAqa,IAAmBF,EAAK9gB,CAAC,EAAE,UAC3B+gB,IAAW/gB;AACX;AAAA,QACZ;AAGQ,UAAI+gB,IAAW;AACb,eAAO;AAET,MAAIA,MAAa,IACfD,EAAK,MAAK,IAEVG,EAAUH,GAAMC,CAAQ,GAGtBD,EAAK,WAAW,MAClBf,EAAOF,CAAI,IAAIiB,EAAK,CAAC,IAEnBf,EAAO,mBAAmB,UAC5B,KAAK,KAAK,kBAAkBF,GAAMmB,KAAoBra,CAAQ;AAAA,IACxE;AAEM,WAAO;AAAA,EACb,GAEA0Y,EAAa,UAAU,MAAMA,EAAa,UAAU,gBAEpDA,EAAa,UAAU,qBACnB,SAA4BQ,GAAM;AAChC,QAAIO,GAAWL,GAAQ/f;AAGvB,QADA+f,IAAS,KAAK,SACVA,MAAW;AACb,aAAO;AAGT,QAAIA,EAAO,mBAAmB;AAC5B,aAAI,UAAU,WAAW,KACvB,KAAK,UAAU,uBAAO,OAAO,IAAI,GACjC,KAAK,eAAe,KACXA,EAAOF,CAAI,MAAM,WACtB,EAAE,KAAK,iBAAiB,IAC1B,KAAK,UAAU,uBAAO,OAAO,IAAI,IAEjC,OAAOE,EAAOF,CAAI,IAEf;AAIT,QAAI,UAAU,WAAW,GAAG;AAC1B,UAAIqB,IAAO,OAAO,KAAKnB,CAAM,GACzBtd;AACJ,WAAKzC,IAAI,GAAGA,IAAIkhB,EAAK,QAAQ,EAAElhB;AAE7B,QADAyC,IAAMye,EAAKlhB,CAAC,GACRyC,MAAQ,oBACZ,KAAK,mBAAmBA,CAAG;AAE7B,kBAAK,mBAAmB,gBAAgB,GACxC,KAAK,UAAU,uBAAO,OAAO,IAAI,GACjC,KAAK,eAAe,GACb;AAAA,IACf;AAIM,QAFA2d,IAAYL,EAAOF,CAAI,GAEnB,OAAOO,KAAc;AACvB,WAAK,eAAeP,GAAMO,CAAS;AAAA,aAC1BA,MAAc;AAEvB,WAAKpgB,IAAIogB,EAAU,SAAS,GAAGpgB,KAAK,GAAGA;AACrC,aAAK,eAAe6f,GAAMO,EAAUpgB,CAAC,CAAC;AAI1C,WAAO;AAAA,EACb;AAEA,WAASmhB,EAAWpiB,GAAQ8gB,GAAMuB,GAAQ;AACxC,QAAIrB,IAAShhB,EAAO;AAEpB,QAAIghB,MAAW;AACb,aAAO,CAAA;AAET,QAAIsB,IAAatB,EAAOF,CAAI;AAC5B,WAAIwB,MAAe,SACV,CAAA,IAEL,OAAOA,KAAe,aACjBD,IAAS,CAACC,EAAW,YAAYA,CAAU,IAAI,CAACA,CAAU,IAE5DD,IACLE,EAAgBD,CAAU,IAAIhB,EAAWgB,GAAYA,EAAW,MAAM;AAAA,EAC1E;AAEA,EAAAhC,EAAa,UAAU,YAAY,SAAmBQ,GAAM;AAC1D,WAAOsB,EAAW,MAAMtB,GAAM,EAAI;AAAA,EACpC,GAEAR,EAAa,UAAU,eAAe,SAAsBQ,GAAM;AAChE,WAAOsB,EAAW,MAAMtB,GAAM,EAAK;AAAA,EACrC,GAEAR,EAAa,gBAAgB,SAASkC,GAAS1B,GAAM;AACnD,WAAI,OAAO0B,EAAQ,iBAAkB,aAC5BA,EAAQ,cAAc1B,CAAI,IAE1B2B,EAAc,KAAKD,GAAS1B,CAAI;AAAA,EAE3C,GAEAR,EAAa,UAAU,gBAAgBmC;AACvC,WAASA,EAAc3B,GAAM;AAC3B,QAAIE,IAAS,KAAK;AAElB,QAAIA,MAAW,QAAW;AACxB,UAAIsB,IAAatB,EAAOF,CAAI;AAE5B,UAAI,OAAOwB,KAAe;AACxB,eAAO;AACF,UAAIA,MAAe;AACxB,eAAOA,EAAW;AAAA,IAExB;AAEE,WAAO;AAAA,EACT;AAEA,EAAAhC,EAAa,UAAU,aAAa,WAAsB;AACxD,WAAO,KAAK,eAAe,IAAIJ,EAAe,KAAK,OAAO,IAAI,CAAA;AAAA,EAChE;AAEA,WAASoB,EAAWoB,GAAKxf,GAAG;AAE1B,aADIyf,IAAO,IAAI,MAAMzf,CAAC,GACbjC,IAAI,GAAGA,IAAIiC,GAAG,EAAEjC;AACvB,MAAA0hB,EAAK1hB,CAAC,IAAIyhB,EAAIzhB,CAAC;AACjB,WAAO0hB;AAAA,EACT;AAEA,WAAST,EAAUH,GAAMa,GAAO;AAC9B,WAAOA,IAAQ,IAAIb,EAAK,QAAQa;AAC9B,MAAAb,EAAKa,CAAK,IAAIb,EAAKa,IAAQ,CAAC;AAC9B,IAAAb,EAAK,IAAG;AAAA,EACV;AAEA,WAASQ,EAAgBG,GAAK;AAE5B,aADIG,IAAM,IAAI,MAAMH,EAAI,MAAM,GACrBzhB,IAAI,GAAGA,IAAI4hB,EAAI,QAAQ,EAAE5hB;AAChC,MAAA4hB,EAAI5hB,CAAC,IAAIyhB,EAAIzhB,CAAC,EAAE,YAAYyhB,EAAIzhB,CAAC;AAEnC,WAAO4hB;AAAA,EACT;AAEA,WAASrC,EAAKgC,GAASvT,GAAM;AAC3B,WAAO,IAAI,QAAQ,SAAU4Q,GAASC,GAAQ;AAC5C,eAASgD,EAAc5B,GAAK;AAC1B,QAAAsB,EAAQ,eAAevT,GAAM8T,CAAQ,GACrCjD,EAAOoB,CAAG;AAAA,MAChB;AAEI,eAAS6B,IAAW;AAClB,QAAI,OAAOP,EAAQ,kBAAmB,cACpCA,EAAQ,eAAe,SAASM,CAAa,GAE/CjD,EAAQ,CAAA,EAAG,MAAM,KAAK,SAAS,CAAC;AAAA,MACtC;AAEI,MAAAmD,EAA+BR,GAASvT,GAAM8T,GAAU,EAAE,MAAM,IAAM,GAClE9T,MAAS,WACXgU,EAA8BT,GAASM,GAAe,EAAE,MAAM,GAAI,CAAE;AAAA,IAE1E,CAAG;AAAA,EACH;AAEA,WAASG,EAA8BT,GAASrB,GAAS+B,GAAO;AAC9D,IAAI,OAAOV,EAAQ,MAAO,cACxBQ,EAA+BR,GAAS,SAASrB,GAAS+B,CAAK;AAAA,EAEnE;AAEA,WAASF,EAA+BR,GAASvT,GAAMrH,GAAUsb,GAAO;AACtE,QAAI,OAAOV,EAAQ,MAAO;AACxB,MAAIU,EAAM,OACRV,EAAQ,KAAKvT,GAAMrH,CAAQ,IAE3B4a,EAAQ,GAAGvT,GAAMrH,CAAQ;AAAA,aAElB,OAAO4a,EAAQ,oBAAqB;AAG7C,MAAAA,EAAQ,iBAAiBvT,GAAM,SAASkU,EAAaxC,GAAK;AAGxD,QAAIuC,EAAM,QACRV,EAAQ,oBAAoBvT,GAAMkU,CAAY,GAEhDvb,EAAS+Y,CAAG;AAAA,MAClB,CAAK;AAAA;AAED,YAAM,IAAI,UAAU,wEAAwE,OAAO6B,CAAO;AAAA,EAE9G;;;;AC1dA,MAAMY,KAA6C;AA8B5C,IAAKC,uBAAAA,OACVA,EAAA,gBAAgB,iBAChBA,EAAA,oBAAoB,qBACpBA,EAAA,eAAe,gBAHLA,IAAAA,MAAA,CAAA,CAAA;AA8OZ,MAAMC,IAA6B,CAA2BvhB,OAC3D;AAAA,EACC,aAAaA,MAAU,eAAeA,MAAU,cAAcA,MAAU;AAAA,EACxE,WACEA,MAAU,2BACVA,MAAU,eACVA,MAAU,cACVA,MAAU;AAAA,EACZ,YAAYA,MAAU,kBAAkBA,MAAU;AAAA,EAClD,WAAWA,MAAU,gBAAgBA,MAAU,kBAAkBA,MAAU;AAC7E,IAUWwhB,KAAyB,MAOjC;AACH,QAAM,CAACC,GAA2BC,CAA4B,IAAI3jB,EAAM;AAAA,IACtE;AAAA,EAAA,GAEI,CAAC4jB,GAAgBC,CAAiB,IAAI7jB,EAAM;AAAA,IAChD;AAAA,EAAA,GAGI8jB,IAAgB9jB,EAAM,OAAmB,YAAY,GACrD+jB,IAA4B/jB,EAAM,OAAO,EAAK,GAE9CgkB,IAA6B,CAACC,MAC3B,WAAW,MAAM;AACtB,QAAI,CAACF,EAA0B,SAAS;AACtC,MAAAJ,EAA6B,8BAA8B;AAC3D;AAAA,IACF;AAEA,UAAM,EAAE,aAAAO,EAAA,IAAgBV,EAA2BM,EAAc,OAAO;AACxE,QAAI,CAACI,GAAa;AAChB,MAAAP,EAA6B,0DAA0D;AACvF;AAAA,IACF;AAAA,EACF,GAAGM,KAAmCX,EAA0C;AAGlF,SAAO;AAAA,IACL,2BAAAI;AAAA,IACA,mBAAmB1jB,EAAM;AAAA,MACvB,CAACikB,MAA6C;AAC5C,QAAIL,KACF,aAAaA,CAAc,GAG7BD,EAA6B,IAAI,GACjCE,EAAkBG,EAA2BC,CAA+B,CAAC,GAC7EH,EAAc,UAAU,cACxBC,EAA0B,UAAU;AAAA,MACtC;AAAA,MACA,CAACH,CAAc;AAAA,IAAA;AAAA,IAEjB,mBAAmB5jB,EAAM,YAAY,MAAM;AACzC,MAAI4jB,KACF,aAAaA,CAAc,GAG7BD,EAA6B,IAAI,GACjCE,EAAkB,IAAI,GACtBC,EAAc,UAAU,cACxBC,EAA0B,UAAU;AAAA,IACtC,GAAG,CAACH,CAAc,CAAC;AAAA,IACnB,gCAAgC5jB,EAAM,YAAY,MAAM;AACtD,MAAA2jB,EAA6B,IAAI;AAAA,IACnC,GAAG,CAAA,CAAE;AAAA,IAEL,yBAAyB3jB,EAAM,YAAY,CAACmkB,MAA2B;AACrE,MAAAL,EAAc,UAAUK;AAAA,IAC1B,GAAG,CAAA,CAAE;AAAA,IACL,qCAAqCnkB,EAAM,YAAY,CAACokB,MAAoC;AAC1F,MAAAL,EAA0B,UAAUK;AAAA,IACtC,GAAG,CAAA,CAAE;AAAA,EAAA;AAET;AAMA,SAASC,GACP3B,GACAzgB,GACA;AACA,QAAMqiB,IAAWtkB,EAAM,OAAOiC,CAAK;AACnC,EAAAjC,EAAM,UAAU,MAAM;AACpB,IAAAskB,EAAS,UAAUriB;AAAA,EACrB,GAAG,CAACA,CAAK,CAAC;AAEV,QAAMsiB,IAAqBvkB,EAAM;AAAA,IAC/B,OAAOwkB,MAAyB;AAC9B,YAAM,EAAE,aAAAN,EAAA,IAAgBV,EAA2Bc,EAAS,OAAO;AACnE,UAAI,CAAAJ;AAIJ,eAAO,IAAI,QAAc,CAACnE,GAASC,MAAW;AAC5C,gBAAMyE,IAAsB,CAACxiB,MAAsB;AACjD,kBAAM,EAAE,aAAAiiB,MAAgBV,EAA2BvhB,CAAK;AACxD,YAAKiiB,MAGL3L,EAAA,GACAwH,EAAA;AAAA,UACF,GACM2E,IAAe,MAAM;AACzB,YAAAnM,EAAA,GACAyH,EAAO,IAAI,MAAM,yDAAyD,CAAC;AAAA,UAC7E,GAEMzH,IAAU,MAAM;AACpB,YAAAmK,EAAQ,IAAI,gBAAyB+B,CAAmB,GACxDD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,UACvC;AAEA,UAAAhC,EAAQ,GAAG,gBAAyB+B,CAAmB,GACvDD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,QACpC,CAAC;AAAA,IACH;AAAA,IACA,CAAChC,CAAO;AAAA,EAAA,GAGJiC,IAA4B3kB,EAAM;AAAA,IACtC,OAAOwkB,MAAyB;AAC9B,YAAM,EAAE,WAAAI,EAAA,IAAcpB,EAA2Bc,EAAS,OAAO;AACjE,UAAI,CAAAM;AAIJ,eAAO,IAAI,QAAc,CAAC7E,GAASC,MAAW;AAC5C,gBAAMyE,IAAsB,CAACxiB,MAAsB;AACjD,kBAAM,EAAE,WAAA2iB,MAAcpB,EAA2BvhB,CAAK;AACtD,YAAK2iB,MAGLrM,EAAA,GACAwH,EAAA;AAAA,UACF,GACM2E,IAAe,MAAM;AACzB,YAAAnM,EAAA,GACAyH,EAAO,IAAI,MAAM,gEAAgE,CAAC;AAAA,UACpF,GAEMzH,IAAU,MAAM;AACpB,YAAAmK,EAAQ,IAAI,gBAAyB+B,CAAmB,GACxDD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,UACvC;AAEA,UAAAhC,EAAQ,GAAG,gBAAyB+B,CAAmB,GACvDD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,QACpC,CAAC;AAAA,IACH;AAAA,IACA,CAAChC,CAAO;AAAA,EAAA,GAGJmC,IAAoB7kB,EAAM;AAAA,IAC9B,OAAOwkB,MAAyB;AAC9B,YAAM,EAAE,YAAAM,EAAA,IAAetB,EAA2Bc,EAAS,OAAO;AAClE,UAAI,CAAAQ;AAIJ,eAAO,IAAI,QAAc,CAAC/E,GAASC,MAAW;AAC5C,gBAAMyE,IAAsB,CAACxiB,MAAsB;AACjD,kBAAM,EAAE,YAAA6iB,MAAetB,EAA2BvhB,CAAK;AACvD,YAAK6iB,MAGLvM,EAAA,GACAwH,EAAA;AAAA,UACF,GACM2E,IAAe,MAAM;AACzB,YAAAnM,EAAA,GACAyH,EAAO,IAAI,MAAM,wDAAwD,CAAC;AAAA,UAC5E,GAEMzH,IAAU,MAAM;AACpB,YAAAmK,EAAQ,IAAI,gBAAyB+B,CAAmB,GACxDD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,UACvC;AAEA,UAAAhC,EAAQ,GAAG,gBAAyB+B,CAAmB,GACvDD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,QACpC,CAAC;AAAA,IACH;AAAA,IACA,CAAChC,CAAO;AAAA,EAAA;AAGV,SAAO,EAAE,oBAAA6B,GAAoB,2BAAAI,GAA2B,mBAAAE,EAAA;AAC1D;AAMO,SAASE,GAASC,GAAuC;AAC9D,QAAMC,IAAqBC,GAAA;AAE3B,MADAF,IAAUA,KAAWC,GACjB,CAACD;AACH,UAAM,IAAI;AAAA,MACR;AAAA,IAAA;AAIJ,QAAM;AAAA,IACJ,MAAApiB;AAAA,IACA,UAAU;AAAA,MACR,iCAAAqhB;AAAA,MAEA,2BAAAP;AAAA,MACA,mBAAAyB;AAAA,MACA,mBAAAC;AAAA,MACA,gCAAAC;AAAA,MACA,yBAAAC;AAAA,MACA,qCAAAC;AAAA,IAAA;AAAA,EACF,IACEP,GAEEtC,IAAU1iB,EAAM,QAAQ,MAAM,IAAIwgB,GAAAA,aAAA,GAAqD,EAAE,GAEzFgF,IAAyBvV,GAAsB,EAAE,MAAArN,GAAM,GAEvD6iB,IAAmBzlB,EAAM,QAAQ,MAEnCwlB,EAAuB;AAAA,IACrB,CAAClhB,MACCA,EAAE,SAAS+Y,GAAgB,SAC3B,EAAEH,EAA2B,mBAAmB5Y,EAAE;AAAA,EAAA,KACjD,MAEN,CAACkhB,CAAsB,CAAC,GACrBE,IAAoB1lB,EAAM,QAAQ,MACjCylB,IAIHD,EAAuB;AAAA,IACrB,CAAClhB,MACCA,EAAE,SAAS+Y,GAAgB,SAC3B/Y,EAAE,WAAW4Y,EAA2B,eAAe,MAAMuI,EAAiB;AAAA,EAAA,KAC7E,OAPE,MASR,CAACA,GAAkBD,CAAsB,CAAC,GAGvC,CAACG,GAA4BC,CAA6B,IAAI5lB,EAAM,UAExEylB,KAAA,gBAAAA,EAAkB,eAAc,EAAE;AACpC,EAAAzlB,EAAM,UAAU,MAAM;AACpB,QAAI,CAACylB;AACH;AAGF,UAAMI,IAA0B,CAAChI,MAA6C;AAC5E,MAAA+H,EAA8B/H,CAAU;AAAA,IAC1C;AAEA,WAAA4H,EAAiB,GAAGK,GAAiB,mBAAmBD,CAAuB,GACxE,MAAM;AACX,MAAAJ,EAAiB,IAAIK,GAAiB,mBAAmBD,CAAuB;AAAA,IAClF;AAAA,EACF,GAAG,CAACJ,GAAkB/C,CAAO,CAAC;AAG9B,QAAMnF,IAAc/B,GAAqB,CAAC5L,EAAM,OAAO,QAAQA,EAAM,OAAO,UAAU,GAAG;AAAA,IACvF,MAAAhN;AAAA,IACA,qBAAqB6iB,KAAA,gBAAAA,EAAkB;AAAA,EAAA,CACxC,GACKjI,IAAehC,GAAqB,CAAC5L,EAAM,OAAO,QAAQA,EAAM,OAAO,UAAU,GAAG;AAAA,IACxF,MAAAhN;AAAA,IACA,qBAAqB8iB,KAAA,gBAAAA,EAAmB;AAAA,EAAA,CACzC,GAEK/H,IAAa3d,EAAM;AAAA,IACvB,MACEud,EAAY,KAAK,CAACG,MAAMA,EAAE,WAAW9N,EAAM,OAAO,MAAM,KACxD4N,EAAa,KAAK,CAACE,MAAMA,EAAE,WAAW9N,EAAM,OAAO,MAAM;AAAA,IAC3D,CAAC2N,GAAaC,CAAY;AAAA,EAAA;AAE5B,EAAAxd,EAAM,UAAU,MAAM;AACpB,IAAA0iB,EAAQ,KAAK,iBAA0B/E,CAAU;AAAA,EACnD,GAAG,CAAC+E,GAAS/E,CAAU,CAAC;AAExB,QAAMF,IAAazd,EAAM;AAAA,IACvB,MACEud,EAAY,KAAK,CAACG,MAAMA,EAAE,WAAW9N,EAAM,OAAO,UAAU,KAC5D4N,EAAa,KAAK,CAACE,MAAMA,EAAE,WAAW9N,EAAM,OAAO,UAAU;AAAA,IAC/D,CAAC2N,GAAaC,CAAY;AAAA,EAAA;AAE5B,EAAAxd,EAAM,UAAU,MAAM;AACpB,IAAA0iB,EAAQ,KAAK,qBAA8BjF,CAAU;AAAA,EACvD,GAAG,CAACiF,GAASjF,CAAU,CAAC;AAGxB,QAAM,CAACsI,GAAqBC,CAAsB,IAAIhmB,EAAM,SAAS4C,EAAK,KAAK;AAC/E,EAAA5C,EAAM,UAAU,MAAM;AACpB,UAAMimB,IAA+B,CAACxgB,MAAqC;AACzE,MAAAugB,EAAuBvgB,CAAe;AAAA,IACxC;AAEA,WAAA7C,EAAK,GAAGmI,EAAU,wBAAwBkb,CAA4B,GAC/D,MAAM;AACX,MAAArjB,EAAK,IAAImI,EAAU,wBAAwBkb,CAA4B;AAAA,IACzE;AAAA,EACF,GAAG,CAACrjB,CAAI,CAAC,GAGT5C,EAAM,UAAU,MAAM;AACpB,IAAKylB,KAILJ,EAAA;AAAA,EACF,GAAG,CAACI,CAAgB,CAAC;AAGrB,QAAM,CAACS,GAAgCC,CAAiC,IAAInmB,EAAM,SAEhF,IAAI;AACN,EAAAA,EAAM,UAAU,MAAM;AACpB,QAAI,CAACylB;AACH;AAGF,UAAMW,IAA0B,CAACle,MAAmC;AAClE,MAAIA,EAAY,cAAaud,KAAA,gBAAAA,EAAkB,aAG/CU,EAAkC,mCAAmC;AAAA,IACvE;AAEA,WAAAvjB,EAAK,GAAGmI,EAAU,yBAAyBqb,CAAuB,GAE3D,MAAM;AACX,MAAAxjB,EAAK,IAAImI,EAAU,yBAAyBqb,CAAuB;AAAA,IACrE;AAAA,EACF,GAAG,CAACX,GAAkB7iB,CAAI,CAAC,GAE3B5C,EAAM,UAAU,MAAM;AACpB,IAAI+lB,MAAwBngB,EAAgB,gBAI5CugB,EAAkC,IAAI;AAAA,EACxC,GAAG,CAACJ,CAAmB,CAAC;AAExB,QAAM,CAACM,GAAeC,CAAgB,IAAItmB,EAAM;AAAA,IAC9C,MAAM4C,EAAK,iBAAiB,oBAAoBgN,EAAM,OAAO,UAAU,KAAK;AAAA,EAAA;AAE9E,EAAA5P,EAAM,UAAU,MAAM;AACpB,UAAMumB,IAAuC,MAAM;AACjD,MAAAD,EAAiB1jB,EAAK,iBAAiB,oBAAoBgN,EAAM,OAAO,UAAU,KAAK,IAAI;AAAA,IAC7F,GACM4W,IAAyC,MAAM;AACnD,MAAAF,EAAiB,IAAI;AAAA,IACvB;AAEA,WAAA1jB,EAAK,iBAAiB;AAAA,MACpBkjB,GAAiB;AAAA,MACjBS;AAAA,IAAA,GAEF3jB,EAAK,iBAAiB;AAAA,MACpBkjB,GAAiB;AAAA,MACjBU;AAAA,IAAA,GAEK,MAAM;AACX,MAAA5jB,EAAK,iBAAiB;AAAA,QACpBkjB,GAAiB;AAAA,QACjBS;AAAA,MAAA,GAEF3jB,EAAK,iBAAiB;AAAA,QACpBkjB,GAAiB;AAAA,QACjBU;AAAA,MAAA;AAAA,IAEJ;AAAA,EACF,GAAG,CAAC5jB,EAAK,gBAAgB,CAAC;AAE1B,QAAM6jB,IAAiBzmB,EAAM,QAAQ,MAAM;AACzC,UAAM0mB,IAAU,CAAA;AAChB,WAAIhD,KACFgD,EAAQ,KAAKhD,CAAyB,GAEpCwC,KACFQ,EAAQ,KAAKR,CAA8B,GAEtCQ;AAAA,EACT,GAAG,CAAChD,GAA2BwC,CAA8B,CAAC,GAExDjkB,IAAQjC,EAAM,QAAQ,MAAM;AAChC,QAAIymB,EAAe,SAAS;AAC1B,aAAO;AAGT,QAAIxkB,IAAoB;AAExB,WAAI8jB,MAAwBngB,EAAgB,iBAC1C3D,IAAQ,eAKNokB,MACFpkB,IAAQ,0BAGNwjB,KAAoBE,EAA2BzI,EAA2B,UAAU,MACtFjb,IAAQ0jB,EAA2BzI,EAA2B,UAAU,IAGnEjb;AAAAA,EACT,GAAG;AAAA,IACDwkB;AAAA,IACAV;AAAA,IACAM;AAAA,IACAZ;AAAA,IACAE;AAAA,EAAA,CACD;AAED,EAAA3lB,EAAM,UAAU,MAAM;AACpB,IAAA0iB,EAAQ,KAAK,gBAAyBzgB,CAAK,GAC3CqjB,EAAwBrjB,CAAK;AAAA,EAC/B,GAAG,CAACygB,GAASzgB,CAAK,CAAC,GACnBjC,EAAM,UAAU,MAAM;AACpB,IAAAulB,EAAoCE,MAAqB,IAAI;AAAA,EAC/D,GAAG,CAACA,CAAgB,CAAC;AAGrB,QAAMkB,IAAwB3B,EAAQ,oBAAoB;AAC1D,EAAAhlB,EAAM,UAAU,MAAM;AACpB,QAAI,CAAA2mB;AAIJ,aAAAxB,EAAkBlB,CAA+B,GAC1C,MAAM;AACX,QAAAmB,EAAA;AAAA,MACF;AAAA,EACF,GAAG,CAACuB,GAAuB1C,CAA+B,CAAC;AAE3D,QAAM;AAAA,IACJ,UAAU2C;AAAA,IACV,MAAMC;AAAA,IACN,UAAUC;AAAA,EAAA,IACRhY,GAAmB,EAAE,aAAa2W,KAAoB,QAAW,GAE/DtB,KAA8BnkB,EAAM,QAAQ,MAAM;AACtD,UAAM+mB,IAA2B;AAAA,MAC/B,YAAYpB;AAAA,MAEZ,UAAU;AAAA,QACR,kBAAAF;AAAA,QACA,mBAAAC;AAAA,QACA,SAAAhD;AAAA,MAAA;AAAA,IACF;AAGF,YAAQzgB,GAAA;AAAA,MACN,KAAK;AACH,eAAO;AAAA,UACL,GAAG8kB;AAAA,UACH,UAAU;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UAEV,OAAA9kB;AAAA,UACA,GAAGuhB,EAA2BvhB,CAAK;AAAA,UACnC,gBAAgB;AAAA;AAAA,UAGhB,aAAa;AAAA,UACb,iBAAiB;AAAA,QAAA;AAAA,MAGrB,KAAK;AACH,eAAO;AAAA,UACL,GAAG8kB;AAAA,UACH,UAAU;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UAEV,OAAA9kB;AAAA,UACA,GAAGuhB,EAA2BvhB,CAAK;AAAA,UACnC,gBAAgB;AAAA;AAAA,UAGhB,aAAa;AAAA,UACb,iBAAiB;AAAA,QAAA;AAAA,MAGrB,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,UACL,GAAG8kB;AAAA,UACH,UAAUH;AAAA,UACV,MAAMC;AAAA,UACN,UAAUC;AAAA,UAEV,OAAA7kB;AAAA,UACA,GAAGuhB,EAA2BvhB,CAAK;AAAA,UACnC,gBAAgB;AAAA,UAEhB,aAAa0b;AAAA,UACb,iBAAiBF;AAAA,QAAA;AAAA,MAGrB,KAAK;AACH,eAAO;AAAA,UACL,GAAGsJ;AAAA,UACH,UAAUH;AAAA,UACV,MAAMC;AAAA,UACN,UAAUC;AAAA,UAEV,OAAA7kB;AAAA,UACA,GAAGuhB,EAA2BvhB,CAAK;AAAA,UACnC,gBAAgB;AAAA,UAEhB,aAAa0b;AAAA,UACb,iBAAiBF;AAAA,QAAA;AAAA,MAGrB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,UACL,GAAGsJ;AAAA,UACH,UAAUH;AAAA,UACV,MAAMC;AAAA,UACN,UAAUC;AAAA,UAEV,OAAA7kB;AAAA,UACA,GAAGuhB,EAA2BvhB,CAAK;AAAA,UACnC,gBAAgB;AAAA,UAEhB,aAAa0b;AAAA,UACb,iBAAiBF;AAAA,QAAA;AAAA,MAGrB,KAAK;AACH,eAAO;AAAA,UACL,GAAGsJ;AAAA,UACH,UAAU;AAAA,UACV,MAAM;AAAA,UACN,UAAU;AAAA,UAEV,OAAO;AAAA,UACP,GAAGvD,EAA2B,QAAQ;AAAA,UACtC,gBAAAiD;AAAA;AAAA,UAGA,aAAa;AAAA,UACb,iBAAiB;AAAA,QAAA;AAAA,IACnB;AAAA,EAEN,GAAG;AAAA,IACDG;AAAA,IACAC;AAAA,IACAC;AAAA,IACAnB;AAAA,IACAjD;AAAA,IACA+C;AAAA,IACAxjB;AAAA,IACA0b;AAAA,IACAF;AAAA,EAAA,CACD,GAEK,EAAE,oBAAA8G,GAAoB,2BAAAI,GAA2B,mBAAAE,MACrDR,GAA+B3B,GAASzgB,CAAK,GAEzC+kB,IAAkBhnB,EAAM;AAAA,IAC5B,CAACwkB,MACQ,IAAI,QAAwB,CAACzE,GAASC,MAAW;AACtD,YAAMyE,IAAsB,CAACwC,MAAuC;AAClE,QAAKA,MAGL1O,EAAA,GACAwH,EAAQkH,CAAM;AAAA,MAChB,GACMvC,IAAe,MAAM;AACzB,QAAAnM,EAAA,GACAyH,EAAO,IAAI,MAAM,sDAAsD,CAAC;AAAA,MAC1E,GAEMzH,IAAU,MAAM;AACpB,QAAAmK,EAAQ,IAAI,iBAA0B+B,CAAmB,GACzDD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,MACvC;AAEA,MAAAhC,EAAQ,GAAG,iBAA0B+B,CAAmB,GACxDD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,IACpC,CAAC;AAAA,IAEH,CAAChC,CAAO;AAAA,EAAA,GAGJwE,KAAsBlnB,EAAM;AAAA,IAChC,CAACwkB,MACQ,IAAI,QAAwB,CAACzE,GAASC,MAAW;AACtD,YAAMyE,IAAsB,CAAC0C,MAA2C;AACtE,QAAKA,MAGL5O,EAAA,GACAwH,EAAQoH,CAAU;AAAA,MACpB,GACMzC,IAAe,MAAM;AACzB,QAAAnM,EAAA,GACAyH,EAAO,IAAI,MAAM,0DAA0D,CAAC;AAAA,MAC9E,GAEMzH,IAAU,MAAM;AACpB,QAAAmK,EAAQ,IAAI,qBAA8B+B,CAAmB,GAC7DD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,MACvC;AAEA,MAAAhC,EAAQ,GAAG,qBAA8B+B,CAAmB,GAC5DD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,IACpC,CAAC;AAAA,IAEH,CAAChC,CAAO;AAAA,EAAA;AAGV,SAAO1iB,EAAM,QAAQ,OACZ;AAAA,IACL,GAAGmkB;AAAA,IACH,oBAAAI;AAAA,IACA,2BAAAI;AAAA,IACA,mBAAAE;AAAA,IACA,iBAAAmC;AAAA,IACA,qBAAAE;AAAA,EAAA,IAED;AAAA,IACD/C;AAAA,IACAI;AAAA,IACAI;AAAA,IACAE;AAAA,IACAmC;AAAA,IACAE;AAAA,EAAA,CACD;AACH;AC15BO,IAAKE,uBAAAA,OACVA,EAAA,yBAAyB,0BAMzBA,EAAA,oBAAoB,qBAKpBA,EAAA,kBAAkB,mBAZRA,IAAAA,MAAA,CAAA,CAAA;AAqJZ,SAASC,GAAgCxjB,GAA4BC,GAA4B;AAC/F,QAAMwjB,IAAa,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAKzjB,CAAC,GAAG,GAAG,OAAO,KAAKC,CAAC,CAAC,CAAC;AAIjE,aAAWF,KAAO0jB;AAChB,YAAQ1jB,GAAA;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,YAAIC,EAAED,CAAG,MAAME,EAAEF,CAAG;AAClB,iBAAO;AAET;AAAA,MACF;AAEE,cAAM2jB,IAA8B3jB;AACpC,cAAM,IAAI,MAAM,eAAe2jB,CAAoB,kCAAkC;AAAA,IAAA;AAI3F,SAAO;AACT;AAIA,SAASC,GACP9E,GACAjd,GACA;AACA,QAAMgiB,IAAqBznB,EAAM,OAAOyF,CAAe;AACvD,SAAAzF,EAAM,UAAU,MAAM;AACpB,IAAAynB,EAAmB,UAAUhiB;AAAA,EAC/B,GAAG,CAACA,CAAe,CAAC,GAEazF,EAAM;AAAA,IACrC,OAAOiC,GAA4CuiB,MAAyB;AAC1E,UAAIiD,EAAmB,YAAYxlB;AAInC,eAAO,IAAI,QAAc,CAAC8d,GAASC,MAAW;AAC5C,gBAAM0H,IAAoB,CAACC,MAAkD;AAC3E,YAAIA,MAAa1lB,MAGjBsW,EAAA,GACAwH,EAAA;AAAA,UACF,GACM2E,IAAe,MAAM;AACzB,YAAAnM,EAAA,GACAyH;AAAA,cACE,IAAI;AAAA,gBACF,kDAAkD/d,CAAK;AAAA,cAAA;AAAA,YACzD;AAAA,UAEJ,GAEMsW,IAAU,MAAM;AACpB,YAAAmK,EAAQ,IAAI,0BAAqCgF,CAAiB,GAClElD,KAAA,QAAAA,EAAQ,oBAAoB,SAASE;AAAA,UACvC;AAEA,UAAAhC,EAAQ,GAAG,0BAAqCgF,CAAiB,GACjElD,KAAA,QAAAA,EAAQ,iBAAiB,SAASE;AAAA,QACpC,CAAC;AAAA,IACH;AAAA,IACA,CAAChC,CAAO;AAAA,EAAA;AAIZ;AAIA,SAASkF,GACPC,GACAC,GACA;AACA,QAAMC,IAAiBF,aAAuBG,IAExCC,IAA+BjoB,EAAM;AAAA,IACzC+nB,IAAiBD,IAAsB;AAAA,EAAA;AAGzC,SAAA9nB,EAAM,UAAU,MAAM;AACpB,QAAI,CAAC+nB,GAAgB;AACnB,MAAAE,EAA6B,UAAU;AACvC;AAAA,IACF;AAEA,IACEA,EAA6B,YAAY,QACzCZ,GAAgCY,EAA6B,SAASH,CAAmB,MAK3FG,EAA6B,UAAUH;AAAA,EACzC,GAAG,CAACC,GAAgBD,CAAmB,CAAC,GAEf9nB,EAAM,YAAY,YAAY;AACrD,QAAI+nB,GAAgB;AAClB,UAAI,CAACE,EAA6B;AAChC,cAAM,IAAI;AAAA,UACR;AAAA,QAAA;AAGJ,aAAOJ,EAAY,MAAMI,EAA6B,OAAO;AAAA,IAC/D;AACE,aAAOJ,EAAY,MAAA;AAAA,EAEvB,GAAG,CAACE,GAAgBF,CAAW,CAAC;AAGlC;AAkBO,SAASK,GACdL,GACAxjB,IAAkE,IAChD;AAClB,QAAM,EAAE,MAAM8jB,GAAa,iCAAAlE,GAAiC,GAAGmE,MAAgB/jB,GAEzE6P,IAAkBvH,GAAA,GAClB/J,IAAO5C,EAAM;AAAA,IACjB,MAAMkU,KAAmBiU,KAAe,IAAIje,GAAA;AAAA,IAC5C,CAACgK,GAAiBiU,CAAW;AAAA,EAAA,GAGzBzF,IAAU1iB,EAAM;AAAA,IACpB,MAAM,IAAIwgB,GAAAA,aAAA;AAAA,IACV,CAAA;AAAA,EAAC,GAGG6H,IAAuCroB,EAAM;AAAA,IACjD,CAAoDyF,OACjD;AAAA,MACC,aACEA,MAAoBG,EAAgB,aACpCH,MAAoBG,EAAgB,gBACpCH,MAAoBG,EAAgB;AAAA,IAAA;AAAA,IAS1C,CAAA;AAAA,EAAC,GAGG,CAACmgB,GAAqBC,CAAsB,IAAIhmB,EAAM,SAAS4C,EAAK,KAAK;AAC/E,EAAA5C,EAAM,UAAU,MAAM;AACpB,UAAMimB,IAA+B,CAACxgB,MAAqC;AACzE,MAAAugB,EAAuBvgB,CAAe;AAAA,IACxC;AAEA,WAAA7C,EAAK,GAAGmI,EAAU,wBAAwBkb,CAA4B,GAC/D,MAAM;AACX,MAAArjB,EAAK,IAAImI,EAAU,wBAAwBkb,CAA4B;AAAA,IACzE;AAAA,EACF,GAAG,CAACrjB,CAAI,CAAC,GAET5C,EAAM,UAAU,MAAM;AACpB,UAAMsoB,IAA0B,OAAOra,MAAiB;AACtD,MAAAyU,EAAQ,KAAK,qBAAgCzU,CAAK;AAAA,IACpD;AAEA,WAAArL,EAAK,GAAGmI,EAAU,mBAAmBud,CAAuB,GACrD,MAAM;AACX,MAAA1lB,EAAK,IAAImI,EAAU,mBAAmBud,CAAuB;AAAA,IAC/D;AAAA,EACF,GAAG,CAAC1lB,GAAM8f,CAAO,CAAC,GAElB1iB,EAAM,UAAU,MAAM;AACpB,UAAM2K,IAAwB,OAAOsD,MAAiB;AACpD,MAAAyU,EAAQ,KAAK,mBAA8BzU,CAAK;AAAA,IAClD;AAEA,WAAArL,EAAK,GAAGmI,EAAU,iBAAiBJ,CAAqB,GACjD,MAAM;AACX,MAAA/H,EAAK,IAAImI,EAAU,iBAAiBJ,CAAqB;AAAA,IAC3D;AAAA,EACF,GAAG,CAAC/H,GAAM8f,CAAO,CAAC;AAElB,QAAM,EAAE,kBAAAzX,EAAA,IAAqBD,GAAoB,EAAE,MAAApI,GAAM,GACnD2lB,IAAoBtd,EAAiB,oBAAoB2E,EAAM,OAAO,MAAM,GAC5E4Y,IAAcxoB,EAAM,QAAQ,MAAM;AACtC,QAAKuoB;AAGL,aAAO;AAAA,QACL,QAAQ3Y,EAAM,OAAO;AAAA,QACrB,aAAa3E;AAAA,QACb,aAAasd;AAAA,MAAA;AAAA,EAEjB,GAAG,CAACtd,GAAkBsd,CAAiB,CAAC,GAClCE,IAAwBxd,EAAiB,oBAAoB2E,EAAM,OAAO,UAAU,GACpF8Y,IAAkB1oB,EAAM,QAAQ,MAAM;AAC1C,QAAKyoB;AAGL,aAAO;AAAA,QACL,QAAQ7Y,EAAM,OAAO;AAAA,QACrB,aAAa3E;AAAA,QACb,aAAawd;AAAA,MAAA;AAAA,EAEjB,GAAG,CAACxd,GAAkBwd,CAAqB,CAAC,GACtCE,IAAyB1d,EAAiB,oBAAoB2E,EAAM,OAAO,WAAW,GACtFgZ,IAAmB5oB,EAAM,QAAQ,MAAM;AAC3C,QAAK2oB;AAGL,aAAO;AAAA,QACL,QAAQ/Y,EAAM,OAAO;AAAA,QACrB,aAAa3E;AAAA,QACb,aAAa0d;AAAA,MAAA;AAAA,EAEjB,GAAG,CAAC1d,GAAkB0d,CAAsB,CAAC,GAEvC;AAAA,IACJ,2BAAAjF;AAAA,IACA,mBAAAyB;AAAA,IACA,mBAAAC;AAAA,IACA,gCAAAC;AAAA,IACA,yBAAAC;AAAA,IACA,qCAAAC;AAAA,EAAA,IACE9B,GAAA,GAEEoF,IAAgD7oB,EAAM;AAAA,IAC1D,OAAO;AAAA,MACL,SAAA0iB;AAAA,MACA,aAAAmF;AAAA,MACA,iCAAA5D;AAAA,MAEA,2BAAAP;AAAA,MACA,mBAAAyB;AAAA,MACA,mBAAAC;AAAA,MACA,gCAAAC;AAAA,MACA,yBAAAC;AAAA,MACA,qCAAAC;AAAA,IAAA;AAAA,IAEF;AAAA,MACE7C;AAAA,MACAuB;AAAA,MACA4D;AAAA,MACAnE;AAAA,MACAyB;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,IAAA;AAAA,EACF,GAGIuD,IAAoB9oB,EAAM,QAAQ,MAGR;AAC9B,UAAM+mB,IAA6B;AAAA,MACjC,MAAAnkB;AAAA,MACA,UAAUimB;AAAA,IAAA;AAGZ,YAAQ9C,GAAA;AAAA,MACN,KAAKngB,EAAgB;AACnB,eAAO;AAAA,UACL,GAAGmhB;AAAA,UAEH,iBAAiBnhB,EAAgB;AAAA,UACjC,GAAGyiB,EAAqCziB,EAAgB,UAAU;AAAA,UAElE,OAAO;AAAA,YACL,aAAa;AAAA,YACb,iBAAiB;AAAA,YACjB,kBAAkB;AAAA,UAAA;AAAA,QACpB;AAAA,MAGJ,KAAKA,EAAgB;AAAA,MACrB,KAAKA,EAAgB;AAAA,MACrB,KAAKA,EAAgB;AACnB,eAAO;AAAA,UACL,GAAGmhB;AAAA,UAEH,iBAAiBhB;AAAA,UACjB,GAAGsC,EAAqCtC,CAAmB;AAAA,UAE3D,OAAO;AAAA,YACL,aAAayC;AAAA,YACb,iBAAiBE;AAAA,YACjB,kBAAkBE;AAAA,UAAA;AAAA,QACpB;AAAA,MAGJ,KAAKhjB,EAAgB;AACnB,eAAO;AAAA,UACL,GAAGmhB;AAAA,UAEH,iBAAiBnhB,EAAgB;AAAA,UACjC,GAAGyiB,EAAqCziB,EAAgB,YAAY;AAAA,UAEpE,OAAO;AAAA,YACL,aAAa;AAAA,YACb,iBAAiB;AAAA,YACjB,kBAAkB;AAAA,UAAA;AAAA,QACpB;AAAA,IACF;AAAA,EAEN,GAAG;AAAA,IACDijB;AAAA,IACAjmB;AAAA,IACAmjB;AAAA,IACAyC;AAAA,IACAE;AAAA,IACAL;AAAA,EAAA,CACD;AACD,EAAAroB,EAAM,UAAU,MAAM;AACpB,IAAA0iB,EAAQ,KAAK,0BAAqCoG,EAAkB,eAAe;AAAA,EACrF,GAAG,CAACpG,GAASoG,EAAkB,eAAe,CAAC;AAE/C,QAAMC,IAA2BvB;AAAA,IAC/B9E;AAAA,IACAoG,EAAkB;AAAA,EAAA,GAGdvE,IAAqBvkB,EAAM;AAAA,IAC/B,OAAOwkB,MACEuE;AAAA,MACLnjB,EAAgB;AAAA,MAChB4e;AAAA,IAAA;AAAA,IAGJ,CAACuE,CAAwB;AAAA,EAAA,GAGrBC,IAAwBhpB,EAAM;AAAA,IAClC,OAAOwkB,MACEuE,EAAyBnjB,EAAgB,cAAc4e,CAAM;AAAA,IAEtE,CAACuE,CAAwB;AAAA,EAAA,GAGrB3L,IAAQ2H;AAAA,IACZ/kB,EAAM;AAAA,MACJ,OAAO;AAAA,QACL,iBAAiB8oB,EAAkB;AAAA,QACnC,MAAAlmB;AAAA,QACA,UAAUimB;AAAA,MAAA;AAAA,MAEZ,CAACC,GAAmBlmB,GAAMimB,CAAe;AAAA,IAAA;AAAA,EAC3C,GAGII,IAAmBrB,GAA2BC,GAAaO,CAAW,GAEtEc,IAAQlpB,EAAM;AAAA,IAClB,OAAOoJ,IAAwC,CAAA,MAAO;;AACpD,YAAM;AAAA,QACJ,QAAAob;AAAA,QACA,QAAA2E,IAAS,EAAE,YAAY,EAAE,SAAS,IAAM,gBAAgB,EAAE,kBAAkB,GAAA,IAAO;AAAA,QACnF,oBAAAC;AAAA,MAAA,IACEhgB;AAEJ,YAAM4f,EAAsBxE,CAAM;AAElC,YAAM6E,IAAgB,MAAM;AAC1B,QAAAzmB,EAAK,WAAA;AAAA,MACP;AACA,MAAA4hB,KAAA,QAAAA,EAAQ,iBAAiB,SAAS6E;AAElC,UAAIC,IAAuB;AAC3B,YAAM,QAAQ,IAAI;AAAA,QAChBL,IAAmB,KAAK,CAAC,EAAE,WAAA/f,IAAW,kBAAAqgB,SAAuB;;AAI3D,iBAAAD,OADExiB,MAAAF,KAF8B4iB,GAAmBD,EAAgB,EAEzC,eAAxB,gBAAA3iB,GAAoC,WAApC,gBAAAE,GAA4C,WAAU,KACI,GAErDlE,EAAK,QAAQsG,IAAWqgB,IAAkBH,EAAkB;AAAA,QACrE,CAAC;AAAA;AAAA,SAGDxiB,IAAAuiB,EAAO,eAAP,QAAAviB,EAAmB,UACfhE,EAAK,iBAAiB;AAAA,UACpB;AAAA,UACA;AAAA,YACAkE,IAAAqiB,EAAO,eAAP,gBAAAriB,EAAmB,mBAAkB,CAAA;AAAA,QAAC,IAExC,QAAQ,QAAA;AAAA,SACZD,IAAAsiB,EAAO,WAAP,QAAAtiB,EAAe,UACXjE,EAAK,iBAAiB;AAAA,UACpB;AAAA,UACA;AAAA,YACAoE,IAAAmiB,EAAO,WAAP,gBAAAniB,EAAe,mBAAkB,CAAA;AAAA,QAAC,IAEpC,QAAQ,QAAA;AAAA,SACZD,IAAAoiB,EAAO,gBAAP,QAAApiB,EAAoB,UAChBnE,EAAK,iBAAiB;AAAA,UACpB;AAAA,UACA;AAAA,YACA6mB,KAAAN,EAAO,gBAAP,gBAAAM,GAAoB,mBAAkB,CAAA;AAAA,QAAC,IAEzC,QAAQ,QAAA;AAAA,MAAQ,CACrB,GAED,MAAMlF,EAAmBC,CAAM,GAC3B8E,KACF,MAAMlM,EAAM,mBAAmBoH,CAAM,GAGvCA,KAAA,QAAAA,EAAQ,oBAAoB,SAAS6E;AAAA,IACvC;AAAA,IACA,CAACzmB,GAAMomB,GAAuBC,GAAkB1E,GAAoBnH,EAAM,kBAAkB;AAAA,EAAA,GAGxFsM,KAAM1pB,EAAM,YAAY,YAAY;AACxC,UAAM4C,EAAK,WAAA;AAAA,EACb,GAAG,CAACA,CAAI,CAAC,GAEH+mB,IAAoB3pB,EAAM,YAAY,YAAY;AACtD,UAAM4pB,IAAc,MAAMX,EAAA;AAC1B,UAAMrmB,EAAK,kBAAkBgnB,EAAY,WAAWA,EAAY,gBAAgB;AAAA,EAClF,GAAG,CAACX,GAAkBrmB,CAAI,CAAC;AAC3B,SAAA5C,EAAM;AAAA,IACJ,MAAM;AACJ,MAAA2pB,EAAA,EAAoB,MAAM,CAACvI,MAAQ;AAEjC,gBAAQ,KAAK,2CAA2CA,CAAG;AAAA,MAC7D,CAAC;AAAA,IACH;AAAA,IACA;AAAA;AAAA,IAAA;AAAA,EAEA,GAGKphB,EAAM;AAAA,IACX,OAAO;AAAA,MACL,GAAG8oB;AAAA,MAEH,oBAAAvE;AAAA,MACA,uBAAAyE;AAAA,MAEA,mBAAAW;AAAA,MACA,OAAAT;AAAA,MACA,KAAAQ;AAAA,IAAA;AAAA,IAEF,CAACZ,GAAmBvE,GAAoByE,GAAuBW,GAAmBT,GAAOQ,EAAG;AAAA,EAAA;AAEhG;AC7nBO,SAASG,GAMdC,GACAnjB,GACAojB,GACAC,GACA;AACA,QAAMC,IAAWjqB,EAAM,QAAQ,MAAM,MAAM;AAAA,EAAC,GAAG,CAAA,CAAE,GAC3CkqB,IAAkBlqB,EAAM,YAAY+pB,KAAaE,GAAUD,KAAgB,EAAE,GAC7E7pB,IAAW6pB,IAAeE,IAAkBH,GAE5CrH,IAAU1iB,EAAM,QAAQ,MACvB8pB,IAGD,cAAcA,IACTA,EAAS,SAAS,UAEpBA,IALE,MAMR,CAACA,CAAQ,CAAC;AAEb,EAAA9pB,EAAM,UAAU,MAAM;AACpB,QAAI,GAAC0iB,KAAW,CAACviB;AAGjB,aAAAuiB,EAAQ,GAAG/b,GAAOxG,CAAQ,GACnB,MAAM;AACX,QAAAuiB,EAAQ,IAAI/b,GAAOxG,CAAQ;AAAA,MAC7B;AAAA,EACF,GAAG,CAACuiB,GAAS/b,GAAOxG,CAAQ,CAAC;AAC/B;ACLO,IAAKgqB,uBAAAA,OAKVA,EAAA,kBAAkB,mBALRA,IAAAA,MAAA,CAAA,CAAA;AAcL,SAASC,GAAmBpF,GAAsD;AACvF,QAAM,EAAE,MAAApiB,EAAA,IAASynB,GAAiBrF,CAAO,GAEnCtC,IAAU1iB,EAAM;AAAA,IACpB,MAAM,IAAIwgB,GAAAA,aAAA;AAAA,IACV,CAAA;AAAA,EAAC,GAGGpD,IAAQ2H,GAASC,CAAO,GAExBsF,IAAwCnM,GAAkB,EAAE,MAAAvb,GAAM,GAClE2nB,IAAcvqB,EAAM,QAAQ,OAAO,EAAE,MAAA4C,MAAS,CAACA,CAAI,CAAC,GACpD4nB,IAAO1T,GAAQyT,CAAW,GAE1BE,IAEFzqB,EAAM,QAAQ,MACTsqB,EAAe,IAAI,CAACI,MAAkB;;AAC3C,YAAQA,EAAc,gBAAgB,UAAA;AAAA,MACpC,KAAK9nB,EAAK,iBAAiB;AACzB,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS8nB,EAAc;AAAA,UAEvB,IAAIA,EAAc,WAAW;AAAA,UAC7B,WAAWA,EAAc,WAAW;AAAA,UACpC,MAAM9nB,EAAK;AAAA,QAAA;AAAA,MAGf,OAAKgE,IAAAwW,EAAM,SAAS,qBAAf,gBAAAxW,EAAiC;AAAA,MACtC,OAAKE,IAAAsW,EAAM,SAAS,sBAAf,gBAAAtW,EAAkC;AACrC,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS4jB,EAAc;AAAA,UAEvB,IAAIA,EAAc,WAAW;AAAA,UAC7B,WAAWA,EAAc,WAAW;AAAA,UACpC,QACE7jB,IAAAuW,EAAM,SAAS,qBAAf,gBAAAvW,EAAiC,cAAa6jB,EAAc,gBAAgB,WACxEtN,EAAM,SAAS,mBACfA,EAAM,SAAS;AAAA,QAAA;AAAA,MAGzB;AAKE,eAAO;AAAA,UACL,MAAM;AAAA,UACN,SAASsN,EAAc;AAAA,UAEvB,IAAIA,EAAc,WAAW;AAAA,UAC7B,WAAWA,EAAc,WAAW;AAAA,UACpC,MAAM,MAAM,KAAK9nB,EAAK,mBAAmB,OAAA,CAAQ,EAAE;AAAA,YACjD,CAAC0B,MAAMA,EAAE,aAAaomB,EAAc,gBAAgB;AAAA,UAAA;AAAA,QACtD;AAAA,IACF;AAAA,EAEN,CAAC,GACA,CAACJ,GAAgB1nB,CAAI,CAAC,GAEnB+nB,IAAmB3qB,EAAM,QAAQ,MACE,CAAC,GAAGyqB,GAAuB,GAAGD,EAAK,YAAY,GAErF,CAACC,GAAuBD,EAAK,YAAY,CAAC,GAEvCI,IAAiC5qB,EAAM,OAAO,oBAAI,KAAkC,GACpF6qB,IAAyB7qB,EAAM,QAAQ,MAAM;AACjD,UAAMwf,wBAAU,KAAA;AAChB,eAAWla,KAAWqlB;AACpB,MAAIC,EAA+B,QAAQ,IAAItlB,EAAQ,EAAE,KAIzDslB,EAA+B,QAAQ,IAAItlB,EAAQ,IAAIka,CAAG;AAG5D,WAAOmL,EAAiB,KAAK,CAAC9mB,GAAGC,MAAM;AACrC,YAAMgnB,IAAmBF,EAA+B,QAAQ,IAAI/mB,EAAE,EAAE,GAClEknB,IAAmBH,EAA+B,QAAQ,IAAI9mB,EAAE,EAAE;AACxE,aAAI,OAAOgnB,IAAqB,OAAe,OAAOC,IAAqB,MAClE,IAGFD,EAAiB,YAAYC,EAAiB,QAAA;AAAA,IACvD,CAAC;AAAA,EACH,GAAG,CAACJ,CAAgB,CAAC,GAEfK,IAAkChrB,EAAM,OAAO,oBAAI,KAAK;AAC9D,SAAAA,EAAM,UAAU,MAAM;AACpB,eAAWsF,KAAWulB;AACpB,MAAIG,EAAgC,QAAQ,IAAI1lB,EAAQ,EAAE,MAI1D0lB,EAAgC,QAAQ,IAAI1lB,EAAQ,EAAE,GACtDod,EAAQ,KAAK,mBAA+Bpd,CAAO;AAAA,EAEvD,GAAG,CAACulB,CAAsB,CAAC,GAEpB7qB,EAAM;AAAA,IACX,OAAO;AAAA,MACL,UAAU6qB;AAAA,MACV,MAAML,EAAK;AAAA,MACX,WAAWA,EAAK;AAAA,MAChB,UAAU,EAAE,SAAA9H,EAAA;AAAA,IAAQ;AAAA,IAEtB,CAACmI,GAAwBL,EAAK,MAAMA,EAAK,SAAS;AAAA,EAAA;AAEtD;","x_google_ignoreList":[4,57]}