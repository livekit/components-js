{"version":3,"file":"shared-BGiZtWPs.js","sources":["../src/context/session-context.ts","../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useDataChannel.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useToken.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts","../src/hooks/useSequentialRoomConnectDisconnect.ts","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/hooks/useAgent.ts","../src/hooks/useSession.ts","../src/hooks/useEvents.ts","../src/hooks/useSessionMessages.ts"],"sourcesContent":["import * as React from 'react';\r\n\r\nimport { UseSessionReturn } from '../hooks/useSession';\r\n\r\n/** @internal */\r\nexport const SessionContext = React.createContext<UseSessionReturn | undefined>(undefined);\r\n\r\n/**\r\n * Ensures that a session is provided via context.\r\n * If no session is provided, an error is thrown.\r\n * @beta\r\n */\r\nexport function useSessionContext() {\r\n  const ctx = React.useContext(SessionContext);\r\n  if (!ctx) {\r\n    throw Error('tried to access session context outside of SessionProvider component');\r\n  }\r\n  return ctx;\r\n}\r\n\r\n/**\r\n * Returns the session context if it exists, otherwise undefined.\r\n * @beta\r\n */\r\nexport function useMaybeSessionContext() {\r\n  return React.useContext(SessionContext);\r\n}\r\n\r\n/**\r\n * Ensures that a session is provided, either via context or explicitly as a parameter.\r\n * If no session is provided, an error is thrown.\r\n * @beta\r\n */\r\nexport function useEnsureSession(session?: UseSessionReturn) {\r\n  const context = useMaybeSessionContext();\r\n  const r = session ?? context;\r\n  if (!r) {\r\n    throw new Error(\r\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\r\n    );\r\n  }\r\n  return r;\r\n}\r\n","import type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\r\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\r\n * `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useAudioPlayback(room?: Room): {\r\n  canPlayAudio: boolean;\r\n  startAudio: () => Promise<void>;\r\n} {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const startAudio = React.useCallback(async () => {\r\n    await roomEnsured.startAudio();\r\n  }, [roomEnsured]);\r\n\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  return { canPlayAudio, startAudio };\r\n}\r\n","import { setupClearPinButton } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport type { ClearPinButtonProps } from '../components';\r\n\r\n/**\r\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\r\n * or your custom implementation of it component. It adds the `onClick` handler\r\n * to signal the `LayoutContext` that the tile in focus should be cleared.\r\n * @public\r\n */\r\nexport function useClearPinButton(props: ClearPinButtonProps) {\r\n  const { state, dispatch } = useLayoutContext().pin;\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className } = setupClearPinButton();\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      disabled: !state?.length,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'clear_pin' });\r\n      },\r\n    });\r\n    return mergedProps;\r\n  }, [props, dispatch, state]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import type { ReceivedDataMessage } from '@livekit/components-core';\r\nimport { setupDataMessageHandler } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { DataPublishOptions } from 'livekit-client';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\r\n  isSending: boolean;\r\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\r\n  message: ReceivedDataMessage<T> | undefined;\r\n};\r\n\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\r\n *\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants via the 'chat' topic.\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n *\r\n * @example\r\n * ```tsx\r\n * // Receive all messages (no topic filtering)\r\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topic: T,\r\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\r\n): UseDataChannelReturnType<T>;\r\n\r\n/**\r\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\r\n *\r\n * @public\r\n */\r\nexport function useDataChannel(\r\n  onMessage?: (msg: ReceivedDataMessage) => void,\r\n): UseDataChannelReturnType;\r\n/**\r\n * @internal\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\r\n  callback?: (msg: ReceivedDataMessage<T>) => void,\r\n) {\r\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\r\n\r\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\r\n  const room = useRoomContext();\r\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\r\n    () => setupDataMessageHandler(room, topic, onMessage),\r\n    [room, topic, onMessage],\r\n  );\r\n\r\n  const message = useObservableState(messageObservable, undefined);\r\n  const isSending = useObservableState(isSendingObservable, false);\r\n\r\n  return {\r\n    message,\r\n    send,\r\n    isSending,\r\n  };\r\n}\r\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\r\nimport type { DisconnectReason } from 'livekit-client';\r\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { HTMLAttributes } from 'react';\r\n\r\nimport type { LiveKitRoomProps } from '../components';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { roomOptionsStringifyReplacer } from '../utils';\r\n\r\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\r\n  connect: true,\r\n  audio: false,\r\n  video: false,\r\n};\r\n\r\n/**\r\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\r\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { room, htmlProps } = useLiveKitRoom();\r\n * return <div {...htmlProps}>...</div>;\r\n * ```\r\n * @public\r\n */\r\nexport function useLiveKitRoom<T extends HTMLElement>(\r\n  props: LiveKitRoomProps,\r\n): {\r\n  room: Room | undefined;\r\n  htmlProps: HTMLAttributes<T>;\r\n} {\r\n  const {\r\n    token,\r\n    serverUrl,\r\n    options,\r\n    room: passedRoom,\r\n    connectOptions,\r\n    connect,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMediaDeviceFailure,\r\n    onEncryptionError,\r\n    simulateParticipants,\r\n    ...rest\r\n  } = { ...defaultRoomProps, ...props };\r\n  if (options && passedRoom) {\r\n    log.warn(\r\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\r\n    );\r\n  }\r\n\r\n  const [room, setRoom] = React.useState<Room | undefined>();\r\n\r\n  const shouldConnect = React.useRef(connect);\r\n\r\n  React.useEffect(() => {\r\n    setRoom(passedRoom ?? new Room(options));\r\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\r\n\r\n  const htmlProps = React.useMemo(() => {\r\n    const { className } = setupLiveKitRoom();\r\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\r\n  }, [rest]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    const onSignalConnected = () => {\r\n      const localP = room.localParticipant;\r\n\r\n      log.debug('trying to publish local tracks');\r\n      Promise.all([\r\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\r\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\r\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\r\n      ]).catch((e) => {\r\n        log.warn(e);\r\n        onError?.(e as Error);\r\n      });\r\n    };\r\n\r\n    const handleMediaDeviceError = (e: Error, kind?: MediaDeviceKind) => {\r\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\r\n      onMediaDeviceFailure?.(mediaDeviceFailure, kind);\r\n    };\r\n    const handleEncryptionError = (e: Error) => {\r\n      onEncryptionError?.(e);\r\n    };\r\n    const handleDisconnected = (reason?: DisconnectReason) => {\r\n      onDisconnected?.(reason);\r\n    };\r\n    const handleConnected = () => {\r\n      onConnected?.();\r\n    };\r\n\r\n    room\r\n      .on(RoomEvent.SignalConnected, onSignalConnected)\r\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\r\n      .on(RoomEvent.Disconnected, handleDisconnected)\r\n      .on(RoomEvent.Connected, handleConnected);\r\n\r\n    return () => {\r\n      room\r\n        .off(RoomEvent.SignalConnected, onSignalConnected)\r\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\r\n        .off(RoomEvent.Disconnected, handleDisconnected)\r\n        .off(RoomEvent.Connected, handleConnected);\r\n    };\r\n  }, [\r\n    room,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onError,\r\n    onEncryptionError,\r\n    onMediaDeviceFailure,\r\n    onConnected,\r\n    onDisconnected,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n\r\n    if (simulateParticipants) {\r\n      room.simulateParticipants({\r\n        participants: {\r\n          count: simulateParticipants,\r\n        },\r\n        publish: {\r\n          audio: true,\r\n          useRealTracks: true,\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (connect) {\r\n      shouldConnect.current = true;\r\n      log.debug('connecting');\r\n      if (!token) {\r\n        log.debug('no token yet');\r\n        return;\r\n      }\r\n      if (!serverUrl) {\r\n        log.warn('no livekit url provided');\r\n        onError?.(Error('no livekit url provided'));\r\n        return;\r\n      }\r\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\r\n        log.warn(e);\r\n        if (shouldConnect.current === true) {\r\n          onError?.(e as Error);\r\n        }\r\n      });\r\n    } else {\r\n      log.debug('disconnecting because connect is false');\r\n      shouldConnect.current = false;\r\n      room.disconnect();\r\n    }\r\n  }, [\r\n    connect,\r\n    token,\r\n    JSON.stringify(connectOptions),\r\n    room,\r\n    onError,\r\n    serverUrl,\r\n    simulateParticipants,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    return () => {\r\n      log.info('disconnecting on onmount');\r\n      room.disconnect();\r\n    };\r\n  }, [room]);\r\n\r\n  return { room, htmlProps };\r\n}\r\n","import { participantInfoObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { identity, name, metadata } = useParticipantInfo({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantInfoOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\r\n  let p = useMaybeParticipantContext();\r\n  if (props.participant) {\r\n    p = props.participant;\r\n  }\r\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\r\n  const { identity, name, metadata } = useObservableState(infoObserver, {\r\n    name: p?.name,\r\n    identity: p?.identity,\r\n    metadata: p?.metadata,\r\n  });\r\n\r\n  return { identity, name, metadata };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\n\r\n/**\r\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const permissions = useParticipantPermissions({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantPermissionsOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantPermissions(\r\n  options: UseParticipantPermissionsOptions = {},\r\n): ParticipantPermission | undefined {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\r\n  const permissions = useObservableState(permissionObserver, p.permissions);\r\n  return permissions;\r\n}\r\n","import { connectedParticipantsObserver } from '@livekit/components-core';\r\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useRemoteParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\r\n\r\n  React.useEffect(() => {\r\n    const listener = connectedParticipantsObserver(room, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n    }).subscribe(setParticipants);\r\n    return () => listener.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\r\n  return participants;\r\n}\r\n","import type { Room, RoomEvent } from 'livekit-client';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipants(options: UseParticipantsOptions = {}) {\r\n  const remoteParticipants = useRemoteParticipants(options);\r\n  const { localParticipant } = useLocalParticipant(options);\r\n\r\n  return React.useMemo(\r\n    () => [localParticipant, ...remoteParticipants],\r\n    [localParticipant, remoteParticipants],\r\n  );\r\n}\r\n","import {\r\n  type ParticipantIdentifier,\r\n  connectedParticipantObserver,\r\n  participantByIdentifierObserver,\r\n} from '@livekit/components-core';\r\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\r\n   */\r\n  updateOnlyOn?: ParticipantEvent[];\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identifier: ParticipantIdentifier,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant('Russ');\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identity: string,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\nexport function useRemoteParticipant(\r\n  identityOrIdentifier: string | ParticipantIdentifier,\r\n  options: UseRemoteParticipantOptions = {},\r\n): RemoteParticipant | undefined {\r\n  const room = useRoomContext();\r\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (typeof identityOrIdentifier === 'string') {\r\n      return connectedParticipantObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    } else {\r\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    }\r\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\r\n\r\n  // Using `wrapperParticipant` to ensure a new object reference,\r\n  // triggering a re-render when the participant events fire.\r\n  const [participantWrapper, setParticipantWrapper] = React.useState({\r\n    p: undefined as RemoteParticipant | undefined,\r\n  });\r\n  React.useEffect(() => {\r\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\r\n    return () => listener.unsubscribe();\r\n  }, [observable]);\r\n\r\n  return participantWrapper.p;\r\n}\r\n","import { roomInfoObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\r\n * @remarks\r\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { name, metadata } = useRoomInfo();\r\n * ```\r\n * @public\r\n */\r\nexport interface UseRoomInfoOptions {\r\n  room?: Room;\r\n}\r\n\r\n/** @public */\r\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\r\n  const { name, metadata } = useObservableState(infoObserver, {\r\n    name: room.name,\r\n    metadata: room.metadata,\r\n  });\r\n\r\n  return { name, metadata };\r\n}\r\n","import { activeSpeakerObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { Room } from 'livekit-client';\r\n\r\n/** @public */\r\nexport type UseSpeakingParticipantsOptions = {\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\r\n *\r\n * @example\r\n * ```tsx\r\n * const activeSpeakers = useSpeakingParticipants();\r\n * ```\r\n * @public\r\n */\r\nexport function useSpeakingParticipants(options?: UseSpeakingParticipantsOptions) {\r\n  const ensuredRoom = useEnsureRoom(options?.room);\r\n\r\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(ensuredRoom), [ensuredRoom]);\r\n  const activeSpeakers = useObservableState(speakerObserver, ensuredRoom.activeSpeakers);\r\n  return activeSpeakers;\r\n}\r\n","import { sortParticipants } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\r\n\r\n/**\r\n * The `useSortedParticipants` hook returns the participants sorted by importance.\r\n * @public\r\n */\r\nexport function useSortedParticipants(participants: Array<Participant>) {\r\n  const [sortedParticipants, setSortedParticipants] = React.useState(\r\n    sortParticipants(participants),\r\n  );\r\n  const activeSpeakers = useSpeakingParticipants();\r\n\r\n  React.useEffect(() => {\r\n    setSortedParticipants(sortParticipants(participants));\r\n  }, [activeSpeakers, participants]);\r\n  return sortedParticipants;\r\n}\r\n","import { log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UserInfo {\r\n  identity?: string;\r\n  name?: string;\r\n  metadata?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface UseTokenOptions {\r\n  userInfo?: UserInfo;\r\n}\r\n\r\n/**\r\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\r\n *\r\n * @example\r\n * ```tsx\r\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\r\n * ```\r\n * @public */\r\nexport function useToken(\r\n  tokenEndpoint: string | undefined,\r\n  roomName: string,\r\n  options: UseTokenOptions = {},\r\n) {\r\n  const [token, setToken] = React.useState<string | undefined>(undefined);\r\n\r\n  React.useEffect(() => {\r\n    if (tokenEndpoint === undefined) {\r\n      throw Error('token endpoint needs to be defined');\r\n    }\r\n    if (options.userInfo?.identity === undefined) {\r\n      return;\r\n    }\r\n    const tokenFetcher = async () => {\r\n      log.debug('fetching token');\r\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\r\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\r\n      if (!res.ok) {\r\n        log.error(\r\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\r\n        );\r\n        return;\r\n      }\r\n      const { accessToken } = await res.json();\r\n      setToken(accessToken);\r\n    };\r\n    tokenFetcher();\r\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\r\n  return token;\r\n}\r\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\r\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { Track } from 'livekit-client';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackRefBySourceOrName(\r\n  source: TrackSource<Track.Source>,\r\n): TrackReferenceOrPlaceholder {\r\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\r\n\r\n  const { trackObserver } = React.useMemo(() => {\r\n    return setupMediaTrack(source);\r\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackObserver.subscribe((publication) => {\r\n      setPublication(publication);\r\n    });\r\n    return () => subscription?.unsubscribe();\r\n  }, [trackObserver]);\r\n\r\n  return {\r\n    participant: source.participant,\r\n    source: source.source ?? Track.Source.Unknown,\r\n    publication,\r\n  };\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\r\n\r\n/**\r\n * This function `useTrackByName` allows you to access a track by referencing its track name.\r\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\r\n * for both a passed participant argument and, if not available, a valid participant context.\r\n *\r\n * @public\r\n */\r\nexport function useTrackByName(name: string, participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useTrackRefBySourceOrName({ name, participant: p });\r\n}\r\n","import * as React from 'react';\r\nimport type { TrackReference } from '@livekit/components-core';\r\nimport { participantTracksObservable } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\nimport type { Room, Track } from 'livekit-client';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useParticipants } from './useParticipants';\r\n\r\ntype UseParticipantTracksOptions = {\r\n  participantIdentity?: string;\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\r\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\r\n * @public\r\n */\r\nexport function useParticipantTracks<TrackSource extends Track.Source>(\r\n  sources: Array<TrackSource>,\r\n  optionsOrParticipantIdentity:\r\n    | UseParticipantTracksOptions\r\n    | UseParticipantTracksOptions['participantIdentity'] = {},\r\n): Array<TrackReference> {\r\n  let participantIdentity: UseParticipantTracksOptions['participantIdentity'];\r\n  let room: UseParticipantTracksOptions['room'];\r\n  if (typeof optionsOrParticipantIdentity === 'string') {\r\n    participantIdentity = optionsOrParticipantIdentity;\r\n  } else {\r\n    participantIdentity = optionsOrParticipantIdentity?.participantIdentity;\r\n    room = optionsOrParticipantIdentity?.room;\r\n  }\r\n\r\n  const participantContext = useMaybeParticipantContext();\r\n  const participants = useParticipants({ room, updateOnlyOn: [] });\r\n\r\n  const p = React.useMemo(() => {\r\n    if (participantIdentity) {\r\n      return participants.find((p) => p.identity === participantIdentity);\r\n    }\r\n    return participantContext;\r\n  }, [participantIdentity, participants, participantContext]);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (!p) {\r\n      return undefined;\r\n    }\r\n    return participantTracksObservable(p, { sources });\r\n  }, [p, JSON.stringify(sources)]);\r\n\r\n  const trackRefs = useObservableState(observable, [] as Array<TrackReference>);\r\n\r\n  return trackRefs;\r\n}\r\n","import * as React from 'react';\r\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @internal\r\n * @deprecated this is an internal hook that's only used by deprecated APIs\r\n */\r\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\r\n  const observable = React.useMemo(\r\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\r\n    [ref?.publication?.track],\r\n  );\r\n  return useObservableState(observable, {\r\n    timestamp: Date.now(),\r\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\r\n  });\r\n}\r\n","import {\r\n  type ReceivedTranscriptionSegment,\r\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\r\n  dedupeSegments,\r\n  // getActiveTranscriptionSegments,\r\n  getTrackReferenceId,\r\n  trackTranscriptionObserver,\r\n  type TrackReferenceOrPlaceholder,\r\n  // didActiveSegmentsChange,\r\n} from '@livekit/components-core';\r\nimport type { TranscriptionSegment } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useTrackSyncTime } from './useTrackSyncTime';\r\n\r\n/**\r\n * @alpha\r\n * @deprecated Use useTranscription instead\r\n */\r\nexport interface TrackTranscriptionOptions {\r\n  /**\r\n   * how many transcription segments should be buffered in state\r\n   * @defaultValue 100\r\n   */\r\n  bufferSize?: number;\r\n  /**\r\n   * optional callback for retrieving newly incoming transcriptions only\r\n   */\r\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\r\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\r\n  // maxAge?: number;\r\n}\r\n\r\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\r\n  bufferSize: 100,\r\n  // maxAge: 2_000,\r\n} as const satisfies TrackTranscriptionOptions;\r\n\r\n/**\r\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\r\n * @alpha\r\n * @deprecated Use useTranscription instead\r\n */\r\nexport function useTrackTranscription(\r\n  trackRef: TrackReferenceOrPlaceholder | undefined,\r\n  options?: TrackTranscriptionOptions,\r\n) {\r\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\r\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\r\n\r\n  const syncTimestamps = useTrackSyncTime(trackRef);\r\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\r\n    opts.onTranscription?.(newSegments);\r\n    setSegments((prevSegments) =>\r\n      dedupeSegments(\r\n        prevSegments,\r\n        // when first receiving a segment, add the current media timestamp to it\r\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\r\n        opts.bufferSize,\r\n      ),\r\n    );\r\n  };\r\n  React.useEffect(() => {\r\n    if (!trackRef?.publication) {\r\n      return;\r\n    }\r\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\r\n      handleSegmentMessage(...evt);\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\r\n\r\n  return { segments };\r\n}\r\n","import { participantAttributesObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { attributes } = useParticipantAttributes({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantAttributesOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = props.participant ?? participantContext;\r\n  const attributeObserver = React.useMemo(\r\n    // weird typescript constraint\r\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\r\n    [p],\r\n  );\r\n  const attributeState = useObservableState(attributeObserver, {\r\n    attributes: p?.attributes,\r\n  });\r\n\r\n  return attributeState;\r\n}\r\n\r\n/**\r\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\r\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipantAttribute(\r\n  attributeKey: string,\r\n  options: UseParticipantAttributesOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\r\n\r\n  React.useEffect(() => {\r\n    if (!p) {\r\n      return;\r\n    }\r\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\r\n      if (val.changed[attributeKey] !== undefined) {\r\n        setAttribute(val.attributes[attributeKey]);\r\n      }\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [p, attributeKey]);\r\n\r\n  return attribute;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\r\nimport type { RemoteParticipant } from 'livekit-client';\r\nimport {\r\n  ParticipantAgentAttributes,\r\n  type ReceivedTranscriptionSegment,\r\n  type TrackReference,\r\n} from '@livekit/components-core';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useTrackTranscription } from './useTrackTranscription';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useParticipantAttributes } from './useParticipantAttributes';\r\nimport { AgentState } from './useAgent';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface VoiceAssistant {\r\n  /**\r\n   * The agent participant.\r\n   */\r\n  agent: RemoteParticipant | undefined;\r\n  /**\r\n   * The current state of the agent.\r\n   */\r\n  state: AgentState;\r\n  /**\r\n   * The microphone track published by the agent or associated avatar worker (if any).\r\n   */\r\n  audioTrack: TrackReference | undefined;\r\n  /**\r\n   * The camera track published by the agent or associated avatar worker (if any).\r\n   */\r\n  videoTrack: TrackReference | undefined;\r\n  /**\r\n   * The transcriptions of the agent's microphone track (if any).\r\n   */\r\n  agentTranscriptions: ReceivedTranscriptionSegment[];\r\n  /**\r\n   * The agent's participant attributes.\r\n   */\r\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\r\n}\r\n\r\nconst state_attribute = ParticipantAgentAttributes.AgentState;\r\n\r\n/**\r\n * This hook looks for the first agent-participant in the room.\r\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\r\n * @example\r\n * ```tsx\r\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\r\n * ```\r\n * @beta\r\n */\r\nexport function useVoiceAssistant(): VoiceAssistant {\r\n  const remoteParticipants = useRemoteParticipants();\r\n  const agent = remoteParticipants.find(\r\n    (p) =>\r\n      p.kind === ParticipantKind.AGENT &&\r\n      !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\r\n  );\r\n  const worker = remoteParticipants.find(\r\n    (p) =>\r\n      p.kind === ParticipantKind.AGENT &&\r\n      p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agent?.identity,\r\n  );\r\n  const agentTracks = useParticipantTracks(\r\n    [Track.Source.Microphone, Track.Source.Camera],\r\n    agent?.identity,\r\n  );\r\n  const workerTracks = useParticipantTracks(\r\n    [Track.Source.Microphone, Track.Source.Camera],\r\n    worker?.identity,\r\n  );\r\n  const audioTrack =\r\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\r\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\r\n  const videoTrack =\r\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\r\n    workerTracks.find((t) => t.source === Track.Source.Camera);\r\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\r\n  const connectionState = useConnectionState();\r\n  const { attributes } = useParticipantAttributes({ participant: agent });\r\n\r\n  const state: AgentState = React.useMemo(() => {\r\n    if (connectionState === ConnectionState.Disconnected) {\r\n      return 'disconnected';\r\n    } else if (\r\n      connectionState === ConnectionState.Connecting ||\r\n      !agent ||\r\n      !attributes?.[state_attribute]\r\n    ) {\r\n      return 'connecting';\r\n    } else {\r\n      return attributes[state_attribute] as AgentState;\r\n    }\r\n  }, [attributes, agent, connectionState]);\r\n\r\n  return {\r\n    agent,\r\n    state,\r\n    audioTrack,\r\n    videoTrack,\r\n    agentTranscriptions,\r\n    agentAttributes: attributes,\r\n  };\r\n}\r\n","import { recordingStatusObservable } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport type { Room } from 'livekit-client';\r\n\r\n/**\r\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\r\n * @example\r\n * ```tsx\r\n * const isRecording = useIsRecording();\r\n * ```\r\n * @public\r\n */\r\nexport function useIsRecording(room?: Room) {\r\n  const r = useEnsureRoom(room);\r\n  const connectionState = useConnectionState(r);\r\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\r\n  const isRecording = useObservableState(observable, r.isRecording);\r\n\r\n  return isRecording;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, Room } from 'livekit-client';\r\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @beta */\r\nexport type UseTextStreamOptions = {\r\n  room?: Room;\r\n};\r\n\r\n/**\r\n * @beta\r\n * @param topic - the topic to listen to\r\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\r\n * @example\r\n * ```tsx\r\n * const { textStreams } = useTextStream('my-topic');\r\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\r\n * ```\r\n */\r\nexport function useTextStream(topic: string, options?: UseTextStreamOptions) {\r\n  const room = useEnsureRoom(options?.room);\r\n\r\n  const connectionState = useConnectionState(room);\r\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\r\n\r\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\r\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\r\n\r\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\r\n\r\n  return { textStreams };\r\n}\r\n","import * as React from 'react';\r\nimport { useTextStream } from './useTextStream';\r\nimport { DataTopic, ParticipantAgentAttributes } from '@livekit/components-core';\r\nimport { Room } from 'livekit-client';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface UseTranscriptionsOptions {\r\n  room?: Room;\r\n  participantIdentities?: string[];\r\n  trackSids?: string[];\r\n}\r\n\r\n/**\r\n * @beta\r\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\r\n * if no options are provided, it will return all transcriptions\r\n * @example\r\n * ```tsx\r\n * const transcriptions = useTranscriptions();\r\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\r\n * ```\r\n */\r\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\r\n  const { participantIdentities, trackSids } = opts ?? {};\r\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION, { room: opts?.room });\r\n\r\n  const filteredMessages = React.useMemo(\r\n    () =>\r\n      textStreams\r\n        .filter((stream) =>\r\n          participantIdentities\r\n            ? participantIdentities.includes(stream.participantInfo.identity)\r\n            : true,\r\n        )\r\n        .filter((stream) =>\r\n          trackSids\r\n            ? trackSids.includes(\r\n                stream.streamInfo.attributes?.[ParticipantAgentAttributes.TranscribedTrackId] ?? '',\r\n              )\r\n            : true,\r\n        ),\r\n    [textStreams, participantIdentities, trackSids],\r\n  );\r\n\r\n  return filteredMessages;\r\n}\r\n","import { Mutex, type Room } from 'livekit-client';\r\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\r\nimport { log } from '@livekit/components-core';\r\n\r\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY = 2;\r\nconst CONNECT_DISCONNECT_WARNING_THRESHOLD_MS = 400;\r\n\r\nconst ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY = 3;\r\nconst ROOM_CHANGE_WARNING_THRESHOLD_MS = 1000;\r\n\r\n/** @public */\r\nexport type UseSequentialRoomConnectDisconnectResults<R extends Room | undefined> = {\r\n  connect: typeof Room.prototype.connect & (R extends undefined ? null : unknown);\r\n  disconnect: typeof Room.prototype.disconnect & (R extends undefined ? null : unknown);\r\n};\r\n\r\n/**\r\n * When calling room.disconnect() as part of a React useEffect cleanup function, it is possible for\r\n * a room.connect(...) in the effect body to start running while the room.disconnect() is still\r\n * running. This hook sequentializes these two operations, so they always happen in order and\r\n * never overlap.\r\n *\r\n * @example\r\n * ```ts\r\n * const { connect, disconnect } = useSequentialRoomConnectDisconnect(room);\r\n *\r\n * // Connecting to a room:\r\n * useEffect(() => {\r\n *   connect();\r\n *   return () => disconnect();\r\n * }, [connect, disconnect]);\r\n * ```\r\n *\r\n * @public\r\n */\r\nexport function useSequentialRoomConnectDisconnect<R extends Room | undefined>(\r\n  room: R,\r\n): UseSequentialRoomConnectDisconnectResults<R> {\r\n  const connectDisconnectQueueRef = useRef<\r\n    Array<\r\n      | {\r\n          type: 'connect';\r\n          room: Room;\r\n          args: Parameters<typeof Room.prototype.connect>;\r\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.connect>>) => void;\r\n          reject: (err: Error) => void;\r\n        }\r\n      | {\r\n          type: 'disconnect';\r\n          room: Room;\r\n          args: Parameters<typeof Room.prototype.disconnect>;\r\n          resolve: (value: Awaited<ReturnType<typeof Room.prototype.disconnect>>) => void;\r\n          reject: (err: Error) => void;\r\n        }\r\n    >\r\n  >([]);\r\n\r\n  // Process room connection / disconnection events and execute them in series\r\n  // The main queue is a ref, so one invocation of this function can continue to process newly added\r\n  // events\r\n  const processConnectsAndDisconnectsLock = useMemo(() => new Mutex(), []);\r\n  const processConnectsAndDisconnects = useCallback(async () => {\r\n    return processConnectsAndDisconnectsLock.lock().then(async (unlock) => {\r\n      while (true) {\r\n        const message = connectDisconnectQueueRef.current.pop();\r\n        if (!message) {\r\n          unlock();\r\n          break;\r\n        }\r\n\r\n        switch (message.type) {\r\n          case 'connect':\r\n            await message.room\r\n              .connect(...message.args)\r\n              .then(message.resolve)\r\n              .catch(message.reject);\r\n            break;\r\n          case 'disconnect':\r\n            await message.room\r\n              .disconnect(...message.args)\r\n              .then(message.resolve)\r\n              .catch(message.reject);\r\n            break;\r\n        }\r\n      }\r\n    });\r\n  }, []);\r\n\r\n  const roomChangedTimesRef = useRef<Array<Date>>([]);\r\n  const checkRoomThreshold = useCallback((now: Date) => {\r\n    let roomChangesInThreshold = 0;\r\n    roomChangedTimesRef.current = roomChangedTimesRef.current.filter((i) => {\r\n      const isWithinThreshold = now.getTime() - i.getTime() < ROOM_CHANGE_WARNING_THRESHOLD_MS;\r\n      if (isWithinThreshold) {\r\n        roomChangesInThreshold += 1;\r\n      }\r\n      return isWithinThreshold;\r\n    });\r\n\r\n    if (roomChangesInThreshold > ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY) {\r\n      log.warn(\r\n        `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY}x in ${ROOM_CHANGE_WARNING_THRESHOLD_MS}ms). This is not recommended.`,\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  // When the room changes, clear any pending connect / disconnect calls and log when it happened\r\n  useEffect(() => {\r\n    connectDisconnectQueueRef.current = [];\r\n\r\n    const now = new Date();\r\n    roomChangedTimesRef.current.push(now);\r\n    checkRoomThreshold(now);\r\n  }, [room, checkRoomThreshold]);\r\n\r\n  const connectDisconnectEnqueueTimes = useRef<Array<Date>>([]);\r\n  const checkConnectDisconnectThreshold = useCallback((now: Date) => {\r\n    let connectDisconnectsInThreshold = 0;\r\n    connectDisconnectEnqueueTimes.current = connectDisconnectEnqueueTimes.current.filter((i) => {\r\n      const isWithinThreshold =\r\n        now.getTime() - i.getTime() < CONNECT_DISCONNECT_WARNING_THRESHOLD_MS;\r\n      if (isWithinThreshold) {\r\n        connectDisconnectsInThreshold += 1;\r\n      }\r\n      return isWithinThreshold;\r\n    });\r\n\r\n    if (connectDisconnectsInThreshold > CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY) {\r\n      log.warn(\r\n        `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY}x in ${CONNECT_DISCONNECT_WARNING_THRESHOLD_MS}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`,\r\n      );\r\n    }\r\n  }, []);\r\n\r\n  const connect = useCallback(\r\n    async (...args: Parameters<typeof Room.prototype.connect>) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (!room) {\r\n          throw new Error('Called connect(), but room was unset');\r\n        }\r\n        const now = new Date();\r\n        checkConnectDisconnectThreshold(now);\r\n        connectDisconnectQueueRef.current.push({ type: 'connect', room, args, resolve, reject });\r\n        connectDisconnectEnqueueTimes.current.push(now);\r\n        processConnectsAndDisconnects();\r\n      });\r\n    },\r\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\r\n  );\r\n\r\n  const disconnect = useCallback(\r\n    async (...args: Parameters<typeof Room.prototype.disconnect>) => {\r\n      return new Promise((resolve, reject) => {\r\n        if (!room) {\r\n          throw new Error('Called discconnect(), but room was unset');\r\n        }\r\n        const now = new Date();\r\n        checkConnectDisconnectThreshold(now);\r\n        connectDisconnectQueueRef.current.push({ type: 'disconnect', room, args, resolve, reject });\r\n        connectDisconnectEnqueueTimes.current.push(now);\r\n        processConnectsAndDisconnects();\r\n      });\r\n    },\r\n    [room, checkConnectDisconnectThreshold, processConnectsAndDisconnects],\r\n  );\r\n\r\n  return {\r\n    connect: room ? connect : null,\r\n    disconnect: room ? disconnect : null,\r\n  } as UseSequentialRoomConnectDisconnectResults<R>;\r\n}\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import {\r\n  ConnectionState,\r\n  LocalTrackPublication,\r\n  ParticipantEvent,\r\n  ParticipantKind,\r\n  RemoteParticipant,\r\n  RoomEvent,\r\n  Track,\r\n  Participant,\r\n} from 'livekit-client';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport { EventEmitter } from 'events';\r\nimport * as React from 'react';\r\nimport { ParticipantAgentAttributes, TrackReference } from '@livekit/components-core';\r\n\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { UseSessionReturn } from './useSession';\r\nimport { useMaybeSessionContext } from '../context';\r\nimport { useParticipantInfo } from './useParticipantInfo';\r\n\r\n// FIXME: make this 10 seconds once room dispatch booting info is discoverable\r\nconst DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS = 20_000;\r\n\r\n/** @see https://github.com/livekit/agents/blob/65170238db197f62f479eb7aaef1c0e18bfad6e7/livekit-agents/livekit/agents/voice/events.py#L97 */\r\ntype AgentSdkStates = 'initializing' | 'idle' | 'listening' | 'thinking' | 'speaking';\r\n\r\n/**\r\n * State representing the current status of the agent, whether it is ready for speach, etc\r\n *\r\n * For most agents (which have the preconnect audio buffer feature enabled), this is the lifecycle:\r\n *   connecting  pre-connect-buffering  initializing/listening/thinking/speaking\r\n *\r\n * For agents without the preconnect audio feature enabled:\r\n *   connecting  initializing  idle/listening/thinking/speaking\r\n *\r\n * If an agent fails to connect:\r\n *   connecting  pre-connect-buffering/initializing  failed\r\n *\r\n * Legacy useVoiceAssistant hook:\r\n *   disconnected  connecting  initializing  listening/thinking/speaking\r\n *\r\n * @beta\r\n * */\r\nexport type AgentState =\r\n  | 'disconnected'\r\n  | 'connecting'\r\n  | 'pre-connect-buffering'\r\n  | 'failed'\r\n  | AgentSdkStates;\r\n\r\n/** @beta */\r\nexport enum AgentEvent {\r\n  CameraChanged = 'cameraChanged',\r\n  MicrophoneChanged = 'microphoneChanged',\r\n  StateChanged = 'stateChanged',\r\n}\r\n\r\n/** @beta */\r\nexport type AgentCallbacks = {\r\n  [AgentEvent.CameraChanged]: (newTrack: TrackReference | undefined) => void;\r\n  [AgentEvent.MicrophoneChanged]: (newTrack: TrackReference | undefined) => void;\r\n  [AgentEvent.StateChanged]: (newAgentState: AgentState) => void;\r\n};\r\n\r\ntype AgentStateCommon = {\r\n  // FIXME: maybe add some sort of schema to this?\r\n  attributes: Participant['attributes'];\r\n\r\n  internal: {\r\n    emitter: TypedEventEmitter<AgentCallbacks>;\r\n\r\n    agentParticipant: RemoteParticipant | null;\r\n    workerParticipant: RemoteParticipant | null;\r\n  };\r\n};\r\n\r\ntype AgentStateAvailable = AgentStateCommon & {\r\n  state: 'listening' | 'thinking' | 'speaking';\r\n  failureReasons: null;\r\n\r\n  /** The agent's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: true;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: true;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStatePreConnectBuffering = AgentStateCommon & {\r\n  state: 'pre-connect-buffering';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: true;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStateUnAvailable = AgentStateCommon & {\r\n  state: 'initializing' | 'idle';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: Participant['identity'];\r\n  name: Participant['name'];\r\n  metadata: Participant['metadata'];\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: true;\r\n\r\n  cameraTrack?: TrackReference;\r\n  microphoneTrack?: TrackReference;\r\n};\r\n\r\ntype AgentStateConnecting = AgentStateCommon & {\r\n  state: 'connecting';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: false;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: true;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentStateDisconnected = AgentStateCommon & {\r\n  state: 'disconnected';\r\n  failureReasons: null;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: true;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentStateFailed = AgentStateCommon & {\r\n  state: 'failed';\r\n  failureReasons: Array<string>;\r\n\r\n  /** The client's assigned identity, coming from the JWT token. */\r\n  identity: undefined;\r\n  name: undefined;\r\n  metadata: undefined;\r\n\r\n  /** Is the agent connected to the client? */\r\n  isConnected: false;\r\n\r\n  /**\r\n   * Could the client be listening for user speech?\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  canListen: false;\r\n\r\n  /** Has the client disconnected from the agent either for an expected or unexpected reason? */\r\n  isFinished: true;\r\n\r\n  /** Is the agent currently connecting or setting itself up? */\r\n  isPending: false;\r\n\r\n  cameraTrack: undefined;\r\n  microphoneTrack: undefined;\r\n};\r\n\r\ntype AgentActions = {\r\n  /** Returns a promise that resolves once the agent is connected and available for user input */\r\n  waitUntilConnected: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /**\r\n   * Returns a promise that resolves once the client could be listening for user speech (`canListen` is true)\r\n   *\r\n   * Note that this may not mean that the agent is actually connected - the audio pre-connect\r\n   * buffer could be active and recording user input before the agent actually connects.\r\n   * */\r\n  waitUntilCouldBeListening: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /** Returns a promise that resolves once the client has disconnected from the agent either for an expected or unexpected reason. */\r\n  waitUntilFinished: (signal?: AbortSignal) => Promise<void>;\r\n\r\n  /** Returns a promise that resolves once the agent has published a camera track */\r\n  waitUntilCamera: (signal?: AbortSignal) => Promise<TrackReference>;\r\n\r\n  /** Returns a promise that resolves once the agent has published a microphone track */\r\n  waitUntilMicrophone: (signal?: AbortSignal) => Promise<TrackReference>;\r\n};\r\n\r\ntype AgentStateCases =\r\n  | AgentStateConnecting\r\n  | AgentStateDisconnected\r\n  | AgentStateAvailable\r\n  | AgentStatePreConnectBuffering\r\n  | AgentStateUnAvailable\r\n  | AgentStateFailed;\r\n\r\n/** @beta */\r\nexport type UseAgentReturn = AgentStateCases & AgentActions;\r\n\r\nconst generateDerivedStateValues = <State extends AgentState>(state: State) =>\r\n  ({\r\n    isConnected: state === 'listening' || state === 'thinking' || state === 'speaking',\r\n    canListen:\r\n      state === 'pre-connect-buffering' ||\r\n      state === 'listening' ||\r\n      state === 'thinking' ||\r\n      state === 'speaking',\r\n    isFinished: state === 'disconnected' || state === 'failed',\r\n    isPending: state === 'connecting' || state === 'initializing' || state === 'idle',\r\n  }) as {\r\n    isConnected: State extends 'listening' | 'thinking' | 'speaking' ? true : false;\r\n    canListen: State extends 'pre-connect-buffering' | 'listening' | 'thinking' | 'speaking'\r\n      ? true\r\n      : false;\r\n    isFinished: State extends 'disconnected' | 'failed' ? true : false;\r\n    isPending: State extends 'connecting' | 'initializing' | 'idle' ? true : false;\r\n  };\r\n\r\n/** Internal hook used by useSession to store global agent state */\r\nexport const useAgentTimeoutIdStore = (): {\r\n  agentTimeoutFailureReason: string | null;\r\n  startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\r\n  clearAgentTimeout: () => void;\r\n  clearAgentTimeoutFailureReason: () => void;\r\n  updateAgentTimeoutState: (agentState: AgentState) => void;\r\n  updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\r\n} => {\r\n  const [agentTimeoutFailureReason, setAgentTimeoutFailureReason] = React.useState<string | null>(\r\n    null,\r\n  );\r\n  const [agentTimeoutId, setAgentTimeoutId] = React.useState<ReturnType<typeof setTimeout> | null>(\r\n    null,\r\n  );\r\n\r\n  const agentStateRef = React.useRef<AgentState>('connecting');\r\n  const agentParticipantExistsRef = React.useRef(false);\r\n\r\n  const startAgentConnectedTimeout = (agentConnectTimeoutMilliseconds?: number) => {\r\n    return setTimeout(() => {\r\n      if (!agentParticipantExistsRef.current) {\r\n        setAgentTimeoutFailureReason('Agent did not join the room.');\r\n        return;\r\n      }\r\n\r\n      const { isConnected } = generateDerivedStateValues(agentStateRef.current);\r\n      if (!isConnected) {\r\n        setAgentTimeoutFailureReason('Agent joined the room but did not complete initializing.');\r\n        return;\r\n      }\r\n    }, agentConnectTimeoutMilliseconds ?? DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS);\r\n  };\r\n\r\n  return {\r\n    agentTimeoutFailureReason,\r\n    startAgentTimeout: React.useCallback(\r\n      (agentConnectTimeoutMilliseconds?: number) => {\r\n        if (agentTimeoutId) {\r\n          clearTimeout(agentTimeoutId);\r\n        }\r\n\r\n        setAgentTimeoutFailureReason(null);\r\n        setAgentTimeoutId(startAgentConnectedTimeout(agentConnectTimeoutMilliseconds));\r\n        agentStateRef.current = 'connecting';\r\n        agentParticipantExistsRef.current = false;\r\n      },\r\n      [agentTimeoutId],\r\n    ),\r\n    clearAgentTimeout: React.useCallback(() => {\r\n      if (agentTimeoutId) {\r\n        clearTimeout(agentTimeoutId);\r\n      }\r\n\r\n      setAgentTimeoutFailureReason(null);\r\n      setAgentTimeoutId(null);\r\n      agentStateRef.current = 'connecting';\r\n      agentParticipantExistsRef.current = false;\r\n    }, [agentTimeoutId]),\r\n    clearAgentTimeoutFailureReason: React.useCallback(() => {\r\n      setAgentTimeoutFailureReason(null);\r\n    }, []),\r\n\r\n    updateAgentTimeoutState: React.useCallback((agentState: AgentState) => {\r\n      agentStateRef.current = agentState;\r\n    }, []),\r\n    updateAgentTimeoutParticipantExists: React.useCallback((agentParticipantExists: boolean) => {\r\n      agentParticipantExistsRef.current = agentParticipantExists;\r\n    }, []),\r\n  };\r\n};\r\n\r\ntype SessionStub = Pick<UseSessionReturn, 'connectionState' | 'room' | 'internal'>;\r\n\r\n/** Internal hook used by useAgent which generates a function that when called, will return a\r\n * promise which resolves when agent.isAvailable is enabled. */\r\nfunction useAgentWaitUntilDerivedStates(\r\n  emitter: TypedEventEmitter<AgentCallbacks>,\r\n  state: AgentState,\r\n) {\r\n  const stateRef = React.useRef(state);\r\n  React.useEffect(() => {\r\n    stateRef.current = state;\r\n  }, [state]);\r\n\r\n  const waitUntilConnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { isConnected } = generateDerivedStateValues(stateRef.current);\r\n      if (isConnected) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { isConnected } = generateDerivedStateValues(state);\r\n          if (!isConnected) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilConnected - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilCouldBeListening = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { canListen } = generateDerivedStateValues(stateRef.current);\r\n      if (canListen) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { canListen } = generateDerivedStateValues(state);\r\n          if (!canListen) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilCouldBeListening - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilFinished = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      const { isFinished } = generateDerivedStateValues(stateRef.current);\r\n      if (isFinished) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const stateChangedHandler = (state: AgentState) => {\r\n          const { isFinished } = generateDerivedStateValues(state);\r\n          if (!isFinished) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilFinished - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.StateChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.StateChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished };\r\n}\r\n\r\n/**\r\n * useAgent encapculates all agent state, normalizing some quirks around how LiveKit Agents work.\r\n * @beta\r\n */\r\nexport function useAgent(session?: SessionStub): UseAgentReturn {\r\n  const sessionFromContext = useMaybeSessionContext();\r\n  session = session ?? sessionFromContext;\r\n  if (!session) {\r\n    throw new Error(\r\n      'No session provided, make sure you are inside a Session context or pass the session explicitly',\r\n    );\r\n  }\r\n\r\n  const {\r\n    room,\r\n    internal: {\r\n      agentConnectTimeoutMilliseconds,\r\n\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    },\r\n  } = session;\r\n\r\n  const emitter = React.useMemo(() => new EventEmitter() as TypedEventEmitter<AgentCallbacks>, []);\r\n\r\n  const roomRemoteParticipants = useRemoteParticipants({ room });\r\n\r\n  const agentParticipant = React.useMemo(() => {\r\n    return (\r\n      roomRemoteParticipants.find(\r\n        (p) =>\r\n          p.kind === ParticipantKind.AGENT &&\r\n          !(ParticipantAgentAttributes.PublishOnBehalf in p.attributes),\r\n      ) ?? null\r\n    );\r\n  }, [roomRemoteParticipants]);\r\n  const workerParticipant = React.useMemo(() => {\r\n    if (!agentParticipant) {\r\n      return null;\r\n    }\r\n    return (\r\n      roomRemoteParticipants.find(\r\n        (p) =>\r\n          p.kind === ParticipantKind.AGENT &&\r\n          p.attributes[ParticipantAgentAttributes.PublishOnBehalf] === agentParticipant.identity,\r\n      ) ?? null\r\n    );\r\n  }, [agentParticipant, roomRemoteParticipants]);\r\n\r\n  // 1. Listen for agent participant attribute changes\r\n  const [agentParticipantAttributes, setAgentParticipantAttributes] = React.useState<\r\n    Participant['attributes']\r\n  >(agentParticipant?.attributes ?? {});\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    const handleAttributesChanged = (attributes: UseAgentReturn['attributes']) => {\r\n      setAgentParticipantAttributes(attributes);\r\n    };\r\n\r\n    agentParticipant.on(ParticipantEvent.AttributesChanged, handleAttributesChanged);\r\n    return () => {\r\n      agentParticipant.off(ParticipantEvent.AttributesChanged, handleAttributesChanged);\r\n    };\r\n  }, [agentParticipant, emitter]);\r\n\r\n  // 2. Listen for track updates\r\n  const agentTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\r\n    room,\r\n    participantIdentity: agentParticipant?.identity,\r\n  });\r\n  const workerTracks = useParticipantTracks([Track.Source.Camera, Track.Source.Microphone], {\r\n    room,\r\n    participantIdentity: workerParticipant?.identity,\r\n  });\r\n\r\n  const videoTrack = React.useMemo(\r\n    () =>\r\n      agentTracks.find((t) => t.source === Track.Source.Camera) ??\r\n      workerTracks.find((t) => t.source === Track.Source.Camera),\r\n    [agentTracks, workerTracks],\r\n  );\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.CameraChanged, videoTrack);\r\n  }, [emitter, videoTrack]);\r\n\r\n  const audioTrack = React.useMemo(\r\n    () =>\r\n      agentTracks.find((t) => t.source === Track.Source.Microphone) ??\r\n      workerTracks.find((t) => t.source === Track.Source.Microphone),\r\n    [agentTracks, workerTracks],\r\n  );\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.MicrophoneChanged, audioTrack);\r\n  }, [emitter, audioTrack]);\r\n\r\n  // Listen for room connection state updates\r\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\r\n  React.useEffect(() => {\r\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\r\n      setRoomConnectionState(connectionState);\r\n    };\r\n\r\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    return () => {\r\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    };\r\n  }, [room]);\r\n\r\n  // When the agent participant connects, reset the timeout failure state\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    clearAgentTimeoutFailureReason();\r\n  }, [agentParticipant]);\r\n\r\n  // If the agent participant disconnects in the middle of a conversation unexpectedly, mark that as an explicit failure\r\n  const [agentDisconnectedFailureReason, setAgentDisconnectedFailureReason] = React.useState<\r\n    string | null\r\n  >(null);\r\n  React.useEffect(() => {\r\n    if (!agentParticipant) {\r\n      return;\r\n    }\r\n\r\n    const onParticipantDisconnect = (participant: RemoteParticipant) => {\r\n      if (participant.identity !== agentParticipant?.identity) {\r\n        return;\r\n      }\r\n      setAgentDisconnectedFailureReason('Agent left the room unexpectedly.');\r\n    };\r\n\r\n    room.on(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\r\n\r\n    return () => {\r\n      room.off(RoomEvent.ParticipantDisconnected, onParticipantDisconnect);\r\n    };\r\n  }, [agentParticipant, room]);\r\n\r\n  React.useEffect(() => {\r\n    if (roomConnectionState !== ConnectionState.Disconnected) {\r\n      return;\r\n    }\r\n    // Clear the agent disconnect failure state when the room disconnects\r\n    setAgentDisconnectedFailureReason(null);\r\n  }, [roomConnectionState]);\r\n\r\n  const [localMicTrack, setLocalMicTrack] = React.useState<LocalTrackPublication | null>(\r\n    () => room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null,\r\n  );\r\n  React.useEffect(() => {\r\n    const handleLocalParticipantTrackPublished = () => {\r\n      setLocalMicTrack(room.localParticipant.getTrackPublication(Track.Source.Microphone) ?? null);\r\n    };\r\n    const handleLocalParticipantTrackUnPublished = () => {\r\n      setLocalMicTrack(null);\r\n    };\r\n\r\n    room.localParticipant.on(\r\n      ParticipantEvent.LocalTrackPublished,\r\n      handleLocalParticipantTrackPublished,\r\n    );\r\n    room.localParticipant.on(\r\n      ParticipantEvent.LocalTrackUnpublished,\r\n      handleLocalParticipantTrackUnPublished,\r\n    );\r\n    return () => {\r\n      room.localParticipant.off(\r\n        ParticipantEvent.LocalTrackPublished,\r\n        handleLocalParticipantTrackPublished,\r\n      );\r\n      room.localParticipant.off(\r\n        ParticipantEvent.LocalTrackUnpublished,\r\n        handleLocalParticipantTrackUnPublished,\r\n      );\r\n    };\r\n  }, [room.localParticipant]);\r\n\r\n  const failureReasons = React.useMemo(() => {\r\n    const reasons = [];\r\n    if (agentTimeoutFailureReason) {\r\n      reasons.push(agentTimeoutFailureReason);\r\n    }\r\n    if (agentDisconnectedFailureReason) {\r\n      reasons.push(agentDisconnectedFailureReason);\r\n    }\r\n    return reasons;\r\n  }, [agentTimeoutFailureReason, agentDisconnectedFailureReason]);\r\n\r\n  const state = React.useMemo(() => {\r\n    if (failureReasons.length > 0) {\r\n      return 'failed';\r\n    }\r\n\r\n    let state: AgentState = 'disconnected';\r\n\r\n    if (roomConnectionState !== ConnectionState.Disconnected) {\r\n      state = 'connecting';\r\n    }\r\n\r\n    // If the microphone preconnect buffer is active, then a special 'pre-connect-buffering' state\r\n    // is set\r\n    if (localMicTrack) {\r\n      state = 'pre-connect-buffering';\r\n    }\r\n\r\n    if (agentParticipant && agentParticipantAttributes[ParticipantAgentAttributes.AgentState]) {\r\n      state = agentParticipantAttributes[ParticipantAgentAttributes.AgentState] as AgentSdkStates;\r\n    }\r\n\r\n    return state;\r\n  }, [\r\n    failureReasons,\r\n    roomConnectionState,\r\n    localMicTrack,\r\n    agentParticipant,\r\n    agentParticipantAttributes,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    emitter.emit(AgentEvent.StateChanged, state);\r\n    updateAgentTimeoutState(state);\r\n  }, [emitter, state]);\r\n  React.useEffect(() => {\r\n    updateAgentTimeoutParticipantExists(agentParticipant !== null);\r\n  }, [agentParticipant]);\r\n\r\n  // When the session room begins connecting, start the agent timeout\r\n  const isSessionDisconnected = session.connectionState === 'disconnected';\r\n  React.useEffect(() => {\r\n    if (isSessionDisconnected) {\r\n      return;\r\n    }\r\n\r\n    startAgentTimeout(agentConnectTimeoutMilliseconds);\r\n    return () => {\r\n      clearAgentTimeout();\r\n    };\r\n  }, [isSessionDisconnected, agentConnectTimeoutMilliseconds]);\r\n\r\n  const {\r\n    identity: agentParticipantIdentity,\r\n    name: agentParticipantName,\r\n    metadata: agentParticipantMetadata,\r\n  } = useParticipantInfo({ participant: agentParticipant ?? undefined });\r\n\r\n  const agentState: AgentStateCases = React.useMemo(() => {\r\n    const common: AgentStateCommon = {\r\n      attributes: agentParticipantAttributes,\r\n\r\n      internal: {\r\n        agentParticipant,\r\n        workerParticipant,\r\n        emitter,\r\n      },\r\n    };\r\n\r\n    switch (state) {\r\n      case 'disconnected':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n\r\n      case 'connecting':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n\r\n      case 'initializing':\r\n      case 'idle':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'pre-connect-buffering':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'listening':\r\n      case 'thinking':\r\n      case 'speaking':\r\n        return {\r\n          ...common,\r\n          identity: agentParticipantIdentity!,\r\n          name: agentParticipantName,\r\n          metadata: agentParticipantMetadata,\r\n\r\n          state,\r\n          ...generateDerivedStateValues(state),\r\n          failureReasons: null,\r\n\r\n          cameraTrack: videoTrack,\r\n          microphoneTrack: audioTrack,\r\n        };\r\n\r\n      case 'failed':\r\n        return {\r\n          ...common,\r\n          identity: undefined,\r\n          name: undefined,\r\n          metadata: undefined,\r\n\r\n          state: 'failed',\r\n          ...generateDerivedStateValues('failed'),\r\n          failureReasons,\r\n\r\n          // Clear inner values if no longer connected\r\n          cameraTrack: undefined,\r\n          microphoneTrack: undefined,\r\n        };\r\n    }\r\n  }, [\r\n    agentParticipantIdentity,\r\n    agentParticipantName,\r\n    agentParticipantMetadata,\r\n    agentParticipantAttributes,\r\n    emitter,\r\n    agentParticipant,\r\n    state,\r\n    videoTrack,\r\n    audioTrack,\r\n  ]);\r\n\r\n  const { waitUntilConnected, waitUntilCouldBeListening, waitUntilFinished } =\r\n    useAgentWaitUntilDerivedStates(emitter, state);\r\n\r\n  const waitUntilCamera = React.useCallback(\r\n    (signal?: AbortSignal) => {\r\n      return new Promise<TrackReference>((resolve, reject) => {\r\n        const stateChangedHandler = (camera: TrackReference | undefined) => {\r\n          if (!camera) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve(camera);\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilCamera - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.CameraChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.CameraChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  const waitUntilMicrophone = React.useCallback(\r\n    (signal?: AbortSignal) => {\r\n      return new Promise<TrackReference>((resolve, reject) => {\r\n        const stateChangedHandler = (microphone: TrackReference | undefined) => {\r\n          if (!microphone) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve(microphone);\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(new Error('useAgent(/* ... */).waitUntilMicrophone - signal aborted'));\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(AgentEvent.MicrophoneChanged, stateChangedHandler);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(AgentEvent.MicrophoneChanged, stateChangedHandler);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return React.useMemo(() => {\r\n    return {\r\n      ...agentState,\r\n      waitUntilConnected,\r\n      waitUntilCouldBeListening,\r\n      waitUntilFinished,\r\n      waitUntilCamera,\r\n      waitUntilMicrophone,\r\n    };\r\n  }, [\r\n    agentState,\r\n    waitUntilConnected,\r\n    waitUntilCouldBeListening,\r\n    waitUntilFinished,\r\n    waitUntilCamera,\r\n    waitUntilMicrophone,\r\n  ]);\r\n}\r\n","import * as React from 'react';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport {\r\n  Room,\r\n  RoomEvent,\r\n  ConnectionState,\r\n  TrackPublishOptions,\r\n  Track,\r\n  TokenSourceConfigurable,\r\n  TokenSourceFixed,\r\n  TokenSourceFetchOptions,\r\n  RoomConnectOptions,\r\n  decodeTokenPayload,\r\n} from 'livekit-client';\r\nimport { EventEmitter } from 'events';\r\n\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { AgentState, useAgent, useAgentTimeoutIdStore } from './useAgent';\r\nimport { TrackReference } from '@livekit/components-core';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\n\r\n/** @beta */\r\nexport enum SessionEvent {\r\n  ConnectionStateChanged = 'connectionStateChanged',\r\n  /**\r\n   * Emits when an error is encountered while attempting to create a track.\r\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\r\n   * args: (error: Error, kind: MediaDeviceKind)\r\n   */\r\n  MediaDevicesError = 'mediaDevicesError',\r\n  /**\r\n   * Emits when an error is received while decrypting frame received frame information.\r\n   * args: (error: Error)\r\n   */\r\n  EncryptionError = 'encryptionError',\r\n}\r\n\r\n/** @beta */\r\nexport type SessionCallbacks = {\r\n  [SessionEvent.ConnectionStateChanged]: (newAgentConnectionState: ConnectionState) => void;\r\n  [SessionEvent.MediaDevicesError]: (error: Error) => void;\r\n  [SessionEvent.EncryptionError]: (error: Error) => void;\r\n};\r\n\r\n/** @beta */\r\nexport type SessionConnectOptions = {\r\n  /** Optional abort signal which if triggered will terminate connecting even if it isn't complete */\r\n  signal?: AbortSignal;\r\n\r\n  tracks?: {\r\n    microphone?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n    camera?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n    screenShare?: {\r\n      enabled?: boolean;\r\n      publishOptions?: TrackPublishOptions;\r\n    };\r\n  };\r\n\r\n  /** Options for Room.connect(.., .., opts) */\r\n  roomConnectOptions?: RoomConnectOptions;\r\n};\r\n\r\n/** @beta */\r\nexport type SwitchActiveDeviceOptions = {\r\n  /**\r\n   *  If true, adds an `exact` constraint to the getUserMedia request.\r\n   *  The request will fail if this option is true and the device specified is not actually available\r\n   */\r\n  exact?: boolean;\r\n};\r\n\r\ntype SessionStateCommon = {\r\n  room: Room;\r\n  internal: {\r\n    emitter: TypedEventEmitter<SessionCallbacks>;\r\n    tokenSource: TokenSourceConfigurable | TokenSourceFixed;\r\n    agentConnectTimeoutMilliseconds?: number;\r\n\r\n    agentTimeoutFailureReason: string | null;\r\n    startAgentTimeout: (agentConnectTimeoutMilliseconds?: number) => void;\r\n    clearAgentTimeout: () => void;\r\n    clearAgentTimeoutFailureReason: () => void;\r\n    updateAgentTimeoutState: (agentState: AgentState) => void;\r\n    updateAgentTimeoutParticipantExists: (agentParticipantExists: boolean) => void;\r\n  };\r\n};\r\n\r\ntype SessionStateConnecting = SessionStateCommon & {\r\n  connectionState: ConnectionState.Connecting;\r\n  isConnected: false;\r\n\r\n  local: {\r\n    cameraTrack: undefined;\r\n    microphoneTrack: undefined;\r\n    screenShareTrack: undefined;\r\n  };\r\n};\r\n\r\ntype SessionStateConnected = SessionStateCommon & {\r\n  connectionState:\r\n    | ConnectionState.Connected\r\n    | ConnectionState.Reconnecting\r\n    | ConnectionState.SignalReconnecting;\r\n  isConnected: true;\r\n\r\n  local: {\r\n    cameraTrack?: TrackReference;\r\n    microphoneTrack?: TrackReference;\r\n    screenShareTrack?: TrackReference;\r\n  };\r\n};\r\n\r\ntype SessionStateDisconnected = SessionStateCommon & {\r\n  connectionState: ConnectionState.Disconnected;\r\n  isConnected: false;\r\n\r\n  local: {\r\n    cameraTrack: undefined;\r\n    microphoneTrack: undefined;\r\n    screenShareTrack: undefined;\r\n  };\r\n};\r\n\r\ntype SessionActions = {\r\n  /** Returns a promise that resolves once the room connects. */\r\n  waitUntilConnected: (signal?: AbortSignal) => void;\r\n  /** Returns a promise that resolves once the room disconnects */\r\n  waitUntilDisconnected: (signal?: AbortSignal) => void;\r\n\r\n  prepareConnection: () => Promise<void>;\r\n\r\n  /** Connect to the underlying room and dispatch any agents */\r\n  start: (options?: SessionConnectOptions) => Promise<void>;\r\n\r\n  /** Disconnect from the underlying room */\r\n  end: () => Promise<void>;\r\n};\r\n\r\n/** @beta */\r\nexport type UseSessionReturn = (\r\n  | SessionStateConnecting\r\n  | SessionStateConnected\r\n  | SessionStateDisconnected\r\n) &\r\n  SessionActions;\r\n\r\ntype UseSessionCommonOptions = {\r\n  room?: Room;\r\n\r\n  /**\r\n   * Amount of time in milliseonds the system will wait for an agent to join the room, before\r\n   * transitioning to the \"failure\" state.\r\n   */\r\n  agentConnectTimeoutMilliseconds?: number;\r\n};\r\n\r\ntype UseSessionConfigurableOptions = UseSessionCommonOptions & TokenSourceFetchOptions;\r\ntype UseSessionFixedOptions = UseSessionCommonOptions;\r\n\r\n/**\r\n * Given two TokenSourceFetchOptions values, check to see if they are deep equal.\r\n *\r\n * FIXME: swap this for an import from livekit-client once\r\n * https://github.com/livekit/client-sdk-js/pull/1733 is merged and published!\r\n * */\r\nfunction areTokenSourceFetchOptionsEqual(a: TokenSourceFetchOptions, b: TokenSourceFetchOptions) {\r\n  const allKeysSet = new Set([...Object.keys(a), ...Object.keys(b)]) as Set<\r\n    keyof TokenSourceFetchOptions\r\n  >;\r\n\r\n  for (const key of allKeysSet) {\r\n    switch (key) {\r\n      case 'roomName':\r\n      case 'participantName':\r\n      case 'participantIdentity':\r\n      case 'participantMetadata':\r\n      case 'participantAttributes':\r\n      case 'agentName':\r\n      case 'agentMetadata':\r\n        if (a[key] !== b[key]) {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        // ref: https://stackoverflow.com/a/58009992\r\n        const exhaustiveCheckedKey: never = key;\r\n        throw new Error(`Options key ${exhaustiveCheckedKey} not being checked for equality!`);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/** Internal hook used by useSession to manage creating a function which can be used to wait\r\n * until the session is in a given state before resolving. */\r\nfunction useSessionWaitUntilConnectionState(\r\n  emitter: TypedEventEmitter<SessionCallbacks>,\r\n  connectionState: UseSessionReturn['connectionState'],\r\n) {\r\n  const connectionStateRef = React.useRef(connectionState);\r\n  React.useEffect(() => {\r\n    connectionStateRef.current = connectionState;\r\n  }, [connectionState]);\r\n\r\n  const waitUntilConnectionState = React.useCallback(\r\n    async (state: UseSessionReturn['connectionState'], signal?: AbortSignal) => {\r\n      if (connectionStateRef.current === state) {\r\n        return;\r\n      }\r\n\r\n      return new Promise<void>((resolve, reject) => {\r\n        const onceEventOccurred = (newState: UseSessionReturn['connectionState']) => {\r\n          if (newState !== state) {\r\n            return;\r\n          }\r\n          cleanup();\r\n          resolve();\r\n        };\r\n        const abortHandler = () => {\r\n          cleanup();\r\n          reject(\r\n            new Error(\r\n              `useSession(/* ... */).waitUntilConnectionState(${state}, /* signal */) - signal aborted`,\r\n            ),\r\n          );\r\n        };\r\n\r\n        const cleanup = () => {\r\n          emitter.off(SessionEvent.ConnectionStateChanged, onceEventOccurred);\r\n          signal?.removeEventListener('abort', abortHandler);\r\n        };\r\n\r\n        emitter.on(SessionEvent.ConnectionStateChanged, onceEventOccurred);\r\n        signal?.addEventListener('abort', abortHandler);\r\n      });\r\n    },\r\n    [emitter],\r\n  );\r\n\r\n  return waitUntilConnectionState;\r\n}\r\n\r\n/** Internal hook used by useSession to manage creating a function that properly invokes\r\n * tokenSource.fetch(...) with any fetch options */\r\nfunction useSessionTokenSourceFetch(\r\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\r\n  unstableRestOptions: Exclude<UseSessionConfigurableOptions, keyof UseSessionCommonOptions>,\r\n) {\r\n  const isConfigurable = tokenSource instanceof TokenSourceConfigurable;\r\n\r\n  const memoizedTokenFetchOptionsRef = React.useRef<TokenSourceFetchOptions | null>(\r\n    isConfigurable ? unstableRestOptions : null,\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!isConfigurable) {\r\n      memoizedTokenFetchOptionsRef.current = null;\r\n      return;\r\n    }\r\n\r\n    if (\r\n      memoizedTokenFetchOptionsRef.current !== null &&\r\n      areTokenSourceFetchOptionsEqual(memoizedTokenFetchOptionsRef.current, unstableRestOptions)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    memoizedTokenFetchOptionsRef.current = unstableRestOptions;\r\n  }, [isConfigurable, unstableRestOptions]);\r\n\r\n  const tokenSourceFetch = React.useCallback(async () => {\r\n    if (isConfigurable) {\r\n      if (!memoizedTokenFetchOptionsRef.current) {\r\n        throw new Error(\r\n          `AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!`,\r\n        );\r\n      }\r\n      return tokenSource.fetch(memoizedTokenFetchOptionsRef.current);\r\n    } else {\r\n      return tokenSource.fetch();\r\n    }\r\n  }, [isConfigurable, tokenSource]);\r\n\r\n  return tokenSourceFetch;\r\n}\r\n\r\n/**\r\n * A Session represents a managed connection to a Room which can contain Agents.\r\n * @beta\r\n */\r\nexport function useSession(\r\n  tokenSource: TokenSourceConfigurable,\r\n  options?: UseSessionConfigurableOptions,\r\n): UseSessionReturn;\r\n/**\r\n * A Session represents a managed connection to a Room which can contain Agents.\r\n * @beta\r\n */\r\nexport function useSession(\r\n  tokenSource: TokenSourceFixed,\r\n  options?: UseSessionFixedOptions,\r\n): UseSessionReturn;\r\nexport function useSession(\r\n  tokenSource: TokenSourceConfigurable | TokenSourceFixed,\r\n  options: UseSessionConfigurableOptions | UseSessionFixedOptions = {},\r\n): UseSessionReturn {\r\n  const { room: optionsRoom, agentConnectTimeoutMilliseconds, ...restOptions } = options;\r\n\r\n  const roomFromContext = useMaybeRoomContext();\r\n  const room = React.useMemo(\r\n    () => roomFromContext ?? optionsRoom ?? new Room(),\r\n    [roomFromContext, optionsRoom],\r\n  );\r\n\r\n  const emitter = React.useMemo(\r\n    () => new EventEmitter() as TypedEventEmitter<SessionCallbacks>,\r\n    [],\r\n  );\r\n\r\n  const generateDerivedConnectionStateValues = React.useCallback(\r\n    <State extends UseSessionReturn['connectionState']>(connectionState: State) =>\r\n      ({\r\n        isConnected:\r\n          connectionState === ConnectionState.Connected ||\r\n          connectionState === ConnectionState.Reconnecting ||\r\n          connectionState === ConnectionState.SignalReconnecting,\r\n      }) as {\r\n        isConnected: State extends\r\n          | ConnectionState.Connected\r\n          | ConnectionState.Reconnecting\r\n          | ConnectionState.SignalReconnecting\r\n          ? true\r\n          : false;\r\n      },\r\n    [],\r\n  );\r\n\r\n  const [roomConnectionState, setRoomConnectionState] = React.useState(room.state);\r\n  React.useEffect(() => {\r\n    const handleConnectionStateChanged = (connectionState: ConnectionState) => {\r\n      setRoomConnectionState(connectionState);\r\n    };\r\n\r\n    room.on(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    return () => {\r\n      room.off(RoomEvent.ConnectionStateChanged, handleConnectionStateChanged);\r\n    };\r\n  }, [room]);\r\n\r\n  React.useEffect(() => {\r\n    const handleMediaDevicesError = async (error: Error) => {\r\n      emitter.emit(SessionEvent.MediaDevicesError, error);\r\n    };\r\n\r\n    room.on(RoomEvent.MediaDevicesError, handleMediaDevicesError);\r\n    return () => {\r\n      room.off(RoomEvent.MediaDevicesError, handleMediaDevicesError);\r\n    };\r\n  }, [room, emitter]);\r\n\r\n  React.useEffect(() => {\r\n    const handleEncryptionError = async (error: Error) => {\r\n      emitter.emit(SessionEvent.EncryptionError, error);\r\n    };\r\n\r\n    room.on(RoomEvent.EncryptionError, handleEncryptionError);\r\n    return () => {\r\n      room.off(RoomEvent.EncryptionError, handleEncryptionError);\r\n    };\r\n  }, [room, emitter]);\r\n\r\n  const { localParticipant } = useLocalParticipant({ room });\r\n  const cameraPublication = localParticipant.getTrackPublication(Track.Source.Camera);\r\n  const localCamera = React.useMemo(() => {\r\n    if (!cameraPublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.Camera,\r\n      participant: localParticipant,\r\n      publication: cameraPublication,\r\n    };\r\n  }, [localParticipant, cameraPublication]);\r\n  const microphonePublication = localParticipant.getTrackPublication(Track.Source.Microphone);\r\n  const localMicrophone = React.useMemo(() => {\r\n    if (!microphonePublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.Microphone,\r\n      participant: localParticipant,\r\n      publication: microphonePublication,\r\n    };\r\n  }, [localParticipant, microphonePublication]);\r\n  const screenSharePublication = localParticipant.getTrackPublication(Track.Source.ScreenShare);\r\n  const localScreenShare = React.useMemo(() => {\r\n    if (!screenSharePublication) {\r\n      return undefined;\r\n    }\r\n    return {\r\n      source: Track.Source.ScreenShare,\r\n      participant: localParticipant,\r\n      publication: screenSharePublication,\r\n    };\r\n  }, [localParticipant, screenSharePublication]);\r\n\r\n  const {\r\n    agentTimeoutFailureReason,\r\n    startAgentTimeout,\r\n    clearAgentTimeout,\r\n    clearAgentTimeoutFailureReason,\r\n    updateAgentTimeoutState,\r\n    updateAgentTimeoutParticipantExists,\r\n  } = useAgentTimeoutIdStore();\r\n\r\n  const sessionInternal: UseSessionReturn['internal'] = React.useMemo(\r\n    () => ({\r\n      emitter,\r\n      tokenSource,\r\n      agentConnectTimeoutMilliseconds,\r\n\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    }),\r\n    [\r\n      emitter,\r\n      agentConnectTimeoutMilliseconds,\r\n      tokenSource,\r\n      agentTimeoutFailureReason,\r\n      startAgentTimeout,\r\n      clearAgentTimeout,\r\n      clearAgentTimeoutFailureReason,\r\n      updateAgentTimeoutState,\r\n      updateAgentTimeoutParticipantExists,\r\n    ],\r\n  );\r\n\r\n  const conversationState = React.useMemo(():\r\n    | SessionStateConnecting\r\n    | SessionStateConnected\r\n    | SessionStateDisconnected => {\r\n    const common: SessionStateCommon = {\r\n      room,\r\n      internal: sessionInternal,\r\n    };\r\n\r\n    switch (roomConnectionState) {\r\n      case ConnectionState.Connecting:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: ConnectionState.Connecting,\r\n          ...generateDerivedConnectionStateValues(ConnectionState.Connecting),\r\n\r\n          local: {\r\n            cameraTrack: undefined,\r\n            microphoneTrack: undefined,\r\n            screenShareTrack: undefined,\r\n          },\r\n        };\r\n\r\n      case ConnectionState.Connected:\r\n      case ConnectionState.Reconnecting:\r\n      case ConnectionState.SignalReconnecting:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: roomConnectionState,\r\n          ...generateDerivedConnectionStateValues(roomConnectionState),\r\n\r\n          local: {\r\n            cameraTrack: localCamera,\r\n            microphoneTrack: localMicrophone,\r\n            screenShareTrack: localScreenShare,\r\n          },\r\n        };\r\n\r\n      case ConnectionState.Disconnected:\r\n        return {\r\n          ...common,\r\n\r\n          connectionState: ConnectionState.Disconnected,\r\n          ...generateDerivedConnectionStateValues(ConnectionState.Disconnected),\r\n\r\n          local: {\r\n            cameraTrack: undefined,\r\n            microphoneTrack: undefined,\r\n            screenShareTrack: undefined,\r\n          },\r\n        };\r\n    }\r\n  }, [\r\n    sessionInternal,\r\n    room,\r\n    roomConnectionState,\r\n    localCamera,\r\n    localMicrophone,\r\n    generateDerivedConnectionStateValues,\r\n  ]);\r\n  React.useEffect(() => {\r\n    emitter.emit(SessionEvent.ConnectionStateChanged, conversationState.connectionState);\r\n  }, [emitter, conversationState.connectionState]);\r\n\r\n  const waitUntilConnectionState = useSessionWaitUntilConnectionState(\r\n    emitter,\r\n    conversationState.connectionState,\r\n  );\r\n\r\n  const waitUntilConnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      return waitUntilConnectionState(\r\n        ConnectionState.Connected /* FIXME: should I check for other states too? */,\r\n        signal,\r\n      );\r\n    },\r\n    [waitUntilConnectionState],\r\n  );\r\n\r\n  const waitUntilDisconnected = React.useCallback(\r\n    async (signal?: AbortSignal) => {\r\n      return waitUntilConnectionState(ConnectionState.Disconnected, signal);\r\n    },\r\n    [waitUntilConnectionState],\r\n  );\r\n\r\n  const agent = useAgent(\r\n    React.useMemo(\r\n      () => ({\r\n        connectionState: conversationState.connectionState,\r\n        room,\r\n        internal: sessionInternal,\r\n      }),\r\n      [conversationState, room, sessionInternal],\r\n    ),\r\n  );\r\n\r\n  const tokenSourceFetch = useSessionTokenSourceFetch(tokenSource, restOptions);\r\n\r\n  const start = React.useCallback(\r\n    async (connectOptions: SessionConnectOptions = {}) => {\r\n      const {\r\n        signal,\r\n        tracks = { microphone: { enabled: true, publishOptions: { preConnectBuffer: true } } },\r\n        roomConnectOptions,\r\n      } = connectOptions;\r\n\r\n      await waitUntilDisconnected(signal);\r\n\r\n      const onSignalAbort = () => {\r\n        room.disconnect();\r\n      };\r\n      signal?.addEventListener('abort', onSignalAbort);\r\n\r\n      let tokenDispatchesAgent = false;\r\n      await Promise.all([\r\n        tokenSourceFetch().then(({ serverUrl, participantToken }) => {\r\n          const participantTokenPayload = decodeTokenPayload(participantToken);\r\n          const participantTokenAgentDispatchCount =\r\n            participantTokenPayload.roomConfig?.agents?.length ?? 0;\r\n          tokenDispatchesAgent = participantTokenAgentDispatchCount > 0;\r\n\r\n          return room.connect(serverUrl, participantToken, roomConnectOptions);\r\n        }),\r\n\r\n        // Start microphone (with preconnect buffer) by default\r\n        tracks.microphone?.enabled\r\n          ? room.localParticipant.setMicrophoneEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.microphone?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n        tracks.camera?.enabled\r\n          ? room.localParticipant.setCameraEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.camera?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n        tracks.screenShare?.enabled\r\n          ? room.localParticipant.setScreenShareEnabled(\r\n              true,\r\n              undefined,\r\n              tracks.screenShare?.publishOptions ?? {},\r\n            )\r\n          : Promise.resolve(),\r\n      ]);\r\n\r\n      await waitUntilConnected(signal);\r\n      if (tokenDispatchesAgent) {\r\n        await agent.waitUntilConnected(signal);\r\n      }\r\n\r\n      signal?.removeEventListener('abort', onSignalAbort);\r\n    },\r\n    [room, waitUntilDisconnected, tokenSourceFetch, waitUntilConnected, agent.waitUntilConnected],\r\n  );\r\n\r\n  const end = React.useCallback(async () => {\r\n    await room.disconnect();\r\n  }, [room]);\r\n\r\n  const prepareConnection = React.useCallback(async () => {\r\n    const credentials = await tokenSourceFetch();\r\n    await room.prepareConnection(credentials.serverUrl, credentials.participantToken);\r\n  }, [tokenSourceFetch, room]);\r\n  React.useEffect(\r\n    () => {\r\n      prepareConnection().catch((err) => {\r\n        // FIXME: figure out a better logging solution?\r\n        console.warn('WARNING: Room.prepareConnection failed:', err);\r\n      });\r\n    },\r\n    [\r\n      /* note: no prepareConnection here, this effect should only ever run once! */\r\n    ],\r\n  );\r\n\r\n  return React.useMemo(\r\n    () => ({\r\n      ...conversationState,\r\n\r\n      waitUntilConnected,\r\n      waitUntilDisconnected,\r\n\r\n      prepareConnection,\r\n      start,\r\n      end,\r\n    }),\r\n    [conversationState, waitUntilConnected, waitUntilDisconnected, prepareConnection, start, end],\r\n  );\r\n}\r\n","import * as React from 'react';\r\nimport TypedEventEmitter, { EventMap } from 'typed-emitter';\r\n\r\n/** @public */\r\nexport function useEvents<\r\n  Emitter extends TypedEventEmitter<EventMap>,\r\n  EmitterEventMap extends Emitter extends TypedEventEmitter<infer EM> ? EM : never,\r\n  Event extends Parameters<Emitter['on']>[0],\r\n  Callback extends EmitterEventMap[Event],\r\n>(\r\n  instance: Emitter | { internal: { emitter: Emitter } } | null | undefined,\r\n  event: Event,\r\n  handlerFn: Callback | undefined,\r\n  dependencies?: React.DependencyList,\r\n) {\r\n  const fallback = React.useMemo(() => () => {}, []);\r\n  const wrappedCallback = React.useCallback(handlerFn ?? fallback, dependencies ?? []);\r\n  const callback = dependencies ? wrappedCallback : handlerFn;\r\n\r\n  const emitter = React.useMemo(() => {\r\n    if (!instance) {\r\n      return null;\r\n    }\r\n    if ('internal' in instance) {\r\n      return instance.internal.emitter;\r\n    }\r\n    return instance;\r\n  }, [instance]);\r\n\r\n  React.useEffect(() => {\r\n    if (!emitter || !callback) {\r\n      return;\r\n    }\r\n    emitter.on(event, callback);\r\n    return () => {\r\n      emitter.off(event, callback);\r\n    };\r\n  }, [emitter, event, callback]);\r\n}\r\n","import * as React from 'react';\r\nimport type TypedEventEmitter from 'typed-emitter';\r\nimport { SendTextOptions } from 'livekit-client';\r\nimport { EventEmitter } from 'events';\r\nimport {\r\n  ReceivedMessage,\r\n  ReceivedChatMessage,\r\n  TextStreamData,\r\n  ReceivedUserTranscriptionMessage,\r\n  ReceivedAgentTranscriptionMessage,\r\n} from '@livekit/components-core';\r\n\r\nimport { useAgent } from './useAgent';\r\nimport { useTranscriptions } from './useTranscriptions';\r\nimport { useChat } from './useChat';\r\nimport { UseSessionReturn } from './useSession';\r\nimport { useEnsureSession } from '../context';\r\n\r\n/** @beta */\r\nexport type UseSessionMessagesReturn = {\r\n  messages: Array<ReceivedMessage>;\r\n\r\n  /** Is a send operation currently in progress? */\r\n  isSending: boolean;\r\n\r\n  send: (message: string, options?: SendTextOptions) => Promise<ReceivedChatMessage>;\r\n\r\n  internal: {\r\n    emitter: TypedEventEmitter<MessagesCallbacks>;\r\n  };\r\n};\r\n\r\n/** @beta */\r\nexport enum MessagesEvent {\r\n  /**\r\n   * Emits when a new message is received from a participant\r\n   * args: (message: ReceivedMessage)\r\n   */\r\n  MessageReceived = 'messageReceived',\r\n}\r\n\r\n/** @beta */\r\nexport type MessagesCallbacks = {\r\n  [MessagesEvent.MessageReceived]: (message: ReceivedMessage) => void;\r\n};\r\n\r\n/** @beta */\r\nexport function useSessionMessages(session?: UseSessionReturn): UseSessionMessagesReturn {\r\n  const { room } = useEnsureSession(session);\r\n\r\n  const emitter = React.useMemo(\r\n    () => new EventEmitter() as TypedEventEmitter<MessagesCallbacks>,\r\n    [],\r\n  );\r\n\r\n  const agent = useAgent(session);\r\n\r\n  const transcriptions: Array<TextStreamData> = useTranscriptions({ room });\r\n  const chatOptions = React.useMemo(() => ({ room }), [room]);\r\n  const chat = useChat(chatOptions);\r\n\r\n  const transcriptionMessages: Array<\r\n    ReceivedUserTranscriptionMessage | ReceivedAgentTranscriptionMessage\r\n  > = React.useMemo(() => {\r\n    return transcriptions.map((transcription) => {\r\n      switch (transcription.participantInfo.identity) {\r\n        case room.localParticipant.identity:\r\n          return {\r\n            type: 'userTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from: room.localParticipant,\r\n          };\r\n\r\n        case agent.internal.agentParticipant?.identity:\r\n        case agent.internal.workerParticipant?.identity:\r\n          return {\r\n            type: 'agentTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from:\r\n              agent.internal.agentParticipant?.identity === transcription.participantInfo.identity\r\n                ? agent.internal.agentParticipant\r\n                : agent.internal.workerParticipant!,\r\n          };\r\n\r\n        default:\r\n          // FIXME: what should happen if an associated participant is not found?\r\n          //\r\n          // For now, just assume it is an agent transcription, since maybe it is from an agent\r\n          // which disconencted from the room or something like that.\r\n          return {\r\n            type: 'agentTranscript',\r\n            message: transcription.text,\r\n\r\n            id: transcription.streamInfo.id,\r\n            timestamp: transcription.streamInfo.timestamp,\r\n            from: Array.from(room.remoteParticipants.values()).find(\r\n              (p) => p.identity === transcription.participantInfo.identity,\r\n            ),\r\n          };\r\n      }\r\n    });\r\n  }, [transcriptions, room]);\r\n\r\n  const receivedMessages = React.useMemo(() => {\r\n    const merged: Array<ReceivedMessage> = [...transcriptionMessages, ...chat.chatMessages];\r\n    return merged;\r\n  }, [transcriptionMessages, chat.chatMessages]);\r\n\r\n  const messageFirstReceivedTimeMapRef = React.useRef(new Map<ReceivedMessage['id'], Date>());\r\n  const sortedReceivedMessages = React.useMemo(() => {\r\n    const now = new Date();\r\n    for (const message of receivedMessages) {\r\n      if (messageFirstReceivedTimeMapRef.current.has(message.id)) {\r\n        continue;\r\n      }\r\n\r\n      messageFirstReceivedTimeMapRef.current.set(message.id, now);\r\n    }\r\n\r\n    return receivedMessages.sort((a, b) => {\r\n      const aFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(a.id);\r\n      const bFirstReceivedAt = messageFirstReceivedTimeMapRef.current.get(b.id);\r\n      if (typeof aFirstReceivedAt === 'undefined' || typeof bFirstReceivedAt === 'undefined') {\r\n        return 0;\r\n      }\r\n\r\n      return aFirstReceivedAt.getTime() - bFirstReceivedAt.getTime();\r\n    });\r\n  }, [receivedMessages]);\r\n\r\n  const previouslyReceivedMessageIdsRef = React.useRef(new Set());\r\n  React.useEffect(() => {\r\n    for (const message of sortedReceivedMessages) {\r\n      if (previouslyReceivedMessageIdsRef.current.has(message.id)) {\r\n        continue;\r\n      }\r\n\r\n      previouslyReceivedMessageIdsRef.current.add(message.id);\r\n      emitter.emit(MessagesEvent.MessageReceived, message);\r\n    }\r\n  }, [sortedReceivedMessages]);\r\n\r\n  return React.useMemo(\r\n    () => ({\r\n      messages: sortedReceivedMessages,\r\n      send: chat.send,\r\n      isSending: chat.isSending,\r\n      internal: { emitter },\r\n    }),\r\n    [sortedReceivedMessages, chat.send, chat.isSending],\r\n  );\r\n}\r\n"],"names":["SessionContext","React","useSessionContext","ctx","useMaybeSessionContext","useEnsureSession","session","context","r","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","observable","roomAudioPlaybackAllowedObservable","canPlayAudio","useObservableState","useClearPinButton","props","state","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useDataChannel","topicOrCallback","callback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","defaultRoomProps","useLiveKitRoom","token","serverUrl","options","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","log","setRoom","shouldConnect","Room","roomOptionsStringifyReplacer","htmlProps","setupLiveKitRoom","onSignalConnected","localP","e","handleMediaDeviceError","kind","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useParticipantInfo","p","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useEnsureParticipant","permissionObserver","participantPermissionObserver","useRemoteParticipants","participants","setParticipants","listener","connectedParticipantsObserver","useParticipants","remoteParticipants","localParticipant","useLocalParticipant","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","ensuredRoom","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useToken","tokenEndpoint","roomName","setToken","_a","params","res","accessToken","useTrackRefBySourceOrName","source","publication","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","subscription","Track","useTrackByName","participant","useParticipantTracks","sources","optionsOrParticipantIdentity","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","ref","trackSyncTimeObserver","_c","_b","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","trackRef","opts","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","s","addTimestampsToTranscription","trackTranscriptionObserver","evt","getTrackReferenceId","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","val","state_attribute","ParticipantAgentAttributes","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","connectionState","useConnectionState","attributes","ConnectionState","useIsRecording","recordingStatusObservable","useTextStream","isDisconnected","textStreamData","setupTextStream","textStreamObservable","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream","CONNECT_DISCONNECT_WARNING_THRESHOLD_QUANTITY","CONNECT_DISCONNECT_WARNING_THRESHOLD_MS","ROOM_CHANGE_WARNING_THRESHOLD_QUANTITY","ROOM_CHANGE_WARNING_THRESHOLD_MS","useSequentialRoomConnectDisconnect","connectDisconnectQueueRef","useRef","processConnectsAndDisconnectsLock","useMemo","Mutex","processConnectsAndDisconnects","useCallback","unlock","roomChangedTimesRef","checkRoomThreshold","now","roomChangesInThreshold","i","isWithinThreshold","useEffect","connectDisconnectEnqueueTimes","checkConnectDisconnectThreshold","connectDisconnectsInThreshold","args","resolve","reject","disconnect","R","ReflectApply","target","receiver","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","value","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","arg","n","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","key","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","index","ret","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","DEFAULT_AGENT_CONNECT_TIMEOUT_MILLISECONDS","AgentEvent","generateDerivedStateValues","useAgentTimeoutIdStore","agentTimeoutFailureReason","setAgentTimeoutFailureReason","agentTimeoutId","setAgentTimeoutId","agentStateRef","agentParticipantExistsRef","startAgentConnectedTimeout","agentConnectTimeoutMilliseconds","isConnected","agentState","agentParticipantExists","useAgentWaitUntilDerivedStates","stateRef","waitUntilConnected","signal","stateChangedHandler","cleanup","abortHandler","waitUntilCouldBeListening","canListen","waitUntilFinished","isFinished","useAgent","sessionFromContext","startAgentTimeout","clearAgentTimeout","clearAgentTimeoutFailureReason","updateAgentTimeoutState","updateAgentTimeoutParticipantExists","roomRemoteParticipants","agentParticipant","workerParticipant","agentParticipantAttributes","setAgentParticipantAttributes","handleAttributesChanged","ParticipantEvent","roomConnectionState","setRoomConnectionState","handleConnectionStateChanged","agentDisconnectedFailureReason","setAgentDisconnectedFailureReason","onParticipantDisconnect","localMicTrack","setLocalMicTrack","handleLocalParticipantTrackPublished","handleLocalParticipantTrackUnPublished","failureReasons","reasons","isSessionDisconnected","agentParticipantIdentity","agentParticipantName","agentParticipantMetadata","common","waitUntilCamera","camera","waitUntilMicrophone","microphone","SessionEvent","areTokenSourceFetchOptionsEqual","a","b","allKeysSet","exhaustiveCheckedKey","useSessionWaitUntilConnectionState","connectionStateRef","onceEventOccurred","newState","useSessionTokenSourceFetch","tokenSource","unstableRestOptions","isConfigurable","TokenSourceConfigurable","memoizedTokenFetchOptionsRef","useSession","optionsRoom","restOptions","roomFromContext","useMaybeRoomContext","generateDerivedConnectionStateValues","handleMediaDevicesError","error","cameraPublication","localCamera","microphonePublication","localMicrophone","screenSharePublication","localScreenShare","sessionInternal","conversationState","waitUntilConnectionState","waitUntilDisconnected","tokenSourceFetch","start","tracks","roomConnectOptions","onSignalAbort","tokenDispatchesAgent","participantToken","decodeTokenPayload","_d","_e","_f","end","prepareConnection","credentials","useEvents","instance","event","handlerFn","dependencies","fallback","wrappedCallback","MessagesEvent","useSessionMessages","transcriptions","chatOptions","chat","useChat","transcriptionMessages","transcription","receivedMessages","messageFirstReceivedTimeMapRef","sortedReceivedMessages","aFirstReceivedAt","bFirstReceivedAt","previouslyReceivedMessageIdsRef"],"mappings":"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","x_google_ignoreList":[25]}